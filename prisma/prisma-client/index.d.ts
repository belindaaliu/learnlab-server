
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AssessmentOptions
 * 
 */
export type AssessmentOptions = $Result.DefaultSelection<Prisma.$AssessmentOptionsPayload>
/**
 * Model AssessmentQuestions
 * 
 */
export type AssessmentQuestions = $Result.DefaultSelection<Prisma.$AssessmentQuestionsPayload>
/**
 * Model Assessments
 * 
 */
export type Assessments = $Result.DefaultSelection<Prisma.$AssessmentsPayload>
/**
 * Model Categories
 * 
 */
export type Categories = $Result.DefaultSelection<Prisma.$CategoriesPayload>
/**
 * Model Certificates
 * 
 */
export type Certificates = $Result.DefaultSelection<Prisma.$CertificatesPayload>
/**
 * Model CourseContent
 * 
 */
export type CourseContent = $Result.DefaultSelection<Prisma.$CourseContentPayload>
/**
 * Model CourseTags
 * 
 */
export type CourseTags = $Result.DefaultSelection<Prisma.$CourseTagsPayload>
/**
 * Model Courses
 * 
 */
export type Courses = $Result.DefaultSelection<Prisma.$CoursesPayload>
/**
 * Model Enrollments
 * 
 */
export type Enrollments = $Result.DefaultSelection<Prisma.$EnrollmentsPayload>
/**
 * Model LessonProgress
 * 
 */
export type LessonProgress = $Result.DefaultSelection<Prisma.$LessonProgressPayload>
/**
 * Model Messages
 * 
 */
export type Messages = $Result.DefaultSelection<Prisma.$MessagesPayload>
/**
 * Model MultiFactorAuth
 * 
 */
export type MultiFactorAuth = $Result.DefaultSelection<Prisma.$MultiFactorAuthPayload>
/**
 * Model Notifications
 * 
 */
export type Notifications = $Result.DefaultSelection<Prisma.$NotificationsPayload>
/**
 * Model Payments
 * 
 */
export type Payments = $Result.DefaultSelection<Prisma.$PaymentsPayload>
/**
 * Model QuizAttempts
 * 
 */
export type QuizAttempts = $Result.DefaultSelection<Prisma.$QuizAttemptsPayload>
/**
 * Model Reviews
 * 
 */
export type Reviews = $Result.DefaultSelection<Prisma.$ReviewsPayload>
/**
 * Model ShoppingCart
 * 
 */
export type ShoppingCart = $Result.DefaultSelection<Prisma.$ShoppingCartPayload>
/**
 * Model SubscriptionPlans
 * 
 */
export type SubscriptionPlans = $Result.DefaultSelection<Prisma.$SubscriptionPlansPayload>
/**
 * Model Subscriptions
 * 
 */
export type Subscriptions = $Result.DefaultSelection<Prisma.$SubscriptionsPayload>
/**
 * Model UserAnswers
 * 
 */
export type UserAnswers = $Result.DefaultSelection<Prisma.$UserAnswersPayload>
/**
 * Model UserSavedCourses
 * 
 */
export type UserSavedCourses = $Result.DefaultSelection<Prisma.$UserSavedCoursesPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AssessmentQuestions_question_type: {
  mcq: 'mcq',
  truefalse: 'truefalse',
  text: 'text'
};

export type AssessmentQuestions_question_type = (typeof AssessmentQuestions_question_type)[keyof typeof AssessmentQuestions_question_type]


export const CourseContent_type: {
  section: 'section',
  video: 'video',
  note: 'note',
  assessment: 'assessment'
};

export type CourseContent_type = (typeof CourseContent_type)[keyof typeof CourseContent_type]


export const CourseTags_tag_type: {
  topic: 'topic',
  keyword: 'keyword'
};

export type CourseTags_tag_type = (typeof CourseTags_tag_type)[keyof typeof CourseTags_tag_type]


export const Courses_level: {
  beginner: 'beginner',
  intermediate: 'intermediate',
  advanced: 'advanced',
  all_levels: 'all_levels'
};

export type Courses_level = (typeof Courses_level)[keyof typeof Courses_level]


export const MultiFactorAuth_mfa_type: {
  email: 'email',
  sms: 'sms',
  authenticator: 'authenticator'
};

export type MultiFactorAuth_mfa_type = (typeof MultiFactorAuth_mfa_type)[keyof typeof MultiFactorAuth_mfa_type]


export const Notifications_type: {
  course_enrollment: 'course_enrollment',
  new_message: 'new_message',
  new_review: 'new_review',
  certificate_issued: 'certificate_issued',
  course_update: 'course_update',
  announcement: 'announcement',
  quiz_graded: 'quiz_graded',
  subscription_expiring: 'subscription_expiring'
};

export type Notifications_type = (typeof Notifications_type)[keyof typeof Notifications_type]


export const Payments_method: {
  stripe: 'stripe',
  paypal: 'paypal'
};

export type Payments_method = (typeof Payments_method)[keyof typeof Payments_method]


export const Payments_status: {
  paid: 'paid',
  failed: 'failed',
  refunded: 'refunded'
};

export type Payments_status = (typeof Payments_status)[keyof typeof Payments_status]


export const Subscriptions_status: {
  active: 'active',
  canceled: 'canceled',
  expired: 'expired'
};

export type Subscriptions_status = (typeof Subscriptions_status)[keyof typeof Subscriptions_status]


export const Users_role: {
  student: 'student',
  instructor: 'instructor',
  admin: 'admin'
};

export type Users_role = (typeof Users_role)[keyof typeof Users_role]


export const Users_instructor_application_status: {
  none: 'none',
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type Users_instructor_application_status = (typeof Users_instructor_application_status)[keyof typeof Users_instructor_application_status]

}

export type AssessmentQuestions_question_type = $Enums.AssessmentQuestions_question_type

export const AssessmentQuestions_question_type: typeof $Enums.AssessmentQuestions_question_type

export type CourseContent_type = $Enums.CourseContent_type

export const CourseContent_type: typeof $Enums.CourseContent_type

export type CourseTags_tag_type = $Enums.CourseTags_tag_type

export const CourseTags_tag_type: typeof $Enums.CourseTags_tag_type

export type Courses_level = $Enums.Courses_level

export const Courses_level: typeof $Enums.Courses_level

export type MultiFactorAuth_mfa_type = $Enums.MultiFactorAuth_mfa_type

export const MultiFactorAuth_mfa_type: typeof $Enums.MultiFactorAuth_mfa_type

export type Notifications_type = $Enums.Notifications_type

export const Notifications_type: typeof $Enums.Notifications_type

export type Payments_method = $Enums.Payments_method

export const Payments_method: typeof $Enums.Payments_method

export type Payments_status = $Enums.Payments_status

export const Payments_status: typeof $Enums.Payments_status

export type Subscriptions_status = $Enums.Subscriptions_status

export const Subscriptions_status: typeof $Enums.Subscriptions_status

export type Users_role = $Enums.Users_role

export const Users_role: typeof $Enums.Users_role

export type Users_instructor_application_status = $Enums.Users_instructor_application_status

export const Users_instructor_application_status: typeof $Enums.Users_instructor_application_status

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AssessmentOptions
 * const assessmentOptions = await prisma.assessmentOptions.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AssessmentOptions
   * const assessmentOptions = await prisma.assessmentOptions.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.assessmentOptions`: Exposes CRUD operations for the **AssessmentOptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentOptions
    * const assessmentOptions = await prisma.assessmentOptions.findMany()
    * ```
    */
  get assessmentOptions(): Prisma.AssessmentOptionsDelegate<ExtArgs>;

  /**
   * `prisma.assessmentQuestions`: Exposes CRUD operations for the **AssessmentQuestions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentQuestions
    * const assessmentQuestions = await prisma.assessmentQuestions.findMany()
    * ```
    */
  get assessmentQuestions(): Prisma.AssessmentQuestionsDelegate<ExtArgs>;

  /**
   * `prisma.assessments`: Exposes CRUD operations for the **Assessments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assessments
    * const assessments = await prisma.assessments.findMany()
    * ```
    */
  get assessments(): Prisma.AssessmentsDelegate<ExtArgs>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **Categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.CategoriesDelegate<ExtArgs>;

  /**
   * `prisma.certificates`: Exposes CRUD operations for the **Certificates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificates.findMany()
    * ```
    */
  get certificates(): Prisma.CertificatesDelegate<ExtArgs>;

  /**
   * `prisma.courseContent`: Exposes CRUD operations for the **CourseContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseContents
    * const courseContents = await prisma.courseContent.findMany()
    * ```
    */
  get courseContent(): Prisma.CourseContentDelegate<ExtArgs>;

  /**
   * `prisma.courseTags`: Exposes CRUD operations for the **CourseTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseTags
    * const courseTags = await prisma.courseTags.findMany()
    * ```
    */
  get courseTags(): Prisma.CourseTagsDelegate<ExtArgs>;

  /**
   * `prisma.courses`: Exposes CRUD operations for the **Courses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.courses.findMany()
    * ```
    */
  get courses(): Prisma.CoursesDelegate<ExtArgs>;

  /**
   * `prisma.enrollments`: Exposes CRUD operations for the **Enrollments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollments.findMany()
    * ```
    */
  get enrollments(): Prisma.EnrollmentsDelegate<ExtArgs>;

  /**
   * `prisma.lessonProgress`: Exposes CRUD operations for the **LessonProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonProgresses
    * const lessonProgresses = await prisma.lessonProgress.findMany()
    * ```
    */
  get lessonProgress(): Prisma.LessonProgressDelegate<ExtArgs>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **Messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.MessagesDelegate<ExtArgs>;

  /**
   * `prisma.multiFactorAuth`: Exposes CRUD operations for the **MultiFactorAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultiFactorAuths
    * const multiFactorAuths = await prisma.multiFactorAuth.findMany()
    * ```
    */
  get multiFactorAuth(): Prisma.MultiFactorAuthDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **Payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.PaymentsDelegate<ExtArgs>;

  /**
   * `prisma.quizAttempts`: Exposes CRUD operations for the **QuizAttempts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAttempts
    * const quizAttempts = await prisma.quizAttempts.findMany()
    * ```
    */
  get quizAttempts(): Prisma.QuizAttemptsDelegate<ExtArgs>;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **Reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.ReviewsDelegate<ExtArgs>;

  /**
   * `prisma.shoppingCart`: Exposes CRUD operations for the **ShoppingCart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShoppingCarts
    * const shoppingCarts = await prisma.shoppingCart.findMany()
    * ```
    */
  get shoppingCart(): Prisma.ShoppingCartDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionPlans`: Exposes CRUD operations for the **SubscriptionPlans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlans.findMany()
    * ```
    */
  get subscriptionPlans(): Prisma.SubscriptionPlansDelegate<ExtArgs>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **Subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.SubscriptionsDelegate<ExtArgs>;

  /**
   * `prisma.userAnswers`: Exposes CRUD operations for the **UserAnswers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAnswers
    * const userAnswers = await prisma.userAnswers.findMany()
    * ```
    */
  get userAnswers(): Prisma.UserAnswersDelegate<ExtArgs>;

  /**
   * `prisma.userSavedCourses`: Exposes CRUD operations for the **UserSavedCourses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSavedCourses
    * const userSavedCourses = await prisma.userSavedCourses.findMany()
    * ```
    */
  get userSavedCourses(): Prisma.UserSavedCoursesDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.0
   * Query Engine version: 12e25d8d06f6ea5a0252864dd9a03b1bb51f3022
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AssessmentOptions: 'AssessmentOptions',
    AssessmentQuestions: 'AssessmentQuestions',
    Assessments: 'Assessments',
    Categories: 'Categories',
    Certificates: 'Certificates',
    CourseContent: 'CourseContent',
    CourseTags: 'CourseTags',
    Courses: 'Courses',
    Enrollments: 'Enrollments',
    LessonProgress: 'LessonProgress',
    Messages: 'Messages',
    MultiFactorAuth: 'MultiFactorAuth',
    Notifications: 'Notifications',
    Payments: 'Payments',
    QuizAttempts: 'QuizAttempts',
    Reviews: 'Reviews',
    ShoppingCart: 'ShoppingCart',
    SubscriptionPlans: 'SubscriptionPlans',
    Subscriptions: 'Subscriptions',
    UserAnswers: 'UserAnswers',
    UserSavedCourses: 'UserSavedCourses',
    Users: 'Users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'assessmentOptions' | 'assessmentQuestions' | 'assessments' | 'categories' | 'certificates' | 'courseContent' | 'courseTags' | 'courses' | 'enrollments' | 'lessonProgress' | 'messages' | 'multiFactorAuth' | 'notifications' | 'payments' | 'quizAttempts' | 'reviews' | 'shoppingCart' | 'subscriptionPlans' | 'subscriptions' | 'userAnswers' | 'userSavedCourses' | 'users'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      AssessmentOptions: {
        payload: Prisma.$AssessmentOptionsPayload<ExtArgs>
        fields: Prisma.AssessmentOptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentOptionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentOptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentOptionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentOptionsPayload>
          }
          findFirst: {
            args: Prisma.AssessmentOptionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentOptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentOptionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentOptionsPayload>
          }
          findMany: {
            args: Prisma.AssessmentOptionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentOptionsPayload>[]
          }
          create: {
            args: Prisma.AssessmentOptionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentOptionsPayload>
          }
          createMany: {
            args: Prisma.AssessmentOptionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AssessmentOptionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentOptionsPayload>
          }
          update: {
            args: Prisma.AssessmentOptionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentOptionsPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentOptionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentOptionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentOptionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentOptionsPayload>
          }
          aggregate: {
            args: Prisma.AssessmentOptionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAssessmentOptions>
          }
          groupBy: {
            args: Prisma.AssessmentOptionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssessmentOptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentOptionsCountArgs<ExtArgs>,
            result: $Utils.Optional<AssessmentOptionsCountAggregateOutputType> | number
          }
        }
      }
      AssessmentQuestions: {
        payload: Prisma.$AssessmentQuestionsPayload<ExtArgs>
        fields: Prisma.AssessmentQuestionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentQuestionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentQuestionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionsPayload>
          }
          findFirst: {
            args: Prisma.AssessmentQuestionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentQuestionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionsPayload>
          }
          findMany: {
            args: Prisma.AssessmentQuestionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionsPayload>[]
          }
          create: {
            args: Prisma.AssessmentQuestionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionsPayload>
          }
          createMany: {
            args: Prisma.AssessmentQuestionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AssessmentQuestionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionsPayload>
          }
          update: {
            args: Prisma.AssessmentQuestionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionsPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentQuestionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentQuestionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentQuestionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionsPayload>
          }
          aggregate: {
            args: Prisma.AssessmentQuestionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAssessmentQuestions>
          }
          groupBy: {
            args: Prisma.AssessmentQuestionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssessmentQuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentQuestionsCountArgs<ExtArgs>,
            result: $Utils.Optional<AssessmentQuestionsCountAggregateOutputType> | number
          }
        }
      }
      Assessments: {
        payload: Prisma.$AssessmentsPayload<ExtArgs>
        fields: Prisma.AssessmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>
          }
          findFirst: {
            args: Prisma.AssessmentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>
          }
          findMany: {
            args: Prisma.AssessmentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>[]
          }
          create: {
            args: Prisma.AssessmentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>
          }
          createMany: {
            args: Prisma.AssessmentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AssessmentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>
          }
          update: {
            args: Prisma.AssessmentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssessmentsPayload>
          }
          aggregate: {
            args: Prisma.AssessmentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAssessments>
          }
          groupBy: {
            args: Prisma.AssessmentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssessmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentsCountArgs<ExtArgs>,
            result: $Utils.Optional<AssessmentsCountAggregateOutputType> | number
          }
        }
      }
      Categories: {
        payload: Prisma.$CategoriesPayload<ExtArgs>
        fields: Prisma.CategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findFirst: {
            args: Prisma.CategoriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findMany: {
            args: Prisma.CategoriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          create: {
            args: Prisma.CategoriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          createMany: {
            args: Prisma.CategoriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          update: {
            args: Prisma.CategoriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          deleteMany: {
            args: Prisma.CategoriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.CategoriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriesCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      Certificates: {
        payload: Prisma.$CertificatesPayload<ExtArgs>
        fields: Prisma.CertificatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificatesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificatesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificatesPayload>
          }
          findFirst: {
            args: Prisma.CertificatesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificatesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificatesPayload>
          }
          findMany: {
            args: Prisma.CertificatesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificatesPayload>[]
          }
          create: {
            args: Prisma.CertificatesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificatesPayload>
          }
          createMany: {
            args: Prisma.CertificatesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CertificatesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificatesPayload>
          }
          update: {
            args: Prisma.CertificatesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificatesPayload>
          }
          deleteMany: {
            args: Prisma.CertificatesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CertificatesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CertificatesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CertificatesPayload>
          }
          aggregate: {
            args: Prisma.CertificatesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCertificates>
          }
          groupBy: {
            args: Prisma.CertificatesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CertificatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificatesCountArgs<ExtArgs>,
            result: $Utils.Optional<CertificatesCountAggregateOutputType> | number
          }
        }
      }
      CourseContent: {
        payload: Prisma.$CourseContentPayload<ExtArgs>
        fields: Prisma.CourseContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseContentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseContentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          findFirst: {
            args: Prisma.CourseContentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseContentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          findMany: {
            args: Prisma.CourseContentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>[]
          }
          create: {
            args: Prisma.CourseContentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          createMany: {
            args: Prisma.CourseContentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CourseContentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          update: {
            args: Prisma.CourseContentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          deleteMany: {
            args: Prisma.CourseContentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CourseContentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CourseContentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          aggregate: {
            args: Prisma.CourseContentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourseContent>
          }
          groupBy: {
            args: Prisma.CourseContentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CourseContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseContentCountArgs<ExtArgs>,
            result: $Utils.Optional<CourseContentCountAggregateOutputType> | number
          }
        }
      }
      CourseTags: {
        payload: Prisma.$CourseTagsPayload<ExtArgs>
        fields: Prisma.CourseTagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseTagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseTagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          findFirst: {
            args: Prisma.CourseTagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseTagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          findMany: {
            args: Prisma.CourseTagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>[]
          }
          create: {
            args: Prisma.CourseTagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          createMany: {
            args: Prisma.CourseTagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CourseTagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          update: {
            args: Prisma.CourseTagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          deleteMany: {
            args: Prisma.CourseTagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CourseTagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CourseTagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseTagsPayload>
          }
          aggregate: {
            args: Prisma.CourseTagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourseTags>
          }
          groupBy: {
            args: Prisma.CourseTagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CourseTagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseTagsCountArgs<ExtArgs>,
            result: $Utils.Optional<CourseTagsCountAggregateOutputType> | number
          }
        }
      }
      Courses: {
        payload: Prisma.$CoursesPayload<ExtArgs>
        fields: Prisma.CoursesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoursesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoursesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          findFirst: {
            args: Prisma.CoursesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoursesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          findMany: {
            args: Prisma.CoursesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>[]
          }
          create: {
            args: Prisma.CoursesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          createMany: {
            args: Prisma.CoursesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CoursesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          update: {
            args: Prisma.CoursesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          deleteMany: {
            args: Prisma.CoursesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CoursesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CoursesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          aggregate: {
            args: Prisma.CoursesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourses>
          }
          groupBy: {
            args: Prisma.CoursesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CoursesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoursesCountArgs<ExtArgs>,
            result: $Utils.Optional<CoursesCountAggregateOutputType> | number
          }
        }
      }
      Enrollments: {
        payload: Prisma.$EnrollmentsPayload<ExtArgs>
        fields: Prisma.EnrollmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnrollmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnrollmentsPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnrollmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnrollmentsPayload>
          }
          findMany: {
            args: Prisma.EnrollmentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnrollmentsPayload>[]
          }
          create: {
            args: Prisma.EnrollmentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnrollmentsPayload>
          }
          createMany: {
            args: Prisma.EnrollmentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EnrollmentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnrollmentsPayload>
          }
          update: {
            args: Prisma.EnrollmentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnrollmentsPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EnrollmentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnrollmentsPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEnrollments>
          }
          groupBy: {
            args: Prisma.EnrollmentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EnrollmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentsCountArgs<ExtArgs>,
            result: $Utils.Optional<EnrollmentsCountAggregateOutputType> | number
          }
        }
      }
      LessonProgress: {
        payload: Prisma.$LessonProgressPayload<ExtArgs>
        fields: Prisma.LessonProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonProgressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonProgressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          findFirst: {
            args: Prisma.LessonProgressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonProgressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          findMany: {
            args: Prisma.LessonProgressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
          }
          create: {
            args: Prisma.LessonProgressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          createMany: {
            args: Prisma.LessonProgressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LessonProgressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          update: {
            args: Prisma.LessonProgressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          deleteMany: {
            args: Prisma.LessonProgressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LessonProgressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LessonProgressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          aggregate: {
            args: Prisma.LessonProgressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLessonProgress>
          }
          groupBy: {
            args: Prisma.LessonProgressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LessonProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonProgressCountArgs<ExtArgs>,
            result: $Utils.Optional<LessonProgressCountAggregateOutputType> | number
          }
        }
      }
      Messages: {
        payload: Prisma.$MessagesPayload<ExtArgs>
        fields: Prisma.MessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessagesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessagesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          findFirst: {
            args: Prisma.MessagesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessagesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          findMany: {
            args: Prisma.MessagesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>[]
          }
          create: {
            args: Prisma.MessagesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          createMany: {
            args: Prisma.MessagesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessagesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          update: {
            args: Prisma.MessagesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          deleteMany: {
            args: Prisma.MessagesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessagesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessagesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.MessagesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessagesCountArgs<ExtArgs>,
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      MultiFactorAuth: {
        payload: Prisma.$MultiFactorAuthPayload<ExtArgs>
        fields: Prisma.MultiFactorAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultiFactorAuthFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultiFactorAuthFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthPayload>
          }
          findFirst: {
            args: Prisma.MultiFactorAuthFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultiFactorAuthFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthPayload>
          }
          findMany: {
            args: Prisma.MultiFactorAuthFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthPayload>[]
          }
          create: {
            args: Prisma.MultiFactorAuthCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthPayload>
          }
          createMany: {
            args: Prisma.MultiFactorAuthCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MultiFactorAuthDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthPayload>
          }
          update: {
            args: Prisma.MultiFactorAuthUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthPayload>
          }
          deleteMany: {
            args: Prisma.MultiFactorAuthDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MultiFactorAuthUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MultiFactorAuthUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthPayload>
          }
          aggregate: {
            args: Prisma.MultiFactorAuthAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMultiFactorAuth>
          }
          groupBy: {
            args: Prisma.MultiFactorAuthGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MultiFactorAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultiFactorAuthCountArgs<ExtArgs>,
            result: $Utils.Optional<MultiFactorAuthCountAggregateOutputType> | number
          }
        }
      }
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>
        fields: Prisma.NotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      Payments: {
        payload: Prisma.$PaymentsPayload<ExtArgs>
        fields: Prisma.PaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findFirst: {
            args: Prisma.PaymentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findMany: {
            args: Prisma.PaymentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          create: {
            args: Prisma.PaymentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          createMany: {
            args: Prisma.PaymentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          update: {
            args: Prisma.PaymentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.PaymentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentsCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      QuizAttempts: {
        payload: Prisma.$QuizAttemptsPayload<ExtArgs>
        fields: Prisma.QuizAttemptsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAttemptsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAttemptsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptsPayload>
          }
          findFirst: {
            args: Prisma.QuizAttemptsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAttemptsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptsPayload>
          }
          findMany: {
            args: Prisma.QuizAttemptsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptsPayload>[]
          }
          create: {
            args: Prisma.QuizAttemptsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptsPayload>
          }
          createMany: {
            args: Prisma.QuizAttemptsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.QuizAttemptsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptsPayload>
          }
          update: {
            args: Prisma.QuizAttemptsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptsPayload>
          }
          deleteMany: {
            args: Prisma.QuizAttemptsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAttemptsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.QuizAttemptsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptsPayload>
          }
          aggregate: {
            args: Prisma.QuizAttemptsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuizAttempts>
          }
          groupBy: {
            args: Prisma.QuizAttemptsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuizAttemptsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAttemptsCountArgs<ExtArgs>,
            result: $Utils.Optional<QuizAttemptsCountAggregateOutputType> | number
          }
        }
      }
      Reviews: {
        payload: Prisma.$ReviewsPayload<ExtArgs>
        fields: Prisma.ReviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          findFirst: {
            args: Prisma.ReviewsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          findMany: {
            args: Prisma.ReviewsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>[]
          }
          create: {
            args: Prisma.ReviewsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          createMany: {
            args: Prisma.ReviewsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReviewsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          update: {
            args: Prisma.ReviewsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          deleteMany: {
            args: Prisma.ReviewsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReviewsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          aggregate: {
            args: Prisma.ReviewsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReviews>
          }
          groupBy: {
            args: Prisma.ReviewsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewsCountArgs<ExtArgs>,
            result: $Utils.Optional<ReviewsCountAggregateOutputType> | number
          }
        }
      }
      ShoppingCart: {
        payload: Prisma.$ShoppingCartPayload<ExtArgs>
        fields: Prisma.ShoppingCartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShoppingCartFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoppingCartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShoppingCartFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoppingCartPayload>
          }
          findFirst: {
            args: Prisma.ShoppingCartFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoppingCartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShoppingCartFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoppingCartPayload>
          }
          findMany: {
            args: Prisma.ShoppingCartFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoppingCartPayload>[]
          }
          create: {
            args: Prisma.ShoppingCartCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoppingCartPayload>
          }
          createMany: {
            args: Prisma.ShoppingCartCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShoppingCartDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoppingCartPayload>
          }
          update: {
            args: Prisma.ShoppingCartUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoppingCartPayload>
          }
          deleteMany: {
            args: Prisma.ShoppingCartDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShoppingCartUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShoppingCartUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoppingCartPayload>
          }
          aggregate: {
            args: Prisma.ShoppingCartAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShoppingCart>
          }
          groupBy: {
            args: Prisma.ShoppingCartGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShoppingCartGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShoppingCartCountArgs<ExtArgs>,
            result: $Utils.Optional<ShoppingCartCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlans: {
        payload: Prisma.$SubscriptionPlansPayload<ExtArgs>
        fields: Prisma.SubscriptionPlansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlansFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlansFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlansPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlansFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlansFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlansPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlansFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlansPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlansCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlansPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlansCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionPlansDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlansPayload>
          }
          update: {
            args: Prisma.SubscriptionPlansUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlansPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlansDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlansUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionPlansUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlansPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlansAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubscriptionPlans>
          }
          groupBy: {
            args: Prisma.SubscriptionPlansGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionPlansGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlansCountArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionPlansCountAggregateOutputType> | number
          }
        }
      }
      Subscriptions: {
        payload: Prisma.$SubscriptionsPayload<ExtArgs>
        fields: Prisma.SubscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          findMany: {
            args: Prisma.SubscriptionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          create: {
            args: Prisma.SubscriptionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          createMany: {
            args: Prisma.SubscriptionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          update: {
            args: Prisma.SubscriptionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.SubscriptionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionsCountArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
      UserAnswers: {
        payload: Prisma.$UserAnswersPayload<ExtArgs>
        fields: Prisma.UserAnswersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAnswersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAnswersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAnswersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAnswersPayload>
          }
          findFirst: {
            args: Prisma.UserAnswersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAnswersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAnswersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAnswersPayload>
          }
          findMany: {
            args: Prisma.UserAnswersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAnswersPayload>[]
          }
          create: {
            args: Prisma.UserAnswersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAnswersPayload>
          }
          createMany: {
            args: Prisma.UserAnswersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserAnswersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAnswersPayload>
          }
          update: {
            args: Prisma.UserAnswersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAnswersPayload>
          }
          deleteMany: {
            args: Prisma.UserAnswersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserAnswersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserAnswersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserAnswersPayload>
          }
          aggregate: {
            args: Prisma.UserAnswersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserAnswers>
          }
          groupBy: {
            args: Prisma.UserAnswersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserAnswersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAnswersCountArgs<ExtArgs>,
            result: $Utils.Optional<UserAnswersCountAggregateOutputType> | number
          }
        }
      }
      UserSavedCourses: {
        payload: Prisma.$UserSavedCoursesPayload<ExtArgs>
        fields: Prisma.UserSavedCoursesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSavedCoursesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserSavedCoursesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSavedCoursesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserSavedCoursesPayload>
          }
          findFirst: {
            args: Prisma.UserSavedCoursesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserSavedCoursesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSavedCoursesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserSavedCoursesPayload>
          }
          findMany: {
            args: Prisma.UserSavedCoursesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserSavedCoursesPayload>[]
          }
          create: {
            args: Prisma.UserSavedCoursesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserSavedCoursesPayload>
          }
          createMany: {
            args: Prisma.UserSavedCoursesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserSavedCoursesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserSavedCoursesPayload>
          }
          update: {
            args: Prisma.UserSavedCoursesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserSavedCoursesPayload>
          }
          deleteMany: {
            args: Prisma.UserSavedCoursesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserSavedCoursesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserSavedCoursesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserSavedCoursesPayload>
          }
          aggregate: {
            args: Prisma.UserSavedCoursesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserSavedCourses>
          }
          groupBy: {
            args: Prisma.UserSavedCoursesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserSavedCoursesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSavedCoursesCountArgs<ExtArgs>,
            result: $Utils.Optional<UserSavedCoursesCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AssessmentOptionsCountOutputType
   */

  export type AssessmentOptionsCountOutputType = {
    UserAnswers: number
  }

  export type AssessmentOptionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserAnswers?: boolean | AssessmentOptionsCountOutputTypeCountUserAnswersArgs
  }

  // Custom InputTypes
  /**
   * AssessmentOptionsCountOutputType without action
   */
  export type AssessmentOptionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptionsCountOutputType
     */
    select?: AssessmentOptionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentOptionsCountOutputType without action
   */
  export type AssessmentOptionsCountOutputTypeCountUserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswersWhereInput
  }


  /**
   * Count Type AssessmentQuestionsCountOutputType
   */

  export type AssessmentQuestionsCountOutputType = {
    AssessmentOptions: number
    UserAnswers: number
  }

  export type AssessmentQuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssessmentOptions?: boolean | AssessmentQuestionsCountOutputTypeCountAssessmentOptionsArgs
    UserAnswers?: boolean | AssessmentQuestionsCountOutputTypeCountUserAnswersArgs
  }

  // Custom InputTypes
  /**
   * AssessmentQuestionsCountOutputType without action
   */
  export type AssessmentQuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestionsCountOutputType
     */
    select?: AssessmentQuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentQuestionsCountOutputType without action
   */
  export type AssessmentQuestionsCountOutputTypeCountAssessmentOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentOptionsWhereInput
  }

  /**
   * AssessmentQuestionsCountOutputType without action
   */
  export type AssessmentQuestionsCountOutputTypeCountUserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswersWhereInput
  }


  /**
   * Count Type AssessmentsCountOutputType
   */

  export type AssessmentsCountOutputType = {
    AssessmentQuestions: number
    QuizAttempts: number
  }

  export type AssessmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssessmentQuestions?: boolean | AssessmentsCountOutputTypeCountAssessmentQuestionsArgs
    QuizAttempts?: boolean | AssessmentsCountOutputTypeCountQuizAttemptsArgs
  }

  // Custom InputTypes
  /**
   * AssessmentsCountOutputType without action
   */
  export type AssessmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentsCountOutputType
     */
    select?: AssessmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentsCountOutputType without action
   */
  export type AssessmentsCountOutputTypeCountAssessmentQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentQuestionsWhereInput
  }

  /**
   * AssessmentsCountOutputType without action
   */
  export type AssessmentsCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptsWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    Courses: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | CategoriesCountOutputTypeCountCoursesArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursesWhereInput
  }


  /**
   * Count Type CourseContentCountOutputType
   */

  export type CourseContentCountOutputType = {
    Assessments: number
    other_CourseContent: number
    LessonProgress: number
  }

  export type CourseContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Assessments?: boolean | CourseContentCountOutputTypeCountAssessmentsArgs
    other_CourseContent?: boolean | CourseContentCountOutputTypeCountOther_CourseContentArgs
    LessonProgress?: boolean | CourseContentCountOutputTypeCountLessonProgressArgs
  }

  // Custom InputTypes
  /**
   * CourseContentCountOutputType without action
   */
  export type CourseContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContentCountOutputType
     */
    select?: CourseContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseContentCountOutputType without action
   */
  export type CourseContentCountOutputTypeCountAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentsWhereInput
  }

  /**
   * CourseContentCountOutputType without action
   */
  export type CourseContentCountOutputTypeCountOther_CourseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseContentWhereInput
  }

  /**
   * CourseContentCountOutputType without action
   */
  export type CourseContentCountOutputTypeCountLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
  }


  /**
   * Count Type CoursesCountOutputType
   */

  export type CoursesCountOutputType = {
    Certificates: number
    CourseContent: number
    CourseTags: number
    Enrollments: number
    Payments: number
    Reviews: number
    ShoppingCart: number
    UserSavedCourses: number
  }

  export type CoursesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Certificates?: boolean | CoursesCountOutputTypeCountCertificatesArgs
    CourseContent?: boolean | CoursesCountOutputTypeCountCourseContentArgs
    CourseTags?: boolean | CoursesCountOutputTypeCountCourseTagsArgs
    Enrollments?: boolean | CoursesCountOutputTypeCountEnrollmentsArgs
    Payments?: boolean | CoursesCountOutputTypeCountPaymentsArgs
    Reviews?: boolean | CoursesCountOutputTypeCountReviewsArgs
    ShoppingCart?: boolean | CoursesCountOutputTypeCountShoppingCartArgs
    UserSavedCourses?: boolean | CoursesCountOutputTypeCountUserSavedCoursesArgs
  }

  // Custom InputTypes
  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursesCountOutputType
     */
    select?: CoursesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificatesWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountCourseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseContentWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountCourseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagsWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentsWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewsWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountShoppingCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShoppingCartWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountUserSavedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSavedCoursesWhereInput
  }


  /**
   * Count Type QuizAttemptsCountOutputType
   */

  export type QuizAttemptsCountOutputType = {
    UserAnswers: number
  }

  export type QuizAttemptsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserAnswers?: boolean | QuizAttemptsCountOutputTypeCountUserAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuizAttemptsCountOutputType without action
   */
  export type QuizAttemptsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttemptsCountOutputType
     */
    select?: QuizAttemptsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizAttemptsCountOutputType without action
   */
  export type QuizAttemptsCountOutputTypeCountUserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswersWhereInput
  }


  /**
   * Count Type SubscriptionPlansCountOutputType
   */

  export type SubscriptionPlansCountOutputType = {
    Payments: number
    Subscriptions: number
  }

  export type SubscriptionPlansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Payments?: boolean | SubscriptionPlansCountOutputTypeCountPaymentsArgs
    Subscriptions?: boolean | SubscriptionPlansCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlansCountOutputType without action
   */
  export type SubscriptionPlansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlansCountOutputType
     */
    select?: SubscriptionPlansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlansCountOutputType without action
   */
  export type SubscriptionPlansCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }

  /**
   * SubscriptionPlansCountOutputType without action
   */
  export type SubscriptionPlansCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    Certificates: number
    Courses: number
    Enrollments: number
    LessonProgress: number
    Messages_Messages_receiver_idToUsers: number
    Messages_Messages_sender_idToUsers: number
    MultiFactorAuth: number
    Notifications: number
    Payments: number
    QuizAttempts: number
    Reviews_Reviews_instructor_idToUsers: number
    Reviews_Reviews_user_idToUsers: number
    ShoppingCart: number
    Subscriptions: number
    UserSavedCourses: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Certificates?: boolean | UsersCountOutputTypeCountCertificatesArgs
    Courses?: boolean | UsersCountOutputTypeCountCoursesArgs
    Enrollments?: boolean | UsersCountOutputTypeCountEnrollmentsArgs
    LessonProgress?: boolean | UsersCountOutputTypeCountLessonProgressArgs
    Messages_Messages_receiver_idToUsers?: boolean | UsersCountOutputTypeCountMessages_Messages_receiver_idToUsersArgs
    Messages_Messages_sender_idToUsers?: boolean | UsersCountOutputTypeCountMessages_Messages_sender_idToUsersArgs
    MultiFactorAuth?: boolean | UsersCountOutputTypeCountMultiFactorAuthArgs
    Notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    Payments?: boolean | UsersCountOutputTypeCountPaymentsArgs
    QuizAttempts?: boolean | UsersCountOutputTypeCountQuizAttemptsArgs
    Reviews_Reviews_instructor_idToUsers?: boolean | UsersCountOutputTypeCountReviews_Reviews_instructor_idToUsersArgs
    Reviews_Reviews_user_idToUsers?: boolean | UsersCountOutputTypeCountReviews_Reviews_user_idToUsersArgs
    ShoppingCart?: boolean | UsersCountOutputTypeCountShoppingCartArgs
    Subscriptions?: boolean | UsersCountOutputTypeCountSubscriptionsArgs
    UserSavedCourses?: boolean | UsersCountOutputTypeCountUserSavedCoursesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificatesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessages_Messages_receiver_idToUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessages_Messages_sender_idToUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMultiFactorAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiFactorAuthWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReviews_Reviews_instructor_idToUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReviews_Reviews_user_idToUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountShoppingCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShoppingCartWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserSavedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSavedCoursesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AssessmentOptions
   */

  export type AggregateAssessmentOptions = {
    _count: AssessmentOptionsCountAggregateOutputType | null
    _avg: AssessmentOptionsAvgAggregateOutputType | null
    _sum: AssessmentOptionsSumAggregateOutputType | null
    _min: AssessmentOptionsMinAggregateOutputType | null
    _max: AssessmentOptionsMaxAggregateOutputType | null
  }

  export type AssessmentOptionsAvgAggregateOutputType = {
    id: number | null
    question_id: number | null
  }

  export type AssessmentOptionsSumAggregateOutputType = {
    id: bigint | null
    question_id: bigint | null
  }

  export type AssessmentOptionsMinAggregateOutputType = {
    id: bigint | null
    question_id: bigint | null
    option_text: string | null
    is_correct: boolean | null
  }

  export type AssessmentOptionsMaxAggregateOutputType = {
    id: bigint | null
    question_id: bigint | null
    option_text: string | null
    is_correct: boolean | null
  }

  export type AssessmentOptionsCountAggregateOutputType = {
    id: number
    question_id: number
    option_text: number
    is_correct: number
    _all: number
  }


  export type AssessmentOptionsAvgAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type AssessmentOptionsSumAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type AssessmentOptionsMinAggregateInputType = {
    id?: true
    question_id?: true
    option_text?: true
    is_correct?: true
  }

  export type AssessmentOptionsMaxAggregateInputType = {
    id?: true
    question_id?: true
    option_text?: true
    is_correct?: true
  }

  export type AssessmentOptionsCountAggregateInputType = {
    id?: true
    question_id?: true
    option_text?: true
    is_correct?: true
    _all?: true
  }

  export type AssessmentOptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentOptions to aggregate.
     */
    where?: AssessmentOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentOptions to fetch.
     */
    orderBy?: AssessmentOptionsOrderByWithRelationInput | AssessmentOptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentOptions
    **/
    _count?: true | AssessmentOptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentOptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentOptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentOptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentOptionsMaxAggregateInputType
  }

  export type GetAssessmentOptionsAggregateType<T extends AssessmentOptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentOptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentOptions[P]>
      : GetScalarType<T[P], AggregateAssessmentOptions[P]>
  }




  export type AssessmentOptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentOptionsWhereInput
    orderBy?: AssessmentOptionsOrderByWithAggregationInput | AssessmentOptionsOrderByWithAggregationInput[]
    by: AssessmentOptionsScalarFieldEnum[] | AssessmentOptionsScalarFieldEnum
    having?: AssessmentOptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentOptionsCountAggregateInputType | true
    _avg?: AssessmentOptionsAvgAggregateInputType
    _sum?: AssessmentOptionsSumAggregateInputType
    _min?: AssessmentOptionsMinAggregateInputType
    _max?: AssessmentOptionsMaxAggregateInputType
  }

  export type AssessmentOptionsGroupByOutputType = {
    id: bigint
    question_id: bigint
    option_text: string | null
    is_correct: boolean | null
    _count: AssessmentOptionsCountAggregateOutputType | null
    _avg: AssessmentOptionsAvgAggregateOutputType | null
    _sum: AssessmentOptionsSumAggregateOutputType | null
    _min: AssessmentOptionsMinAggregateOutputType | null
    _max: AssessmentOptionsMaxAggregateOutputType | null
  }

  type GetAssessmentOptionsGroupByPayload<T extends AssessmentOptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentOptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentOptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentOptionsGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentOptionsGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentOptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question_id?: boolean
    option_text?: boolean
    is_correct?: boolean
    AssessmentQuestions?: boolean | AssessmentQuestionsDefaultArgs<ExtArgs>
    UserAnswers?: boolean | AssessmentOptions$UserAnswersArgs<ExtArgs>
    _count?: boolean | AssessmentOptionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentOptions"]>


  export type AssessmentOptionsSelectScalar = {
    id?: boolean
    question_id?: boolean
    option_text?: boolean
    is_correct?: boolean
  }

  export type AssessmentOptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssessmentQuestions?: boolean | AssessmentQuestionsDefaultArgs<ExtArgs>
    UserAnswers?: boolean | AssessmentOptions$UserAnswersArgs<ExtArgs>
    _count?: boolean | AssessmentOptionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AssessmentOptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentOptions"
    objects: {
      AssessmentQuestions: Prisma.$AssessmentQuestionsPayload<ExtArgs>
      UserAnswers: Prisma.$UserAnswersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      question_id: bigint
      option_text: string | null
      is_correct: boolean | null
    }, ExtArgs["result"]["assessmentOptions"]>
    composites: {}
  }

  type AssessmentOptionsGetPayload<S extends boolean | null | undefined | AssessmentOptionsDefaultArgs> = $Result.GetResult<Prisma.$AssessmentOptionsPayload, S>

  type AssessmentOptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssessmentOptionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssessmentOptionsCountAggregateInputType | true
    }

  export interface AssessmentOptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentOptions'], meta: { name: 'AssessmentOptions' } }
    /**
     * Find zero or one AssessmentOptions that matches the filter.
     * @param {AssessmentOptionsFindUniqueArgs} args - Arguments to find a AssessmentOptions
     * @example
     * // Get one AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssessmentOptionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentOptionsFindUniqueArgs<ExtArgs>>
    ): Prisma__AssessmentOptionsClient<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AssessmentOptions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssessmentOptionsFindUniqueOrThrowArgs} args - Arguments to find a AssessmentOptions
     * @example
     * // Get one AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssessmentOptionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentOptionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssessmentOptionsClient<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AssessmentOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentOptionsFindFirstArgs} args - Arguments to find a AssessmentOptions
     * @example
     * // Get one AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssessmentOptionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentOptionsFindFirstArgs<ExtArgs>>
    ): Prisma__AssessmentOptionsClient<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AssessmentOptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentOptionsFindFirstOrThrowArgs} args - Arguments to find a AssessmentOptions
     * @example
     * // Get one AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssessmentOptionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentOptionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssessmentOptionsClient<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AssessmentOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentOptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.findMany()
     * 
     * // Get first 10 AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentOptionsWithIdOnly = await prisma.assessmentOptions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssessmentOptionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentOptionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AssessmentOptions.
     * @param {AssessmentOptionsCreateArgs} args - Arguments to create a AssessmentOptions.
     * @example
     * // Create one AssessmentOptions
     * const AssessmentOptions = await prisma.assessmentOptions.create({
     *   data: {
     *     // ... data to create a AssessmentOptions
     *   }
     * })
     * 
    **/
    create<T extends AssessmentOptionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentOptionsCreateArgs<ExtArgs>>
    ): Prisma__AssessmentOptionsClient<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AssessmentOptions.
     * @param {AssessmentOptionsCreateManyArgs} args - Arguments to create many AssessmentOptions.
     * @example
     * // Create many AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AssessmentOptionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentOptionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AssessmentOptions.
     * @param {AssessmentOptionsDeleteArgs} args - Arguments to delete one AssessmentOptions.
     * @example
     * // Delete one AssessmentOptions
     * const AssessmentOptions = await prisma.assessmentOptions.delete({
     *   where: {
     *     // ... filter to delete one AssessmentOptions
     *   }
     * })
     * 
    **/
    delete<T extends AssessmentOptionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentOptionsDeleteArgs<ExtArgs>>
    ): Prisma__AssessmentOptionsClient<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AssessmentOptions.
     * @param {AssessmentOptionsUpdateArgs} args - Arguments to update one AssessmentOptions.
     * @example
     * // Update one AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssessmentOptionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentOptionsUpdateArgs<ExtArgs>>
    ): Prisma__AssessmentOptionsClient<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AssessmentOptions.
     * @param {AssessmentOptionsDeleteManyArgs} args - Arguments to filter AssessmentOptions to delete.
     * @example
     * // Delete a few AssessmentOptions
     * const { count } = await prisma.assessmentOptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssessmentOptionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentOptionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentOptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssessmentOptionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentOptionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssessmentOptions.
     * @param {AssessmentOptionsUpsertArgs} args - Arguments to update or create a AssessmentOptions.
     * @example
     * // Update or create a AssessmentOptions
     * const assessmentOptions = await prisma.assessmentOptions.upsert({
     *   create: {
     *     // ... data to create a AssessmentOptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentOptions we want to update
     *   }
     * })
    **/
    upsert<T extends AssessmentOptionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentOptionsUpsertArgs<ExtArgs>>
    ): Prisma__AssessmentOptionsClient<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AssessmentOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentOptionsCountArgs} args - Arguments to filter AssessmentOptions to count.
     * @example
     * // Count the number of AssessmentOptions
     * const count = await prisma.assessmentOptions.count({
     *   where: {
     *     // ... the filter for the AssessmentOptions we want to count
     *   }
     * })
    **/
    count<T extends AssessmentOptionsCountArgs>(
      args?: Subset<T, AssessmentOptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentOptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentOptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentOptionsAggregateArgs>(args: Subset<T, AssessmentOptionsAggregateArgs>): Prisma.PrismaPromise<GetAssessmentOptionsAggregateType<T>>

    /**
     * Group by AssessmentOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentOptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentOptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentOptionsGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentOptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentOptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentOptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentOptions model
   */
  readonly fields: AssessmentOptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentOptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentOptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    AssessmentQuestions<T extends AssessmentQuestionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentQuestionsDefaultArgs<ExtArgs>>): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    UserAnswers<T extends AssessmentOptions$UserAnswersArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentOptions$UserAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AssessmentOptions model
   */ 
  interface AssessmentOptionsFieldRefs {
    readonly id: FieldRef<"AssessmentOptions", 'BigInt'>
    readonly question_id: FieldRef<"AssessmentOptions", 'BigInt'>
    readonly option_text: FieldRef<"AssessmentOptions", 'String'>
    readonly is_correct: FieldRef<"AssessmentOptions", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentOptions findUnique
   */
  export type AssessmentOptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentOptions to fetch.
     */
    where: AssessmentOptionsWhereUniqueInput
  }

  /**
   * AssessmentOptions findUniqueOrThrow
   */
  export type AssessmentOptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentOptions to fetch.
     */
    where: AssessmentOptionsWhereUniqueInput
  }

  /**
   * AssessmentOptions findFirst
   */
  export type AssessmentOptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentOptions to fetch.
     */
    where?: AssessmentOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentOptions to fetch.
     */
    orderBy?: AssessmentOptionsOrderByWithRelationInput | AssessmentOptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentOptions.
     */
    cursor?: AssessmentOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentOptions.
     */
    distinct?: AssessmentOptionsScalarFieldEnum | AssessmentOptionsScalarFieldEnum[]
  }

  /**
   * AssessmentOptions findFirstOrThrow
   */
  export type AssessmentOptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentOptions to fetch.
     */
    where?: AssessmentOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentOptions to fetch.
     */
    orderBy?: AssessmentOptionsOrderByWithRelationInput | AssessmentOptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentOptions.
     */
    cursor?: AssessmentOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentOptions.
     */
    distinct?: AssessmentOptionsScalarFieldEnum | AssessmentOptionsScalarFieldEnum[]
  }

  /**
   * AssessmentOptions findMany
   */
  export type AssessmentOptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentOptions to fetch.
     */
    where?: AssessmentOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentOptions to fetch.
     */
    orderBy?: AssessmentOptionsOrderByWithRelationInput | AssessmentOptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentOptions.
     */
    cursor?: AssessmentOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentOptions.
     */
    skip?: number
    distinct?: AssessmentOptionsScalarFieldEnum | AssessmentOptionsScalarFieldEnum[]
  }

  /**
   * AssessmentOptions create
   */
  export type AssessmentOptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentOptions.
     */
    data: XOR<AssessmentOptionsCreateInput, AssessmentOptionsUncheckedCreateInput>
  }

  /**
   * AssessmentOptions createMany
   */
  export type AssessmentOptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentOptions.
     */
    data: AssessmentOptionsCreateManyInput | AssessmentOptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentOptions update
   */
  export type AssessmentOptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentOptions.
     */
    data: XOR<AssessmentOptionsUpdateInput, AssessmentOptionsUncheckedUpdateInput>
    /**
     * Choose, which AssessmentOptions to update.
     */
    where: AssessmentOptionsWhereUniqueInput
  }

  /**
   * AssessmentOptions updateMany
   */
  export type AssessmentOptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentOptions.
     */
    data: XOR<AssessmentOptionsUpdateManyMutationInput, AssessmentOptionsUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentOptions to update
     */
    where?: AssessmentOptionsWhereInput
  }

  /**
   * AssessmentOptions upsert
   */
  export type AssessmentOptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentOptions to update in case it exists.
     */
    where: AssessmentOptionsWhereUniqueInput
    /**
     * In case the AssessmentOptions found by the `where` argument doesn't exist, create a new AssessmentOptions with this data.
     */
    create: XOR<AssessmentOptionsCreateInput, AssessmentOptionsUncheckedCreateInput>
    /**
     * In case the AssessmentOptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentOptionsUpdateInput, AssessmentOptionsUncheckedUpdateInput>
  }

  /**
   * AssessmentOptions delete
   */
  export type AssessmentOptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    /**
     * Filter which AssessmentOptions to delete.
     */
    where: AssessmentOptionsWhereUniqueInput
  }

  /**
   * AssessmentOptions deleteMany
   */
  export type AssessmentOptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentOptions to delete
     */
    where?: AssessmentOptionsWhereInput
  }

  /**
   * AssessmentOptions.UserAnswers
   */
  export type AssessmentOptions$UserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    where?: UserAnswersWhereInput
    orderBy?: UserAnswersOrderByWithRelationInput | UserAnswersOrderByWithRelationInput[]
    cursor?: UserAnswersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAnswersScalarFieldEnum | UserAnswersScalarFieldEnum[]
  }

  /**
   * AssessmentOptions without action
   */
  export type AssessmentOptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
  }


  /**
   * Model AssessmentQuestions
   */

  export type AggregateAssessmentQuestions = {
    _count: AssessmentQuestionsCountAggregateOutputType | null
    _avg: AssessmentQuestionsAvgAggregateOutputType | null
    _sum: AssessmentQuestionsSumAggregateOutputType | null
    _min: AssessmentQuestionsMinAggregateOutputType | null
    _max: AssessmentQuestionsMaxAggregateOutputType | null
  }

  export type AssessmentQuestionsAvgAggregateOutputType = {
    id: number | null
    assessment_id: number | null
  }

  export type AssessmentQuestionsSumAggregateOutputType = {
    id: bigint | null
    assessment_id: bigint | null
  }

  export type AssessmentQuestionsMinAggregateOutputType = {
    id: bigint | null
    assessment_id: bigint | null
    question_text: string | null
    question_type: $Enums.AssessmentQuestions_question_type | null
  }

  export type AssessmentQuestionsMaxAggregateOutputType = {
    id: bigint | null
    assessment_id: bigint | null
    question_text: string | null
    question_type: $Enums.AssessmentQuestions_question_type | null
  }

  export type AssessmentQuestionsCountAggregateOutputType = {
    id: number
    assessment_id: number
    question_text: number
    question_type: number
    _all: number
  }


  export type AssessmentQuestionsAvgAggregateInputType = {
    id?: true
    assessment_id?: true
  }

  export type AssessmentQuestionsSumAggregateInputType = {
    id?: true
    assessment_id?: true
  }

  export type AssessmentQuestionsMinAggregateInputType = {
    id?: true
    assessment_id?: true
    question_text?: true
    question_type?: true
  }

  export type AssessmentQuestionsMaxAggregateInputType = {
    id?: true
    assessment_id?: true
    question_text?: true
    question_type?: true
  }

  export type AssessmentQuestionsCountAggregateInputType = {
    id?: true
    assessment_id?: true
    question_text?: true
    question_type?: true
    _all?: true
  }

  export type AssessmentQuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentQuestions to aggregate.
     */
    where?: AssessmentQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionsOrderByWithRelationInput | AssessmentQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentQuestions
    **/
    _count?: true | AssessmentQuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentQuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentQuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentQuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentQuestionsMaxAggregateInputType
  }

  export type GetAssessmentQuestionsAggregateType<T extends AssessmentQuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentQuestions[P]>
      : GetScalarType<T[P], AggregateAssessmentQuestions[P]>
  }




  export type AssessmentQuestionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentQuestionsWhereInput
    orderBy?: AssessmentQuestionsOrderByWithAggregationInput | AssessmentQuestionsOrderByWithAggregationInput[]
    by: AssessmentQuestionsScalarFieldEnum[] | AssessmentQuestionsScalarFieldEnum
    having?: AssessmentQuestionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentQuestionsCountAggregateInputType | true
    _avg?: AssessmentQuestionsAvgAggregateInputType
    _sum?: AssessmentQuestionsSumAggregateInputType
    _min?: AssessmentQuestionsMinAggregateInputType
    _max?: AssessmentQuestionsMaxAggregateInputType
  }

  export type AssessmentQuestionsGroupByOutputType = {
    id: bigint
    assessment_id: bigint
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
    _count: AssessmentQuestionsCountAggregateOutputType | null
    _avg: AssessmentQuestionsAvgAggregateOutputType | null
    _sum: AssessmentQuestionsSumAggregateOutputType | null
    _min: AssessmentQuestionsMinAggregateOutputType | null
    _max: AssessmentQuestionsMaxAggregateOutputType | null
  }

  type GetAssessmentQuestionsGroupByPayload<T extends AssessmentQuestionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentQuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentQuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentQuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentQuestionsGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentQuestionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessment_id?: boolean
    question_text?: boolean
    question_type?: boolean
    AssessmentOptions?: boolean | AssessmentQuestions$AssessmentOptionsArgs<ExtArgs>
    Assessments?: boolean | AssessmentsDefaultArgs<ExtArgs>
    UserAnswers?: boolean | AssessmentQuestions$UserAnswersArgs<ExtArgs>
    _count?: boolean | AssessmentQuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentQuestions"]>


  export type AssessmentQuestionsSelectScalar = {
    id?: boolean
    assessment_id?: boolean
    question_text?: boolean
    question_type?: boolean
  }

  export type AssessmentQuestionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssessmentOptions?: boolean | AssessmentQuestions$AssessmentOptionsArgs<ExtArgs>
    Assessments?: boolean | AssessmentsDefaultArgs<ExtArgs>
    UserAnswers?: boolean | AssessmentQuestions$UserAnswersArgs<ExtArgs>
    _count?: boolean | AssessmentQuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AssessmentQuestionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentQuestions"
    objects: {
      AssessmentOptions: Prisma.$AssessmentOptionsPayload<ExtArgs>[]
      Assessments: Prisma.$AssessmentsPayload<ExtArgs>
      UserAnswers: Prisma.$UserAnswersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      assessment_id: bigint
      question_text: string
      question_type: $Enums.AssessmentQuestions_question_type
    }, ExtArgs["result"]["assessmentQuestions"]>
    composites: {}
  }

  type AssessmentQuestionsGetPayload<S extends boolean | null | undefined | AssessmentQuestionsDefaultArgs> = $Result.GetResult<Prisma.$AssessmentQuestionsPayload, S>

  type AssessmentQuestionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssessmentQuestionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssessmentQuestionsCountAggregateInputType | true
    }

  export interface AssessmentQuestionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentQuestions'], meta: { name: 'AssessmentQuestions' } }
    /**
     * Find zero or one AssessmentQuestions that matches the filter.
     * @param {AssessmentQuestionsFindUniqueArgs} args - Arguments to find a AssessmentQuestions
     * @example
     * // Get one AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssessmentQuestionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentQuestionsFindUniqueArgs<ExtArgs>>
    ): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AssessmentQuestions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssessmentQuestionsFindUniqueOrThrowArgs} args - Arguments to find a AssessmentQuestions
     * @example
     * // Get one AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssessmentQuestionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentQuestionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AssessmentQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionsFindFirstArgs} args - Arguments to find a AssessmentQuestions
     * @example
     * // Get one AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssessmentQuestionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentQuestionsFindFirstArgs<ExtArgs>>
    ): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AssessmentQuestions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionsFindFirstOrThrowArgs} args - Arguments to find a AssessmentQuestions
     * @example
     * // Get one AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssessmentQuestionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentQuestionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AssessmentQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.findMany()
     * 
     * // Get first 10 AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentQuestionsWithIdOnly = await prisma.assessmentQuestions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssessmentQuestionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentQuestionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AssessmentQuestions.
     * @param {AssessmentQuestionsCreateArgs} args - Arguments to create a AssessmentQuestions.
     * @example
     * // Create one AssessmentQuestions
     * const AssessmentQuestions = await prisma.assessmentQuestions.create({
     *   data: {
     *     // ... data to create a AssessmentQuestions
     *   }
     * })
     * 
    **/
    create<T extends AssessmentQuestionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentQuestionsCreateArgs<ExtArgs>>
    ): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AssessmentQuestions.
     * @param {AssessmentQuestionsCreateManyArgs} args - Arguments to create many AssessmentQuestions.
     * @example
     * // Create many AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AssessmentQuestionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentQuestionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AssessmentQuestions.
     * @param {AssessmentQuestionsDeleteArgs} args - Arguments to delete one AssessmentQuestions.
     * @example
     * // Delete one AssessmentQuestions
     * const AssessmentQuestions = await prisma.assessmentQuestions.delete({
     *   where: {
     *     // ... filter to delete one AssessmentQuestions
     *   }
     * })
     * 
    **/
    delete<T extends AssessmentQuestionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentQuestionsDeleteArgs<ExtArgs>>
    ): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AssessmentQuestions.
     * @param {AssessmentQuestionsUpdateArgs} args - Arguments to update one AssessmentQuestions.
     * @example
     * // Update one AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssessmentQuestionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentQuestionsUpdateArgs<ExtArgs>>
    ): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AssessmentQuestions.
     * @param {AssessmentQuestionsDeleteManyArgs} args - Arguments to filter AssessmentQuestions to delete.
     * @example
     * // Delete a few AssessmentQuestions
     * const { count } = await prisma.assessmentQuestions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssessmentQuestionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentQuestionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssessmentQuestionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentQuestionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssessmentQuestions.
     * @param {AssessmentQuestionsUpsertArgs} args - Arguments to update or create a AssessmentQuestions.
     * @example
     * // Update or create a AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestions.upsert({
     *   create: {
     *     // ... data to create a AssessmentQuestions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentQuestions we want to update
     *   }
     * })
    **/
    upsert<T extends AssessmentQuestionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentQuestionsUpsertArgs<ExtArgs>>
    ): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionsCountArgs} args - Arguments to filter AssessmentQuestions to count.
     * @example
     * // Count the number of AssessmentQuestions
     * const count = await prisma.assessmentQuestions.count({
     *   where: {
     *     // ... the filter for the AssessmentQuestions we want to count
     *   }
     * })
    **/
    count<T extends AssessmentQuestionsCountArgs>(
      args?: Subset<T, AssessmentQuestionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentQuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentQuestionsAggregateArgs>(args: Subset<T, AssessmentQuestionsAggregateArgs>): Prisma.PrismaPromise<GetAssessmentQuestionsAggregateType<T>>

    /**
     * Group by AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentQuestionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentQuestionsGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentQuestionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentQuestionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentQuestions model
   */
  readonly fields: AssessmentQuestionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentQuestions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentQuestionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    AssessmentOptions<T extends AssessmentQuestions$AssessmentOptionsArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentQuestions$AssessmentOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Assessments<T extends AssessmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentsDefaultArgs<ExtArgs>>): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    UserAnswers<T extends AssessmentQuestions$UserAnswersArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentQuestions$UserAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AssessmentQuestions model
   */ 
  interface AssessmentQuestionsFieldRefs {
    readonly id: FieldRef<"AssessmentQuestions", 'BigInt'>
    readonly assessment_id: FieldRef<"AssessmentQuestions", 'BigInt'>
    readonly question_text: FieldRef<"AssessmentQuestions", 'String'>
    readonly question_type: FieldRef<"AssessmentQuestions", 'AssessmentQuestions_question_type'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentQuestions findUnique
   */
  export type AssessmentQuestionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestions to fetch.
     */
    where: AssessmentQuestionsWhereUniqueInput
  }

  /**
   * AssessmentQuestions findUniqueOrThrow
   */
  export type AssessmentQuestionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestions to fetch.
     */
    where: AssessmentQuestionsWhereUniqueInput
  }

  /**
   * AssessmentQuestions findFirst
   */
  export type AssessmentQuestionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestions to fetch.
     */
    where?: AssessmentQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionsOrderByWithRelationInput | AssessmentQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentQuestions.
     */
    cursor?: AssessmentQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentQuestions.
     */
    distinct?: AssessmentQuestionsScalarFieldEnum | AssessmentQuestionsScalarFieldEnum[]
  }

  /**
   * AssessmentQuestions findFirstOrThrow
   */
  export type AssessmentQuestionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestions to fetch.
     */
    where?: AssessmentQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionsOrderByWithRelationInput | AssessmentQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentQuestions.
     */
    cursor?: AssessmentQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentQuestions.
     */
    distinct?: AssessmentQuestionsScalarFieldEnum | AssessmentQuestionsScalarFieldEnum[]
  }

  /**
   * AssessmentQuestions findMany
   */
  export type AssessmentQuestionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestions to fetch.
     */
    where?: AssessmentQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionsOrderByWithRelationInput | AssessmentQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentQuestions.
     */
    cursor?: AssessmentQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    distinct?: AssessmentQuestionsScalarFieldEnum | AssessmentQuestionsScalarFieldEnum[]
  }

  /**
   * AssessmentQuestions create
   */
  export type AssessmentQuestionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentQuestions.
     */
    data: XOR<AssessmentQuestionsCreateInput, AssessmentQuestionsUncheckedCreateInput>
  }

  /**
   * AssessmentQuestions createMany
   */
  export type AssessmentQuestionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentQuestions.
     */
    data: AssessmentQuestionsCreateManyInput | AssessmentQuestionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentQuestions update
   */
  export type AssessmentQuestionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentQuestions.
     */
    data: XOR<AssessmentQuestionsUpdateInput, AssessmentQuestionsUncheckedUpdateInput>
    /**
     * Choose, which AssessmentQuestions to update.
     */
    where: AssessmentQuestionsWhereUniqueInput
  }

  /**
   * AssessmentQuestions updateMany
   */
  export type AssessmentQuestionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentQuestions.
     */
    data: XOR<AssessmentQuestionsUpdateManyMutationInput, AssessmentQuestionsUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentQuestions to update
     */
    where?: AssessmentQuestionsWhereInput
  }

  /**
   * AssessmentQuestions upsert
   */
  export type AssessmentQuestionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentQuestions to update in case it exists.
     */
    where: AssessmentQuestionsWhereUniqueInput
    /**
     * In case the AssessmentQuestions found by the `where` argument doesn't exist, create a new AssessmentQuestions with this data.
     */
    create: XOR<AssessmentQuestionsCreateInput, AssessmentQuestionsUncheckedCreateInput>
    /**
     * In case the AssessmentQuestions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentQuestionsUpdateInput, AssessmentQuestionsUncheckedUpdateInput>
  }

  /**
   * AssessmentQuestions delete
   */
  export type AssessmentQuestionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    /**
     * Filter which AssessmentQuestions to delete.
     */
    where: AssessmentQuestionsWhereUniqueInput
  }

  /**
   * AssessmentQuestions deleteMany
   */
  export type AssessmentQuestionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentQuestions to delete
     */
    where?: AssessmentQuestionsWhereInput
  }

  /**
   * AssessmentQuestions.AssessmentOptions
   */
  export type AssessmentQuestions$AssessmentOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    where?: AssessmentOptionsWhereInput
    orderBy?: AssessmentOptionsOrderByWithRelationInput | AssessmentOptionsOrderByWithRelationInput[]
    cursor?: AssessmentOptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentOptionsScalarFieldEnum | AssessmentOptionsScalarFieldEnum[]
  }

  /**
   * AssessmentQuestions.UserAnswers
   */
  export type AssessmentQuestions$UserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    where?: UserAnswersWhereInput
    orderBy?: UserAnswersOrderByWithRelationInput | UserAnswersOrderByWithRelationInput[]
    cursor?: UserAnswersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAnswersScalarFieldEnum | UserAnswersScalarFieldEnum[]
  }

  /**
   * AssessmentQuestions without action
   */
  export type AssessmentQuestionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
  }


  /**
   * Model Assessments
   */

  export type AggregateAssessments = {
    _count: AssessmentsCountAggregateOutputType | null
    _avg: AssessmentsAvgAggregateOutputType | null
    _sum: AssessmentsSumAggregateOutputType | null
    _min: AssessmentsMinAggregateOutputType | null
    _max: AssessmentsMaxAggregateOutputType | null
  }

  export type AssessmentsAvgAggregateOutputType = {
    id: number | null
    content_id: number | null
  }

  export type AssessmentsSumAggregateOutputType = {
    id: bigint | null
    content_id: bigint | null
  }

  export type AssessmentsMinAggregateOutputType = {
    id: bigint | null
    content_id: bigint | null
    title: string | null
    instructions: string | null
  }

  export type AssessmentsMaxAggregateOutputType = {
    id: bigint | null
    content_id: bigint | null
    title: string | null
    instructions: string | null
  }

  export type AssessmentsCountAggregateOutputType = {
    id: number
    content_id: number
    title: number
    instructions: number
    _all: number
  }


  export type AssessmentsAvgAggregateInputType = {
    id?: true
    content_id?: true
  }

  export type AssessmentsSumAggregateInputType = {
    id?: true
    content_id?: true
  }

  export type AssessmentsMinAggregateInputType = {
    id?: true
    content_id?: true
    title?: true
    instructions?: true
  }

  export type AssessmentsMaxAggregateInputType = {
    id?: true
    content_id?: true
    title?: true
    instructions?: true
  }

  export type AssessmentsCountAggregateInputType = {
    id?: true
    content_id?: true
    title?: true
    instructions?: true
    _all?: true
  }

  export type AssessmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessments to aggregate.
     */
    where?: AssessmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentsOrderByWithRelationInput | AssessmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assessments
    **/
    _count?: true | AssessmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentsMaxAggregateInputType
  }

  export type GetAssessmentsAggregateType<T extends AssessmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessments[P]>
      : GetScalarType<T[P], AggregateAssessments[P]>
  }




  export type AssessmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentsWhereInput
    orderBy?: AssessmentsOrderByWithAggregationInput | AssessmentsOrderByWithAggregationInput[]
    by: AssessmentsScalarFieldEnum[] | AssessmentsScalarFieldEnum
    having?: AssessmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentsCountAggregateInputType | true
    _avg?: AssessmentsAvgAggregateInputType
    _sum?: AssessmentsSumAggregateInputType
    _min?: AssessmentsMinAggregateInputType
    _max?: AssessmentsMaxAggregateInputType
  }

  export type AssessmentsGroupByOutputType = {
    id: bigint
    content_id: bigint
    title: string | null
    instructions: string | null
    _count: AssessmentsCountAggregateOutputType | null
    _avg: AssessmentsAvgAggregateOutputType | null
    _sum: AssessmentsSumAggregateOutputType | null
    _min: AssessmentsMinAggregateOutputType | null
    _max: AssessmentsMaxAggregateOutputType | null
  }

  type GetAssessmentsGroupByPayload<T extends AssessmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentsGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content_id?: boolean
    title?: boolean
    instructions?: boolean
    AssessmentQuestions?: boolean | Assessments$AssessmentQuestionsArgs<ExtArgs>
    CourseContent?: boolean | CourseContentDefaultArgs<ExtArgs>
    QuizAttempts?: boolean | Assessments$QuizAttemptsArgs<ExtArgs>
    _count?: boolean | AssessmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessments"]>


  export type AssessmentsSelectScalar = {
    id?: boolean
    content_id?: boolean
    title?: boolean
    instructions?: boolean
  }

  export type AssessmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssessmentQuestions?: boolean | Assessments$AssessmentQuestionsArgs<ExtArgs>
    CourseContent?: boolean | CourseContentDefaultArgs<ExtArgs>
    QuizAttempts?: boolean | Assessments$QuizAttemptsArgs<ExtArgs>
    _count?: boolean | AssessmentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AssessmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assessments"
    objects: {
      AssessmentQuestions: Prisma.$AssessmentQuestionsPayload<ExtArgs>[]
      CourseContent: Prisma.$CourseContentPayload<ExtArgs>
      QuizAttempts: Prisma.$QuizAttemptsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      content_id: bigint
      title: string | null
      instructions: string | null
    }, ExtArgs["result"]["assessments"]>
    composites: {}
  }

  type AssessmentsGetPayload<S extends boolean | null | undefined | AssessmentsDefaultArgs> = $Result.GetResult<Prisma.$AssessmentsPayload, S>

  type AssessmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssessmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssessmentsCountAggregateInputType | true
    }

  export interface AssessmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assessments'], meta: { name: 'Assessments' } }
    /**
     * Find zero or one Assessments that matches the filter.
     * @param {AssessmentsFindUniqueArgs} args - Arguments to find a Assessments
     * @example
     * // Get one Assessments
     * const assessments = await prisma.assessments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssessmentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsFindUniqueArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Assessments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssessmentsFindUniqueOrThrowArgs} args - Arguments to find a Assessments
     * @example
     * // Get one Assessments
     * const assessments = await prisma.assessments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssessmentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsFindFirstArgs} args - Arguments to find a Assessments
     * @example
     * // Get one Assessments
     * const assessments = await prisma.assessments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssessmentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsFindFirstArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Assessments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsFindFirstOrThrowArgs} args - Arguments to find a Assessments
     * @example
     * // Get one Assessments
     * const assessments = await prisma.assessments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssessmentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assessments
     * const assessments = await prisma.assessments.findMany()
     * 
     * // Get first 10 Assessments
     * const assessments = await prisma.assessments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentsWithIdOnly = await prisma.assessments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssessmentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Assessments.
     * @param {AssessmentsCreateArgs} args - Arguments to create a Assessments.
     * @example
     * // Create one Assessments
     * const Assessments = await prisma.assessments.create({
     *   data: {
     *     // ... data to create a Assessments
     *   }
     * })
     * 
    **/
    create<T extends AssessmentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsCreateArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Assessments.
     * @param {AssessmentsCreateManyArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessments = await prisma.assessments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AssessmentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assessments.
     * @param {AssessmentsDeleteArgs} args - Arguments to delete one Assessments.
     * @example
     * // Delete one Assessments
     * const Assessments = await prisma.assessments.delete({
     *   where: {
     *     // ... filter to delete one Assessments
     *   }
     * })
     * 
    **/
    delete<T extends AssessmentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsDeleteArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Assessments.
     * @param {AssessmentsUpdateArgs} args - Arguments to update one Assessments.
     * @example
     * // Update one Assessments
     * const assessments = await prisma.assessments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssessmentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsUpdateArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Assessments.
     * @param {AssessmentsDeleteManyArgs} args - Arguments to filter Assessments to delete.
     * @example
     * // Delete a few Assessments
     * const { count } = await prisma.assessments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssessmentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssessmentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assessments
     * const assessments = await prisma.assessments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssessmentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assessments.
     * @param {AssessmentsUpsertArgs} args - Arguments to update or create a Assessments.
     * @example
     * // Update or create a Assessments
     * const assessments = await prisma.assessments.upsert({
     *   create: {
     *     // ... data to create a Assessments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assessments we want to update
     *   }
     * })
    **/
    upsert<T extends AssessmentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssessmentsUpsertArgs<ExtArgs>>
    ): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsCountArgs} args - Arguments to filter Assessments to count.
     * @example
     * // Count the number of Assessments
     * const count = await prisma.assessments.count({
     *   where: {
     *     // ... the filter for the Assessments we want to count
     *   }
     * })
    **/
    count<T extends AssessmentsCountArgs>(
      args?: Subset<T, AssessmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentsAggregateArgs>(args: Subset<T, AssessmentsAggregateArgs>): Prisma.PrismaPromise<GetAssessmentsAggregateType<T>>

    /**
     * Group by Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentsGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assessments model
   */
  readonly fields: AssessmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assessments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    AssessmentQuestions<T extends Assessments$AssessmentQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Assessments$AssessmentQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    CourseContent<T extends CourseContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseContentDefaultArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    QuizAttempts<T extends Assessments$QuizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Assessments$QuizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Assessments model
   */ 
  interface AssessmentsFieldRefs {
    readonly id: FieldRef<"Assessments", 'BigInt'>
    readonly content_id: FieldRef<"Assessments", 'BigInt'>
    readonly title: FieldRef<"Assessments", 'String'>
    readonly instructions: FieldRef<"Assessments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Assessments findUnique
   */
  export type AssessmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where: AssessmentsWhereUniqueInput
  }

  /**
   * Assessments findUniqueOrThrow
   */
  export type AssessmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where: AssessmentsWhereUniqueInput
  }

  /**
   * Assessments findFirst
   */
  export type AssessmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentsOrderByWithRelationInput | AssessmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentsScalarFieldEnum | AssessmentsScalarFieldEnum[]
  }

  /**
   * Assessments findFirstOrThrow
   */
  export type AssessmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentsOrderByWithRelationInput | AssessmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentsScalarFieldEnum | AssessmentsScalarFieldEnum[]
  }

  /**
   * Assessments findMany
   */
  export type AssessmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentsOrderByWithRelationInput | AssessmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assessments.
     */
    cursor?: AssessmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    distinct?: AssessmentsScalarFieldEnum | AssessmentsScalarFieldEnum[]
  }

  /**
   * Assessments create
   */
  export type AssessmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Assessments.
     */
    data: XOR<AssessmentsCreateInput, AssessmentsUncheckedCreateInput>
  }

  /**
   * Assessments createMany
   */
  export type AssessmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentsCreateManyInput | AssessmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assessments update
   */
  export type AssessmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Assessments.
     */
    data: XOR<AssessmentsUpdateInput, AssessmentsUncheckedUpdateInput>
    /**
     * Choose, which Assessments to update.
     */
    where: AssessmentsWhereUniqueInput
  }

  /**
   * Assessments updateMany
   */
  export type AssessmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assessments.
     */
    data: XOR<AssessmentsUpdateManyMutationInput, AssessmentsUncheckedUpdateManyInput>
    /**
     * Filter which Assessments to update
     */
    where?: AssessmentsWhereInput
  }

  /**
   * Assessments upsert
   */
  export type AssessmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Assessments to update in case it exists.
     */
    where: AssessmentsWhereUniqueInput
    /**
     * In case the Assessments found by the `where` argument doesn't exist, create a new Assessments with this data.
     */
    create: XOR<AssessmentsCreateInput, AssessmentsUncheckedCreateInput>
    /**
     * In case the Assessments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentsUpdateInput, AssessmentsUncheckedUpdateInput>
  }

  /**
   * Assessments delete
   */
  export type AssessmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    /**
     * Filter which Assessments to delete.
     */
    where: AssessmentsWhereUniqueInput
  }

  /**
   * Assessments deleteMany
   */
  export type AssessmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessments to delete
     */
    where?: AssessmentsWhereInput
  }

  /**
   * Assessments.AssessmentQuestions
   */
  export type Assessments$AssessmentQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestions
     */
    select?: AssessmentQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionsInclude<ExtArgs> | null
    where?: AssessmentQuestionsWhereInput
    orderBy?: AssessmentQuestionsOrderByWithRelationInput | AssessmentQuestionsOrderByWithRelationInput[]
    cursor?: AssessmentQuestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentQuestionsScalarFieldEnum | AssessmentQuestionsScalarFieldEnum[]
  }

  /**
   * Assessments.QuizAttempts
   */
  export type Assessments$QuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    where?: QuizAttemptsWhereInput
    orderBy?: QuizAttemptsOrderByWithRelationInput | QuizAttemptsOrderByWithRelationInput[]
    cursor?: QuizAttemptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptsScalarFieldEnum | QuizAttemptsScalarFieldEnum[]
  }

  /**
   * Assessments without action
   */
  export type AssessmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
  }


  /**
   * Model Categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: bigint | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to aggregate.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type CategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesWhereInput
    orderBy?: CategoriesOrderByWithAggregationInput | CategoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: CategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: bigint
    name: string
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends CategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type CategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    Courses?: boolean | Categories$CoursesArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>


  export type CategoriesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | Categories$CoursesArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categories"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type CategoriesGetPayload<S extends boolean | null | undefined | CategoriesDefaultArgs> = $Result.GetResult<Prisma.$CategoriesPayload, S>

  type CategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface CategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categories'], meta: { name: 'Categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {CategoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesFindFirstArgs<ExtArgs>>
    ): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Categories.
     * @param {CategoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
    **/
    create<T extends CategoriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesCreateArgs<ExtArgs>>
    ): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CategoriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categories.
     * @param {CategoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
    **/
    delete<T extends CategoriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesDeleteArgs<ExtArgs>>
    ): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Categories.
     * @param {CategoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesUpdateArgs<ExtArgs>>
    ): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categories.
     * @param {CategoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoriesUpsertArgs<ExtArgs>>
    ): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoriesCountArgs>(
      args?: Subset<T, CategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categories model
   */
  readonly fields: CategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends Categories$CoursesArgs<ExtArgs> = {}>(args?: Subset<T, Categories$CoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Categories model
   */ 
  interface CategoriesFieldRefs {
    readonly id: FieldRef<"Categories", 'BigInt'>
    readonly name: FieldRef<"Categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Categories findUnique
   */
  export type CategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findUniqueOrThrow
   */
  export type CategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findFirst
   */
  export type CategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findFirstOrThrow
   */
  export type CategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findMany
   */
  export type CategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories create
   */
  export type CategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Categories.
     */
    data: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
  }

  /**
   * Categories createMany
   */
  export type CategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categories update
   */
  export type CategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Categories.
     */
    data: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
    /**
     * Choose, which Categories to update.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories updateMany
   */
  export type CategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoriesWhereInput
  }

  /**
   * Categories upsert
   */
  export type CategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Categories to update in case it exists.
     */
    where: CategoriesWhereUniqueInput
    /**
     * In case the Categories found by the `where` argument doesn't exist, create a new Categories with this data.
     */
    create: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
    /**
     * In case the Categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
  }

  /**
   * Categories delete
   */
  export type CategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter which Categories to delete.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories deleteMany
   */
  export type CategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoriesWhereInput
  }

  /**
   * Categories.Courses
   */
  export type Categories$CoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    where?: CoursesWhereInput
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    cursor?: CoursesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * Categories without action
   */
  export type CategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
  }


  /**
   * Model Certificates
   */

  export type AggregateCertificates = {
    _count: CertificatesCountAggregateOutputType | null
    _avg: CertificatesAvgAggregateOutputType | null
    _sum: CertificatesSumAggregateOutputType | null
    _min: CertificatesMinAggregateOutputType | null
    _max: CertificatesMaxAggregateOutputType | null
  }

  export type CertificatesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    course_id: number | null
  }

  export type CertificatesSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
  }

  export type CertificatesMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    certificate_url: string | null
    issued_at: Date | null
  }

  export type CertificatesMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    certificate_url: string | null
    issued_at: Date | null
  }

  export type CertificatesCountAggregateOutputType = {
    id: number
    user_id: number
    course_id: number
    certificate_url: number
    issued_at: number
    _all: number
  }


  export type CertificatesAvgAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type CertificatesSumAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type CertificatesMinAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    certificate_url?: true
    issued_at?: true
  }

  export type CertificatesMaxAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    certificate_url?: true
    issued_at?: true
  }

  export type CertificatesCountAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    certificate_url?: true
    issued_at?: true
    _all?: true
  }

  export type CertificatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to aggregate.
     */
    where?: CertificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificatesOrderByWithRelationInput | CertificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificatesMaxAggregateInputType
  }

  export type GetCertificatesAggregateType<T extends CertificatesAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificates[P]>
      : GetScalarType<T[P], AggregateCertificates[P]>
  }




  export type CertificatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificatesWhereInput
    orderBy?: CertificatesOrderByWithAggregationInput | CertificatesOrderByWithAggregationInput[]
    by: CertificatesScalarFieldEnum[] | CertificatesScalarFieldEnum
    having?: CertificatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificatesCountAggregateInputType | true
    _avg?: CertificatesAvgAggregateInputType
    _sum?: CertificatesSumAggregateInputType
    _min?: CertificatesMinAggregateInputType
    _max?: CertificatesMaxAggregateInputType
  }

  export type CertificatesGroupByOutputType = {
    id: bigint
    user_id: bigint
    course_id: bigint
    certificate_url: string | null
    issued_at: Date | null
    _count: CertificatesCountAggregateOutputType | null
    _avg: CertificatesAvgAggregateOutputType | null
    _sum: CertificatesSumAggregateOutputType | null
    _min: CertificatesMinAggregateOutputType | null
    _max: CertificatesMaxAggregateOutputType | null
  }

  type GetCertificatesGroupByPayload<T extends CertificatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificatesGroupByOutputType[P]>
            : GetScalarType<T[P], CertificatesGroupByOutputType[P]>
        }
      >
    >


  export type CertificatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    certificate_url?: boolean
    issued_at?: boolean
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificates"]>


  export type CertificatesSelectScalar = {
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    certificate_url?: boolean
    issued_at?: boolean
  }

  export type CertificatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $CertificatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificates"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      course_id: bigint
      certificate_url: string | null
      issued_at: Date | null
    }, ExtArgs["result"]["certificates"]>
    composites: {}
  }

  type CertificatesGetPayload<S extends boolean | null | undefined | CertificatesDefaultArgs> = $Result.GetResult<Prisma.$CertificatesPayload, S>

  type CertificatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificatesCountAggregateInputType | true
    }

  export interface CertificatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificates'], meta: { name: 'Certificates' } }
    /**
     * Find zero or one Certificates that matches the filter.
     * @param {CertificatesFindUniqueArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CertificatesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CertificatesFindUniqueArgs<ExtArgs>>
    ): Prisma__CertificatesClient<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Certificates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificatesFindUniqueOrThrowArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CertificatesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificatesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CertificatesClient<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificatesFindFirstArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CertificatesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificatesFindFirstArgs<ExtArgs>>
    ): Prisma__CertificatesClient<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Certificates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificatesFindFirstOrThrowArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CertificatesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificatesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CertificatesClient<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificates.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificatesWithIdOnly = await prisma.certificates.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CertificatesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificatesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Certificates.
     * @param {CertificatesCreateArgs} args - Arguments to create a Certificates.
     * @example
     * // Create one Certificates
     * const Certificates = await prisma.certificates.create({
     *   data: {
     *     // ... data to create a Certificates
     *   }
     * })
     * 
    **/
    create<T extends CertificatesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CertificatesCreateArgs<ExtArgs>>
    ): Prisma__CertificatesClient<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {CertificatesCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificates = await prisma.certificates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CertificatesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificatesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Certificates.
     * @param {CertificatesDeleteArgs} args - Arguments to delete one Certificates.
     * @example
     * // Delete one Certificates
     * const Certificates = await prisma.certificates.delete({
     *   where: {
     *     // ... filter to delete one Certificates
     *   }
     * })
     * 
    **/
    delete<T extends CertificatesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CertificatesDeleteArgs<ExtArgs>>
    ): Prisma__CertificatesClient<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Certificates.
     * @param {CertificatesUpdateArgs} args - Arguments to update one Certificates.
     * @example
     * // Update one Certificates
     * const certificates = await prisma.certificates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CertificatesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CertificatesUpdateArgs<ExtArgs>>
    ): Prisma__CertificatesClient<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {CertificatesDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CertificatesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CertificatesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificates = await prisma.certificates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CertificatesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CertificatesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificates.
     * @param {CertificatesUpsertArgs} args - Arguments to update or create a Certificates.
     * @example
     * // Update or create a Certificates
     * const certificates = await prisma.certificates.upsert({
     *   create: {
     *     // ... data to create a Certificates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificates we want to update
     *   }
     * })
    **/
    upsert<T extends CertificatesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CertificatesUpsertArgs<ExtArgs>>
    ): Prisma__CertificatesClient<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificatesCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificates.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificatesCountArgs>(
      args?: Subset<T, CertificatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificatesAggregateArgs>(args: Subset<T, CertificatesAggregateArgs>): Prisma.PrismaPromise<GetCertificatesAggregateType<T>>

    /**
     * Group by Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificatesGroupByArgs['orderBy'] }
        : { orderBy?: CertificatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificates model
   */
  readonly fields: CertificatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Certificates model
   */ 
  interface CertificatesFieldRefs {
    readonly id: FieldRef<"Certificates", 'BigInt'>
    readonly user_id: FieldRef<"Certificates", 'BigInt'>
    readonly course_id: FieldRef<"Certificates", 'BigInt'>
    readonly certificate_url: FieldRef<"Certificates", 'String'>
    readonly issued_at: FieldRef<"Certificates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificates findUnique
   */
  export type CertificatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where: CertificatesWhereUniqueInput
  }

  /**
   * Certificates findUniqueOrThrow
   */
  export type CertificatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where: CertificatesWhereUniqueInput
  }

  /**
   * Certificates findFirst
   */
  export type CertificatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificatesOrderByWithRelationInput | CertificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * Certificates findFirstOrThrow
   */
  export type CertificatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificatesOrderByWithRelationInput | CertificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * Certificates findMany
   */
  export type CertificatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificatesOrderByWithRelationInput | CertificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * Certificates create
   */
  export type CertificatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificates.
     */
    data: XOR<CertificatesCreateInput, CertificatesUncheckedCreateInput>
  }

  /**
   * Certificates createMany
   */
  export type CertificatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificatesCreateManyInput | CertificatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificates update
   */
  export type CertificatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificates.
     */
    data: XOR<CertificatesUpdateInput, CertificatesUncheckedUpdateInput>
    /**
     * Choose, which Certificates to update.
     */
    where: CertificatesWhereUniqueInput
  }

  /**
   * Certificates updateMany
   */
  export type CertificatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificatesUpdateManyMutationInput, CertificatesUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificatesWhereInput
  }

  /**
   * Certificates upsert
   */
  export type CertificatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificates to update in case it exists.
     */
    where: CertificatesWhereUniqueInput
    /**
     * In case the Certificates found by the `where` argument doesn't exist, create a new Certificates with this data.
     */
    create: XOR<CertificatesCreateInput, CertificatesUncheckedCreateInput>
    /**
     * In case the Certificates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificatesUpdateInput, CertificatesUncheckedUpdateInput>
  }

  /**
   * Certificates delete
   */
  export type CertificatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    /**
     * Filter which Certificates to delete.
     */
    where: CertificatesWhereUniqueInput
  }

  /**
   * Certificates deleteMany
   */
  export type CertificatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificatesWhereInput
  }

  /**
   * Certificates without action
   */
  export type CertificatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
  }


  /**
   * Model CourseContent
   */

  export type AggregateCourseContent = {
    _count: CourseContentCountAggregateOutputType | null
    _avg: CourseContentAvgAggregateOutputType | null
    _sum: CourseContentSumAggregateOutputType | null
    _min: CourseContentMinAggregateOutputType | null
    _max: CourseContentMaxAggregateOutputType | null
  }

  export type CourseContentAvgAggregateOutputType = {
    id: number | null
    course_id: number | null
    parent_id: number | null
    duration_seconds: number | null
    order_index: number | null
  }

  export type CourseContentSumAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    parent_id: bigint | null
    duration_seconds: number | null
    order_index: number | null
  }

  export type CourseContentMinAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    parent_id: bigint | null
    title: string | null
    type: $Enums.CourseContent_type | null
    video_url: string | null
    note_content: string | null
    duration_seconds: number | null
    order_index: number | null
  }

  export type CourseContentMaxAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    parent_id: bigint | null
    title: string | null
    type: $Enums.CourseContent_type | null
    video_url: string | null
    note_content: string | null
    duration_seconds: number | null
    order_index: number | null
  }

  export type CourseContentCountAggregateOutputType = {
    id: number
    course_id: number
    parent_id: number
    title: number
    type: number
    video_url: number
    note_content: number
    duration_seconds: number
    order_index: number
    _all: number
  }


  export type CourseContentAvgAggregateInputType = {
    id?: true
    course_id?: true
    parent_id?: true
    duration_seconds?: true
    order_index?: true
  }

  export type CourseContentSumAggregateInputType = {
    id?: true
    course_id?: true
    parent_id?: true
    duration_seconds?: true
    order_index?: true
  }

  export type CourseContentMinAggregateInputType = {
    id?: true
    course_id?: true
    parent_id?: true
    title?: true
    type?: true
    video_url?: true
    note_content?: true
    duration_seconds?: true
    order_index?: true
  }

  export type CourseContentMaxAggregateInputType = {
    id?: true
    course_id?: true
    parent_id?: true
    title?: true
    type?: true
    video_url?: true
    note_content?: true
    duration_seconds?: true
    order_index?: true
  }

  export type CourseContentCountAggregateInputType = {
    id?: true
    course_id?: true
    parent_id?: true
    title?: true
    type?: true
    video_url?: true
    note_content?: true
    duration_seconds?: true
    order_index?: true
    _all?: true
  }

  export type CourseContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseContent to aggregate.
     */
    where?: CourseContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseContents to fetch.
     */
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseContents
    **/
    _count?: true | CourseContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseContentMaxAggregateInputType
  }

  export type GetCourseContentAggregateType<T extends CourseContentAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseContent[P]>
      : GetScalarType<T[P], AggregateCourseContent[P]>
  }




  export type CourseContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseContentWhereInput
    orderBy?: CourseContentOrderByWithAggregationInput | CourseContentOrderByWithAggregationInput[]
    by: CourseContentScalarFieldEnum[] | CourseContentScalarFieldEnum
    having?: CourseContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseContentCountAggregateInputType | true
    _avg?: CourseContentAvgAggregateInputType
    _sum?: CourseContentSumAggregateInputType
    _min?: CourseContentMinAggregateInputType
    _max?: CourseContentMaxAggregateInputType
  }

  export type CourseContentGroupByOutputType = {
    id: bigint
    course_id: bigint
    parent_id: bigint | null
    title: string
    type: $Enums.CourseContent_type
    video_url: string | null
    note_content: string | null
    duration_seconds: number | null
    order_index: number
    _count: CourseContentCountAggregateOutputType | null
    _avg: CourseContentAvgAggregateOutputType | null
    _sum: CourseContentSumAggregateOutputType | null
    _min: CourseContentMinAggregateOutputType | null
    _max: CourseContentMaxAggregateOutputType | null
  }

  type GetCourseContentGroupByPayload<T extends CourseContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseContentGroupByOutputType[P]>
            : GetScalarType<T[P], CourseContentGroupByOutputType[P]>
        }
      >
    >


  export type CourseContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    parent_id?: boolean
    title?: boolean
    type?: boolean
    video_url?: boolean
    note_content?: boolean
    duration_seconds?: boolean
    order_index?: boolean
    Assessments?: boolean | CourseContent$AssessmentsArgs<ExtArgs>
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    CourseContent?: boolean | CourseContent$CourseContentArgs<ExtArgs>
    other_CourseContent?: boolean | CourseContent$other_CourseContentArgs<ExtArgs>
    LessonProgress?: boolean | CourseContent$LessonProgressArgs<ExtArgs>
    _count?: boolean | CourseContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseContent"]>


  export type CourseContentSelectScalar = {
    id?: boolean
    course_id?: boolean
    parent_id?: boolean
    title?: boolean
    type?: boolean
    video_url?: boolean
    note_content?: boolean
    duration_seconds?: boolean
    order_index?: boolean
  }

  export type CourseContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Assessments?: boolean | CourseContent$AssessmentsArgs<ExtArgs>
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    CourseContent?: boolean | CourseContent$CourseContentArgs<ExtArgs>
    other_CourseContent?: boolean | CourseContent$other_CourseContentArgs<ExtArgs>
    LessonProgress?: boolean | CourseContent$LessonProgressArgs<ExtArgs>
    _count?: boolean | CourseContentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CourseContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseContent"
    objects: {
      Assessments: Prisma.$AssessmentsPayload<ExtArgs>[]
      Courses: Prisma.$CoursesPayload<ExtArgs>
      CourseContent: Prisma.$CourseContentPayload<ExtArgs> | null
      other_CourseContent: Prisma.$CourseContentPayload<ExtArgs>[]
      LessonProgress: Prisma.$LessonProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      course_id: bigint
      parent_id: bigint | null
      title: string
      type: $Enums.CourseContent_type
      video_url: string | null
      note_content: string | null
      duration_seconds: number | null
      order_index: number
    }, ExtArgs["result"]["courseContent"]>
    composites: {}
  }

  type CourseContentGetPayload<S extends boolean | null | undefined | CourseContentDefaultArgs> = $Result.GetResult<Prisma.$CourseContentPayload, S>

  type CourseContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseContentCountAggregateInputType | true
    }

  export interface CourseContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseContent'], meta: { name: 'CourseContent' } }
    /**
     * Find zero or one CourseContent that matches the filter.
     * @param {CourseContentFindUniqueArgs} args - Arguments to find a CourseContent
     * @example
     * // Get one CourseContent
     * const courseContent = await prisma.courseContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseContentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CourseContentFindUniqueArgs<ExtArgs>>
    ): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CourseContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseContentFindUniqueOrThrowArgs} args - Arguments to find a CourseContent
     * @example
     * // Get one CourseContent
     * const courseContent = await prisma.courseContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CourseContentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseContentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CourseContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentFindFirstArgs} args - Arguments to find a CourseContent
     * @example
     * // Get one CourseContent
     * const courseContent = await prisma.courseContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseContentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseContentFindFirstArgs<ExtArgs>>
    ): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CourseContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentFindFirstOrThrowArgs} args - Arguments to find a CourseContent
     * @example
     * // Get one CourseContent
     * const courseContent = await prisma.courseContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CourseContentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseContentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CourseContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseContents
     * const courseContents = await prisma.courseContent.findMany()
     * 
     * // Get first 10 CourseContents
     * const courseContents = await prisma.courseContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseContentWithIdOnly = await prisma.courseContent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CourseContentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseContentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CourseContent.
     * @param {CourseContentCreateArgs} args - Arguments to create a CourseContent.
     * @example
     * // Create one CourseContent
     * const CourseContent = await prisma.courseContent.create({
     *   data: {
     *     // ... data to create a CourseContent
     *   }
     * })
     * 
    **/
    create<T extends CourseContentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseContentCreateArgs<ExtArgs>>
    ): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CourseContents.
     * @param {CourseContentCreateManyArgs} args - Arguments to create many CourseContents.
     * @example
     * // Create many CourseContents
     * const courseContent = await prisma.courseContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CourseContentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseContentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseContent.
     * @param {CourseContentDeleteArgs} args - Arguments to delete one CourseContent.
     * @example
     * // Delete one CourseContent
     * const CourseContent = await prisma.courseContent.delete({
     *   where: {
     *     // ... filter to delete one CourseContent
     *   }
     * })
     * 
    **/
    delete<T extends CourseContentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CourseContentDeleteArgs<ExtArgs>>
    ): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CourseContent.
     * @param {CourseContentUpdateArgs} args - Arguments to update one CourseContent.
     * @example
     * // Update one CourseContent
     * const courseContent = await prisma.courseContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseContentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseContentUpdateArgs<ExtArgs>>
    ): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CourseContents.
     * @param {CourseContentDeleteManyArgs} args - Arguments to filter CourseContents to delete.
     * @example
     * // Delete a few CourseContents
     * const { count } = await prisma.courseContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseContentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseContentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseContents
     * const courseContent = await prisma.courseContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseContentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CourseContentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseContent.
     * @param {CourseContentUpsertArgs} args - Arguments to update or create a CourseContent.
     * @example
     * // Update or create a CourseContent
     * const courseContent = await prisma.courseContent.upsert({
     *   create: {
     *     // ... data to create a CourseContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseContent we want to update
     *   }
     * })
    **/
    upsert<T extends CourseContentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CourseContentUpsertArgs<ExtArgs>>
    ): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CourseContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentCountArgs} args - Arguments to filter CourseContents to count.
     * @example
     * // Count the number of CourseContents
     * const count = await prisma.courseContent.count({
     *   where: {
     *     // ... the filter for the CourseContents we want to count
     *   }
     * })
    **/
    count<T extends CourseContentCountArgs>(
      args?: Subset<T, CourseContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseContentAggregateArgs>(args: Subset<T, CourseContentAggregateArgs>): Prisma.PrismaPromise<GetCourseContentAggregateType<T>>

    /**
     * Group by CourseContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseContentGroupByArgs['orderBy'] }
        : { orderBy?: CourseContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseContent model
   */
  readonly fields: CourseContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Assessments<T extends CourseContent$AssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, CourseContent$AssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    CourseContent<T extends CourseContent$CourseContentArgs<ExtArgs> = {}>(args?: Subset<T, CourseContent$CourseContentArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    other_CourseContent<T extends CourseContent$other_CourseContentArgs<ExtArgs> = {}>(args?: Subset<T, CourseContent$other_CourseContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findMany'> | Null>;

    LessonProgress<T extends CourseContent$LessonProgressArgs<ExtArgs> = {}>(args?: Subset<T, CourseContent$LessonProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CourseContent model
   */ 
  interface CourseContentFieldRefs {
    readonly id: FieldRef<"CourseContent", 'BigInt'>
    readonly course_id: FieldRef<"CourseContent", 'BigInt'>
    readonly parent_id: FieldRef<"CourseContent", 'BigInt'>
    readonly title: FieldRef<"CourseContent", 'String'>
    readonly type: FieldRef<"CourseContent", 'CourseContent_type'>
    readonly video_url: FieldRef<"CourseContent", 'String'>
    readonly note_content: FieldRef<"CourseContent", 'String'>
    readonly duration_seconds: FieldRef<"CourseContent", 'Int'>
    readonly order_index: FieldRef<"CourseContent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseContent findUnique
   */
  export type CourseContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContent to fetch.
     */
    where: CourseContentWhereUniqueInput
  }

  /**
   * CourseContent findUniqueOrThrow
   */
  export type CourseContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContent to fetch.
     */
    where: CourseContentWhereUniqueInput
  }

  /**
   * CourseContent findFirst
   */
  export type CourseContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContent to fetch.
     */
    where?: CourseContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseContents to fetch.
     */
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseContents.
     */
    cursor?: CourseContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseContents.
     */
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * CourseContent findFirstOrThrow
   */
  export type CourseContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContent to fetch.
     */
    where?: CourseContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseContents to fetch.
     */
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseContents.
     */
    cursor?: CourseContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseContents.
     */
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * CourseContent findMany
   */
  export type CourseContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContents to fetch.
     */
    where?: CourseContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseContents to fetch.
     */
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseContents.
     */
    cursor?: CourseContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseContents.
     */
    skip?: number
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * CourseContent create
   */
  export type CourseContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseContent.
     */
    data: XOR<CourseContentCreateInput, CourseContentUncheckedCreateInput>
  }

  /**
   * CourseContent createMany
   */
  export type CourseContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseContents.
     */
    data: CourseContentCreateManyInput | CourseContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseContent update
   */
  export type CourseContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseContent.
     */
    data: XOR<CourseContentUpdateInput, CourseContentUncheckedUpdateInput>
    /**
     * Choose, which CourseContent to update.
     */
    where: CourseContentWhereUniqueInput
  }

  /**
   * CourseContent updateMany
   */
  export type CourseContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseContents.
     */
    data: XOR<CourseContentUpdateManyMutationInput, CourseContentUncheckedUpdateManyInput>
    /**
     * Filter which CourseContents to update
     */
    where?: CourseContentWhereInput
  }

  /**
   * CourseContent upsert
   */
  export type CourseContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseContent to update in case it exists.
     */
    where: CourseContentWhereUniqueInput
    /**
     * In case the CourseContent found by the `where` argument doesn't exist, create a new CourseContent with this data.
     */
    create: XOR<CourseContentCreateInput, CourseContentUncheckedCreateInput>
    /**
     * In case the CourseContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseContentUpdateInput, CourseContentUncheckedUpdateInput>
  }

  /**
   * CourseContent delete
   */
  export type CourseContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter which CourseContent to delete.
     */
    where: CourseContentWhereUniqueInput
  }

  /**
   * CourseContent deleteMany
   */
  export type CourseContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseContents to delete
     */
    where?: CourseContentWhereInput
  }

  /**
   * CourseContent.Assessments
   */
  export type CourseContent$AssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessments
     */
    select?: AssessmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentsInclude<ExtArgs> | null
    where?: AssessmentsWhereInput
    orderBy?: AssessmentsOrderByWithRelationInput | AssessmentsOrderByWithRelationInput[]
    cursor?: AssessmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentsScalarFieldEnum | AssessmentsScalarFieldEnum[]
  }

  /**
   * CourseContent.CourseContent
   */
  export type CourseContent$CourseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    where?: CourseContentWhereInput
  }

  /**
   * CourseContent.other_CourseContent
   */
  export type CourseContent$other_CourseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    where?: CourseContentWhereInput
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    cursor?: CourseContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * CourseContent.LessonProgress
   */
  export type CourseContent$LessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    cursor?: LessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * CourseContent without action
   */
  export type CourseContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
  }


  /**
   * Model CourseTags
   */

  export type AggregateCourseTags = {
    _count: CourseTagsCountAggregateOutputType | null
    _avg: CourseTagsAvgAggregateOutputType | null
    _sum: CourseTagsSumAggregateOutputType | null
    _min: CourseTagsMinAggregateOutputType | null
    _max: CourseTagsMaxAggregateOutputType | null
  }

  export type CourseTagsAvgAggregateOutputType = {
    id: number | null
    course_id: number | null
  }

  export type CourseTagsSumAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
  }

  export type CourseTagsMinAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    tag_name: string | null
    tag_type: $Enums.CourseTags_tag_type | null
  }

  export type CourseTagsMaxAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    tag_name: string | null
    tag_type: $Enums.CourseTags_tag_type | null
  }

  export type CourseTagsCountAggregateOutputType = {
    id: number
    course_id: number
    tag_name: number
    tag_type: number
    _all: number
  }


  export type CourseTagsAvgAggregateInputType = {
    id?: true
    course_id?: true
  }

  export type CourseTagsSumAggregateInputType = {
    id?: true
    course_id?: true
  }

  export type CourseTagsMinAggregateInputType = {
    id?: true
    course_id?: true
    tag_name?: true
    tag_type?: true
  }

  export type CourseTagsMaxAggregateInputType = {
    id?: true
    course_id?: true
    tag_name?: true
    tag_type?: true
  }

  export type CourseTagsCountAggregateInputType = {
    id?: true
    course_id?: true
    tag_name?: true
    tag_type?: true
    _all?: true
  }

  export type CourseTagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTags to aggregate.
     */
    where?: CourseTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseTags
    **/
    _count?: true | CourseTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseTagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseTagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseTagsMaxAggregateInputType
  }

  export type GetCourseTagsAggregateType<T extends CourseTagsAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseTags[P]>
      : GetScalarType<T[P], AggregateCourseTags[P]>
  }




  export type CourseTagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagsWhereInput
    orderBy?: CourseTagsOrderByWithAggregationInput | CourseTagsOrderByWithAggregationInput[]
    by: CourseTagsScalarFieldEnum[] | CourseTagsScalarFieldEnum
    having?: CourseTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseTagsCountAggregateInputType | true
    _avg?: CourseTagsAvgAggregateInputType
    _sum?: CourseTagsSumAggregateInputType
    _min?: CourseTagsMinAggregateInputType
    _max?: CourseTagsMaxAggregateInputType
  }

  export type CourseTagsGroupByOutputType = {
    id: bigint
    course_id: bigint
    tag_name: string
    tag_type: $Enums.CourseTags_tag_type
    _count: CourseTagsCountAggregateOutputType | null
    _avg: CourseTagsAvgAggregateOutputType | null
    _sum: CourseTagsSumAggregateOutputType | null
    _min: CourseTagsMinAggregateOutputType | null
    _max: CourseTagsMaxAggregateOutputType | null
  }

  type GetCourseTagsGroupByPayload<T extends CourseTagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseTagsGroupByOutputType[P]>
            : GetScalarType<T[P], CourseTagsGroupByOutputType[P]>
        }
      >
    >


  export type CourseTagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    tag_name?: boolean
    tag_type?: boolean
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTags"]>


  export type CourseTagsSelectScalar = {
    id?: boolean
    course_id?: boolean
    tag_name?: boolean
    tag_type?: boolean
  }

  export type CourseTagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
  }

  export type $CourseTagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseTags"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      course_id: bigint
      tag_name: string
      tag_type: $Enums.CourseTags_tag_type
    }, ExtArgs["result"]["courseTags"]>
    composites: {}
  }

  type CourseTagsGetPayload<S extends boolean | null | undefined | CourseTagsDefaultArgs> = $Result.GetResult<Prisma.$CourseTagsPayload, S>

  type CourseTagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseTagsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseTagsCountAggregateInputType | true
    }

  export interface CourseTagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseTags'], meta: { name: 'CourseTags' } }
    /**
     * Find zero or one CourseTags that matches the filter.
     * @param {CourseTagsFindUniqueArgs} args - Arguments to find a CourseTags
     * @example
     * // Get one CourseTags
     * const courseTags = await prisma.courseTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseTagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CourseTagsFindUniqueArgs<ExtArgs>>
    ): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CourseTags that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseTagsFindUniqueOrThrowArgs} args - Arguments to find a CourseTags
     * @example
     * // Get one CourseTags
     * const courseTags = await prisma.courseTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CourseTagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseTagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CourseTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsFindFirstArgs} args - Arguments to find a CourseTags
     * @example
     * // Get one CourseTags
     * const courseTags = await prisma.courseTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseTagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseTagsFindFirstArgs<ExtArgs>>
    ): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CourseTags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsFindFirstOrThrowArgs} args - Arguments to find a CourseTags
     * @example
     * // Get one CourseTags
     * const courseTags = await prisma.courseTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CourseTagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseTagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CourseTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseTags
     * const courseTags = await prisma.courseTags.findMany()
     * 
     * // Get first 10 CourseTags
     * const courseTags = await prisma.courseTags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseTagsWithIdOnly = await prisma.courseTags.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CourseTagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseTagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CourseTags.
     * @param {CourseTagsCreateArgs} args - Arguments to create a CourseTags.
     * @example
     * // Create one CourseTags
     * const CourseTags = await prisma.courseTags.create({
     *   data: {
     *     // ... data to create a CourseTags
     *   }
     * })
     * 
    **/
    create<T extends CourseTagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseTagsCreateArgs<ExtArgs>>
    ): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CourseTags.
     * @param {CourseTagsCreateManyArgs} args - Arguments to create many CourseTags.
     * @example
     * // Create many CourseTags
     * const courseTags = await prisma.courseTags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CourseTagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseTagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseTags.
     * @param {CourseTagsDeleteArgs} args - Arguments to delete one CourseTags.
     * @example
     * // Delete one CourseTags
     * const CourseTags = await prisma.courseTags.delete({
     *   where: {
     *     // ... filter to delete one CourseTags
     *   }
     * })
     * 
    **/
    delete<T extends CourseTagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CourseTagsDeleteArgs<ExtArgs>>
    ): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CourseTags.
     * @param {CourseTagsUpdateArgs} args - Arguments to update one CourseTags.
     * @example
     * // Update one CourseTags
     * const courseTags = await prisma.courseTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseTagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseTagsUpdateArgs<ExtArgs>>
    ): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CourseTags.
     * @param {CourseTagsDeleteManyArgs} args - Arguments to filter CourseTags to delete.
     * @example
     * // Delete a few CourseTags
     * const { count } = await prisma.courseTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseTagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseTagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseTags
     * const courseTags = await prisma.courseTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseTagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CourseTagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseTags.
     * @param {CourseTagsUpsertArgs} args - Arguments to update or create a CourseTags.
     * @example
     * // Update or create a CourseTags
     * const courseTags = await prisma.courseTags.upsert({
     *   create: {
     *     // ... data to create a CourseTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseTags we want to update
     *   }
     * })
    **/
    upsert<T extends CourseTagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CourseTagsUpsertArgs<ExtArgs>>
    ): Prisma__CourseTagsClient<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsCountArgs} args - Arguments to filter CourseTags to count.
     * @example
     * // Count the number of CourseTags
     * const count = await prisma.courseTags.count({
     *   where: {
     *     // ... the filter for the CourseTags we want to count
     *   }
     * })
    **/
    count<T extends CourseTagsCountArgs>(
      args?: Subset<T, CourseTagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseTagsAggregateArgs>(args: Subset<T, CourseTagsAggregateArgs>): Prisma.PrismaPromise<GetCourseTagsAggregateType<T>>

    /**
     * Group by CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseTagsGroupByArgs['orderBy'] }
        : { orderBy?: CourseTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseTags model
   */
  readonly fields: CourseTagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseTagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CourseTags model
   */ 
  interface CourseTagsFieldRefs {
    readonly id: FieldRef<"CourseTags", 'BigInt'>
    readonly course_id: FieldRef<"CourseTags", 'BigInt'>
    readonly tag_name: FieldRef<"CourseTags", 'String'>
    readonly tag_type: FieldRef<"CourseTags", 'CourseTags_tag_type'>
  }
    

  // Custom InputTypes
  /**
   * CourseTags findUnique
   */
  export type CourseTagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where: CourseTagsWhereUniqueInput
  }

  /**
   * CourseTags findUniqueOrThrow
   */
  export type CourseTagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where: CourseTagsWhereUniqueInput
  }

  /**
   * CourseTags findFirst
   */
  export type CourseTagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where?: CourseTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagsScalarFieldEnum | CourseTagsScalarFieldEnum[]
  }

  /**
   * CourseTags findFirstOrThrow
   */
  export type CourseTagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where?: CourseTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagsScalarFieldEnum | CourseTagsScalarFieldEnum[]
  }

  /**
   * CourseTags findMany
   */
  export type CourseTagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where?: CourseTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseTags.
     */
    cursor?: CourseTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    distinct?: CourseTagsScalarFieldEnum | CourseTagsScalarFieldEnum[]
  }

  /**
   * CourseTags create
   */
  export type CourseTagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseTags.
     */
    data: XOR<CourseTagsCreateInput, CourseTagsUncheckedCreateInput>
  }

  /**
   * CourseTags createMany
   */
  export type CourseTagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseTags.
     */
    data: CourseTagsCreateManyInput | CourseTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseTags update
   */
  export type CourseTagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseTags.
     */
    data: XOR<CourseTagsUpdateInput, CourseTagsUncheckedUpdateInput>
    /**
     * Choose, which CourseTags to update.
     */
    where: CourseTagsWhereUniqueInput
  }

  /**
   * CourseTags updateMany
   */
  export type CourseTagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseTags.
     */
    data: XOR<CourseTagsUpdateManyMutationInput, CourseTagsUncheckedUpdateManyInput>
    /**
     * Filter which CourseTags to update
     */
    where?: CourseTagsWhereInput
  }

  /**
   * CourseTags upsert
   */
  export type CourseTagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseTags to update in case it exists.
     */
    where: CourseTagsWhereUniqueInput
    /**
     * In case the CourseTags found by the `where` argument doesn't exist, create a new CourseTags with this data.
     */
    create: XOR<CourseTagsCreateInput, CourseTagsUncheckedCreateInput>
    /**
     * In case the CourseTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseTagsUpdateInput, CourseTagsUncheckedUpdateInput>
  }

  /**
   * CourseTags delete
   */
  export type CourseTagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    /**
     * Filter which CourseTags to delete.
     */
    where: CourseTagsWhereUniqueInput
  }

  /**
   * CourseTags deleteMany
   */
  export type CourseTagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTags to delete
     */
    where?: CourseTagsWhereInput
  }

  /**
   * CourseTags without action
   */
  export type CourseTagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
  }


  /**
   * Model Courses
   */

  export type AggregateCourses = {
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  export type CoursesAvgAggregateOutputType = {
    id: number | null
    instructor_id: number | null
    category_id: number | null
    price: Decimal | null
    views: number | null
    enrollments_count: number | null
  }

  export type CoursesSumAggregateOutputType = {
    id: bigint | null
    instructor_id: bigint | null
    category_id: bigint | null
    price: Decimal | null
    views: number | null
    enrollments_count: number | null
  }

  export type CoursesMinAggregateOutputType = {
    id: bigint | null
    instructor_id: bigint | null
    title: string | null
    subtitle: string | null
    description: string | null
    category_id: bigint | null
    price: Decimal | null
    thumbnail_url: string | null
    level: $Enums.Courses_level | null
    views: number | null
    enrollments_count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CoursesMaxAggregateOutputType = {
    id: bigint | null
    instructor_id: bigint | null
    title: string | null
    subtitle: string | null
    description: string | null
    category_id: bigint | null
    price: Decimal | null
    thumbnail_url: string | null
    level: $Enums.Courses_level | null
    views: number | null
    enrollments_count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CoursesCountAggregateOutputType = {
    id: number
    instructor_id: number
    title: number
    subtitle: number
    description: number
    category_id: number
    price: number
    thumbnail_url: number
    level: number
    views: number
    enrollments_count: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CoursesAvgAggregateInputType = {
    id?: true
    instructor_id?: true
    category_id?: true
    price?: true
    views?: true
    enrollments_count?: true
  }

  export type CoursesSumAggregateInputType = {
    id?: true
    instructor_id?: true
    category_id?: true
    price?: true
    views?: true
    enrollments_count?: true
  }

  export type CoursesMinAggregateInputType = {
    id?: true
    instructor_id?: true
    title?: true
    subtitle?: true
    description?: true
    category_id?: true
    price?: true
    thumbnail_url?: true
    level?: true
    views?: true
    enrollments_count?: true
    created_at?: true
    updated_at?: true
  }

  export type CoursesMaxAggregateInputType = {
    id?: true
    instructor_id?: true
    title?: true
    subtitle?: true
    description?: true
    category_id?: true
    price?: true
    thumbnail_url?: true
    level?: true
    views?: true
    enrollments_count?: true
    created_at?: true
    updated_at?: true
  }

  export type CoursesCountAggregateInputType = {
    id?: true
    instructor_id?: true
    title?: true
    subtitle?: true
    description?: true
    category_id?: true
    price?: true
    thumbnail_url?: true
    level?: true
    views?: true
    enrollments_count?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CoursesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to aggregate.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CoursesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoursesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoursesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursesMaxAggregateInputType
  }

  export type GetCoursesAggregateType<T extends CoursesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourses[P]>
      : GetScalarType<T[P], AggregateCourses[P]>
  }




  export type CoursesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursesWhereInput
    orderBy?: CoursesOrderByWithAggregationInput | CoursesOrderByWithAggregationInput[]
    by: CoursesScalarFieldEnum[] | CoursesScalarFieldEnum
    having?: CoursesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursesCountAggregateInputType | true
    _avg?: CoursesAvgAggregateInputType
    _sum?: CoursesSumAggregateInputType
    _min?: CoursesMinAggregateInputType
    _max?: CoursesMaxAggregateInputType
  }

  export type CoursesGroupByOutputType = {
    id: bigint
    instructor_id: bigint
    title: string
    subtitle: string | null
    description: string | null
    category_id: bigint
    price: Decimal | null
    thumbnail_url: string | null
    level: $Enums.Courses_level
    views: number | null
    enrollments_count: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  type GetCoursesGroupByPayload<T extends CoursesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursesGroupByOutputType[P]>
            : GetScalarType<T[P], CoursesGroupByOutputType[P]>
        }
      >
    >


  export type CoursesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructor_id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    category_id?: boolean
    price?: boolean
    thumbnail_url?: boolean
    level?: boolean
    views?: boolean
    enrollments_count?: boolean
    created_at?: boolean
    updated_at?: boolean
    Certificates?: boolean | Courses$CertificatesArgs<ExtArgs>
    CourseContent?: boolean | Courses$CourseContentArgs<ExtArgs>
    CourseTags?: boolean | Courses$CourseTagsArgs<ExtArgs>
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Enrollments?: boolean | Courses$EnrollmentsArgs<ExtArgs>
    Payments?: boolean | Courses$PaymentsArgs<ExtArgs>
    Reviews?: boolean | Courses$ReviewsArgs<ExtArgs>
    ShoppingCart?: boolean | Courses$ShoppingCartArgs<ExtArgs>
    UserSavedCourses?: boolean | Courses$UserSavedCoursesArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courses"]>


  export type CoursesSelectScalar = {
    id?: boolean
    instructor_id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    category_id?: boolean
    price?: boolean
    thumbnail_url?: boolean
    level?: boolean
    views?: boolean
    enrollments_count?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CoursesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Certificates?: boolean | Courses$CertificatesArgs<ExtArgs>
    CourseContent?: boolean | Courses$CourseContentArgs<ExtArgs>
    CourseTags?: boolean | Courses$CourseTagsArgs<ExtArgs>
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Enrollments?: boolean | Courses$EnrollmentsArgs<ExtArgs>
    Payments?: boolean | Courses$PaymentsArgs<ExtArgs>
    Reviews?: boolean | Courses$ReviewsArgs<ExtArgs>
    ShoppingCart?: boolean | Courses$ShoppingCartArgs<ExtArgs>
    UserSavedCourses?: boolean | Courses$UserSavedCoursesArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CoursesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Courses"
    objects: {
      Certificates: Prisma.$CertificatesPayload<ExtArgs>[]
      CourseContent: Prisma.$CourseContentPayload<ExtArgs>[]
      CourseTags: Prisma.$CourseTagsPayload<ExtArgs>[]
      Categories: Prisma.$CategoriesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
      Enrollments: Prisma.$EnrollmentsPayload<ExtArgs>[]
      Payments: Prisma.$PaymentsPayload<ExtArgs>[]
      Reviews: Prisma.$ReviewsPayload<ExtArgs>[]
      ShoppingCart: Prisma.$ShoppingCartPayload<ExtArgs>[]
      UserSavedCourses: Prisma.$UserSavedCoursesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      instructor_id: bigint
      title: string
      subtitle: string | null
      description: string | null
      category_id: bigint
      price: Prisma.Decimal | null
      thumbnail_url: string | null
      level: $Enums.Courses_level
      views: number | null
      enrollments_count: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["courses"]>
    composites: {}
  }

  type CoursesGetPayload<S extends boolean | null | undefined | CoursesDefaultArgs> = $Result.GetResult<Prisma.$CoursesPayload, S>

  type CoursesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoursesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoursesCountAggregateInputType | true
    }

  export interface CoursesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Courses'], meta: { name: 'Courses' } }
    /**
     * Find zero or one Courses that matches the filter.
     * @param {CoursesFindUniqueArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoursesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesFindUniqueArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Courses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoursesFindUniqueOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CoursesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindFirstArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoursesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesFindFirstArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Courses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindFirstOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CoursesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.courses.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.courses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursesWithIdOnly = await prisma.courses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CoursesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Courses.
     * @param {CoursesCreateArgs} args - Arguments to create a Courses.
     * @example
     * // Create one Courses
     * const Courses = await prisma.courses.create({
     *   data: {
     *     // ... data to create a Courses
     *   }
     * })
     * 
    **/
    create<T extends CoursesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesCreateArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CoursesCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const courses = await prisma.courses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CoursesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Courses.
     * @param {CoursesDeleteArgs} args - Arguments to delete one Courses.
     * @example
     * // Delete one Courses
     * const Courses = await prisma.courses.delete({
     *   where: {
     *     // ... filter to delete one Courses
     *   }
     * })
     * 
    **/
    delete<T extends CoursesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesDeleteArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Courses.
     * @param {CoursesUpdateArgs} args - Arguments to update one Courses.
     * @example
     * // Update one Courses
     * const courses = await prisma.courses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoursesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesUpdateArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CoursesDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.courses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoursesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const courses = await prisma.courses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoursesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Courses.
     * @param {CoursesUpsertArgs} args - Arguments to update or create a Courses.
     * @example
     * // Update or create a Courses
     * const courses = await prisma.courses.upsert({
     *   create: {
     *     // ... data to create a Courses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courses we want to update
     *   }
     * })
    **/
    upsert<T extends CoursesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesUpsertArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.courses.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CoursesCountArgs>(
      args?: Subset<T, CoursesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursesAggregateArgs>(args: Subset<T, CoursesAggregateArgs>): Prisma.PrismaPromise<GetCoursesAggregateType<T>>

    /**
     * Group by Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoursesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoursesGroupByArgs['orderBy'] }
        : { orderBy?: CoursesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoursesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Courses model
   */
  readonly fields: CoursesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Courses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoursesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Certificates<T extends Courses$CertificatesArgs<ExtArgs> = {}>(args?: Subset<T, Courses$CertificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'findMany'> | Null>;

    CourseContent<T extends Courses$CourseContentArgs<ExtArgs> = {}>(args?: Subset<T, Courses$CourseContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findMany'> | Null>;

    CourseTags<T extends Courses$CourseTagsArgs<ExtArgs> = {}>(args?: Subset<T, Courses$CourseTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Categories<T extends CategoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriesDefaultArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Enrollments<T extends Courses$EnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Courses$EnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Payments<T extends Courses$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Courses$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Reviews<T extends Courses$ReviewsArgs<ExtArgs> = {}>(args?: Subset<T, Courses$ReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'findMany'> | Null>;

    ShoppingCart<T extends Courses$ShoppingCartArgs<ExtArgs> = {}>(args?: Subset<T, Courses$ShoppingCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'findMany'> | Null>;

    UserSavedCourses<T extends Courses$UserSavedCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Courses$UserSavedCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Courses model
   */ 
  interface CoursesFieldRefs {
    readonly id: FieldRef<"Courses", 'BigInt'>
    readonly instructor_id: FieldRef<"Courses", 'BigInt'>
    readonly title: FieldRef<"Courses", 'String'>
    readonly subtitle: FieldRef<"Courses", 'String'>
    readonly description: FieldRef<"Courses", 'String'>
    readonly category_id: FieldRef<"Courses", 'BigInt'>
    readonly price: FieldRef<"Courses", 'Decimal'>
    readonly thumbnail_url: FieldRef<"Courses", 'String'>
    readonly level: FieldRef<"Courses", 'Courses_level'>
    readonly views: FieldRef<"Courses", 'Int'>
    readonly enrollments_count: FieldRef<"Courses", 'Int'>
    readonly created_at: FieldRef<"Courses", 'DateTime'>
    readonly updated_at: FieldRef<"Courses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Courses findUnique
   */
  export type CoursesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where: CoursesWhereUniqueInput
  }

  /**
   * Courses findUniqueOrThrow
   */
  export type CoursesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where: CoursesWhereUniqueInput
  }

  /**
   * Courses findFirst
   */
  export type CoursesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * Courses findFirstOrThrow
   */
  export type CoursesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * Courses findMany
   */
  export type CoursesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * Courses create
   */
  export type CoursesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * The data needed to create a Courses.
     */
    data: XOR<CoursesCreateInput, CoursesUncheckedCreateInput>
  }

  /**
   * Courses createMany
   */
  export type CoursesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CoursesCreateManyInput | CoursesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Courses update
   */
  export type CoursesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * The data needed to update a Courses.
     */
    data: XOR<CoursesUpdateInput, CoursesUncheckedUpdateInput>
    /**
     * Choose, which Courses to update.
     */
    where: CoursesWhereUniqueInput
  }

  /**
   * Courses updateMany
   */
  export type CoursesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CoursesUpdateManyMutationInput, CoursesUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CoursesWhereInput
  }

  /**
   * Courses upsert
   */
  export type CoursesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * The filter to search for the Courses to update in case it exists.
     */
    where: CoursesWhereUniqueInput
    /**
     * In case the Courses found by the `where` argument doesn't exist, create a new Courses with this data.
     */
    create: XOR<CoursesCreateInput, CoursesUncheckedCreateInput>
    /**
     * In case the Courses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoursesUpdateInput, CoursesUncheckedUpdateInput>
  }

  /**
   * Courses delete
   */
  export type CoursesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter which Courses to delete.
     */
    where: CoursesWhereUniqueInput
  }

  /**
   * Courses deleteMany
   */
  export type CoursesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CoursesWhereInput
  }

  /**
   * Courses.Certificates
   */
  export type Courses$CertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    where?: CertificatesWhereInput
    orderBy?: CertificatesOrderByWithRelationInput | CertificatesOrderByWithRelationInput[]
    cursor?: CertificatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * Courses.CourseContent
   */
  export type Courses$CourseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    where?: CourseContentWhereInput
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    cursor?: CourseContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * Courses.CourseTags
   */
  export type Courses$CourseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTags
     */
    select?: CourseTagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagsInclude<ExtArgs> | null
    where?: CourseTagsWhereInput
    orderBy?: CourseTagsOrderByWithRelationInput | CourseTagsOrderByWithRelationInput[]
    cursor?: CourseTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTagsScalarFieldEnum | CourseTagsScalarFieldEnum[]
  }

  /**
   * Courses.Enrollments
   */
  export type Courses$EnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    where?: EnrollmentsWhereInput
    orderBy?: EnrollmentsOrderByWithRelationInput | EnrollmentsOrderByWithRelationInput[]
    cursor?: EnrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * Courses.Payments
   */
  export type Courses$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Courses.Reviews
   */
  export type Courses$ReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    where?: ReviewsWhereInput
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    cursor?: ReviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Courses.ShoppingCart
   */
  export type Courses$ShoppingCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    where?: ShoppingCartWhereInput
    orderBy?: ShoppingCartOrderByWithRelationInput | ShoppingCartOrderByWithRelationInput[]
    cursor?: ShoppingCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShoppingCartScalarFieldEnum | ShoppingCartScalarFieldEnum[]
  }

  /**
   * Courses.UserSavedCourses
   */
  export type Courses$UserSavedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    where?: UserSavedCoursesWhereInput
    orderBy?: UserSavedCoursesOrderByWithRelationInput | UserSavedCoursesOrderByWithRelationInput[]
    cursor?: UserSavedCoursesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSavedCoursesScalarFieldEnum | UserSavedCoursesScalarFieldEnum[]
  }

  /**
   * Courses without action
   */
  export type CoursesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
  }


  /**
   * Model Enrollments
   */

  export type AggregateEnrollments = {
    _count: EnrollmentsCountAggregateOutputType | null
    _avg: EnrollmentsAvgAggregateOutputType | null
    _sum: EnrollmentsSumAggregateOutputType | null
    _min: EnrollmentsMinAggregateOutputType | null
    _max: EnrollmentsMaxAggregateOutputType | null
  }

  export type EnrollmentsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    course_id: number | null
  }

  export type EnrollmentsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
  }

  export type EnrollmentsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    enrolled_at: Date | null
  }

  export type EnrollmentsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    enrolled_at: Date | null
  }

  export type EnrollmentsCountAggregateOutputType = {
    id: number
    user_id: number
    course_id: number
    enrolled_at: number
    _all: number
  }


  export type EnrollmentsAvgAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type EnrollmentsSumAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type EnrollmentsMinAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    enrolled_at?: true
  }

  export type EnrollmentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    enrolled_at?: true
  }

  export type EnrollmentsCountAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    enrolled_at?: true
    _all?: true
  }

  export type EnrollmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to aggregate.
     */
    where?: EnrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentsOrderByWithRelationInput | EnrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentsMaxAggregateInputType
  }

  export type GetEnrollmentsAggregateType<T extends EnrollmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollments[P]>
      : GetScalarType<T[P], AggregateEnrollments[P]>
  }




  export type EnrollmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentsWhereInput
    orderBy?: EnrollmentsOrderByWithAggregationInput | EnrollmentsOrderByWithAggregationInput[]
    by: EnrollmentsScalarFieldEnum[] | EnrollmentsScalarFieldEnum
    having?: EnrollmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentsCountAggregateInputType | true
    _avg?: EnrollmentsAvgAggregateInputType
    _sum?: EnrollmentsSumAggregateInputType
    _min?: EnrollmentsMinAggregateInputType
    _max?: EnrollmentsMaxAggregateInputType
  }

  export type EnrollmentsGroupByOutputType = {
    id: bigint
    user_id: bigint
    course_id: bigint
    enrolled_at: Date | null
    _count: EnrollmentsCountAggregateOutputType | null
    _avg: EnrollmentsAvgAggregateOutputType | null
    _sum: EnrollmentsSumAggregateOutputType | null
    _min: EnrollmentsMinAggregateOutputType | null
    _max: EnrollmentsMaxAggregateOutputType | null
  }

  type GetEnrollmentsGroupByPayload<T extends EnrollmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentsGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentsGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    enrolled_at?: boolean
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>


  export type EnrollmentsSelectScalar = {
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    enrolled_at?: boolean
  }

  export type EnrollmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $EnrollmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollments"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      course_id: bigint
      enrolled_at: Date | null
    }, ExtArgs["result"]["enrollments"]>
    composites: {}
  }

  type EnrollmentsGetPayload<S extends boolean | null | undefined | EnrollmentsDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentsPayload, S>

  type EnrollmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnrollmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnrollmentsCountAggregateInputType | true
    }

  export interface EnrollmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollments'], meta: { name: 'Enrollments' } }
    /**
     * Find zero or one Enrollments that matches the filter.
     * @param {EnrollmentsFindUniqueArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnrollmentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EnrollmentsFindUniqueArgs<ExtArgs>>
    ): Prisma__EnrollmentsClient<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Enrollments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnrollmentsFindUniqueOrThrowArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnrollmentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnrollmentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnrollmentsClient<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsFindFirstArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnrollmentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EnrollmentsFindFirstArgs<ExtArgs>>
    ): Prisma__EnrollmentsClient<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Enrollments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsFindFirstOrThrowArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnrollmentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnrollmentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnrollmentsClient<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollments.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnrollmentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnrollmentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Enrollments.
     * @param {EnrollmentsCreateArgs} args - Arguments to create a Enrollments.
     * @example
     * // Create one Enrollments
     * const Enrollments = await prisma.enrollments.create({
     *   data: {
     *     // ... data to create a Enrollments
     *   }
     * })
     * 
    **/
    create<T extends EnrollmentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EnrollmentsCreateArgs<ExtArgs>>
    ): Prisma__EnrollmentsClient<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Enrollments.
     * @param {EnrollmentsCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollments = await prisma.enrollments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends EnrollmentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnrollmentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enrollments.
     * @param {EnrollmentsDeleteArgs} args - Arguments to delete one Enrollments.
     * @example
     * // Delete one Enrollments
     * const Enrollments = await prisma.enrollments.delete({
     *   where: {
     *     // ... filter to delete one Enrollments
     *   }
     * })
     * 
    **/
    delete<T extends EnrollmentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EnrollmentsDeleteArgs<ExtArgs>>
    ): Prisma__EnrollmentsClient<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Enrollments.
     * @param {EnrollmentsUpdateArgs} args - Arguments to update one Enrollments.
     * @example
     * // Update one Enrollments
     * const enrollments = await prisma.enrollments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnrollmentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EnrollmentsUpdateArgs<ExtArgs>>
    ): Prisma__EnrollmentsClient<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentsDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnrollmentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnrollmentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollments = await prisma.enrollments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnrollmentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EnrollmentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enrollments.
     * @param {EnrollmentsUpsertArgs} args - Arguments to update or create a Enrollments.
     * @example
     * // Update or create a Enrollments
     * const enrollments = await prisma.enrollments.upsert({
     *   create: {
     *     // ... data to create a Enrollments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollments we want to update
     *   }
     * })
    **/
    upsert<T extends EnrollmentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EnrollmentsUpsertArgs<ExtArgs>>
    ): Prisma__EnrollmentsClient<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollments.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentsCountArgs>(
      args?: Subset<T, EnrollmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentsAggregateArgs>(args: Subset<T, EnrollmentsAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentsAggregateType<T>>

    /**
     * Group by Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentsGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollments model
   */
  readonly fields: EnrollmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Enrollments model
   */ 
  interface EnrollmentsFieldRefs {
    readonly id: FieldRef<"Enrollments", 'BigInt'>
    readonly user_id: FieldRef<"Enrollments", 'BigInt'>
    readonly course_id: FieldRef<"Enrollments", 'BigInt'>
    readonly enrolled_at: FieldRef<"Enrollments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollments findUnique
   */
  export type EnrollmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where: EnrollmentsWhereUniqueInput
  }

  /**
   * Enrollments findUniqueOrThrow
   */
  export type EnrollmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where: EnrollmentsWhereUniqueInput
  }

  /**
   * Enrollments findFirst
   */
  export type EnrollmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentsOrderByWithRelationInput | EnrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * Enrollments findFirstOrThrow
   */
  export type EnrollmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentsOrderByWithRelationInput | EnrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * Enrollments findMany
   */
  export type EnrollmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentsOrderByWithRelationInput | EnrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * Enrollments create
   */
  export type EnrollmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollments.
     */
    data: XOR<EnrollmentsCreateInput, EnrollmentsUncheckedCreateInput>
  }

  /**
   * Enrollments createMany
   */
  export type EnrollmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentsCreateManyInput | EnrollmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollments update
   */
  export type EnrollmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollments.
     */
    data: XOR<EnrollmentsUpdateInput, EnrollmentsUncheckedUpdateInput>
    /**
     * Choose, which Enrollments to update.
     */
    where: EnrollmentsWhereUniqueInput
  }

  /**
   * Enrollments updateMany
   */
  export type EnrollmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentsUpdateManyMutationInput, EnrollmentsUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentsWhereInput
  }

  /**
   * Enrollments upsert
   */
  export type EnrollmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollments to update in case it exists.
     */
    where: EnrollmentsWhereUniqueInput
    /**
     * In case the Enrollments found by the `where` argument doesn't exist, create a new Enrollments with this data.
     */
    create: XOR<EnrollmentsCreateInput, EnrollmentsUncheckedCreateInput>
    /**
     * In case the Enrollments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentsUpdateInput, EnrollmentsUncheckedUpdateInput>
  }

  /**
   * Enrollments delete
   */
  export type EnrollmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    /**
     * Filter which Enrollments to delete.
     */
    where: EnrollmentsWhereUniqueInput
  }

  /**
   * Enrollments deleteMany
   */
  export type EnrollmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentsWhereInput
  }

  /**
   * Enrollments without action
   */
  export type EnrollmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
  }


  /**
   * Model LessonProgress
   */

  export type AggregateLessonProgress = {
    _count: LessonProgressCountAggregateOutputType | null
    _avg: LessonProgressAvgAggregateOutputType | null
    _sum: LessonProgressSumAggregateOutputType | null
    _min: LessonProgressMinAggregateOutputType | null
    _max: LessonProgressMaxAggregateOutputType | null
  }

  export type LessonProgressAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    content_id: number | null
  }

  export type LessonProgressSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    content_id: bigint | null
  }

  export type LessonProgressMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    content_id: bigint | null
    is_completed: boolean | null
    completed_at: Date | null
  }

  export type LessonProgressMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    content_id: bigint | null
    is_completed: boolean | null
    completed_at: Date | null
  }

  export type LessonProgressCountAggregateOutputType = {
    id: number
    user_id: number
    content_id: number
    is_completed: number
    completed_at: number
    _all: number
  }


  export type LessonProgressAvgAggregateInputType = {
    id?: true
    user_id?: true
    content_id?: true
  }

  export type LessonProgressSumAggregateInputType = {
    id?: true
    user_id?: true
    content_id?: true
  }

  export type LessonProgressMinAggregateInputType = {
    id?: true
    user_id?: true
    content_id?: true
    is_completed?: true
    completed_at?: true
  }

  export type LessonProgressMaxAggregateInputType = {
    id?: true
    user_id?: true
    content_id?: true
    is_completed?: true
    completed_at?: true
  }

  export type LessonProgressCountAggregateInputType = {
    id?: true
    user_id?: true
    content_id?: true
    is_completed?: true
    completed_at?: true
    _all?: true
  }

  export type LessonProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgress to aggregate.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonProgresses
    **/
    _count?: true | LessonProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonProgressMaxAggregateInputType
  }

  export type GetLessonProgressAggregateType<T extends LessonProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonProgress[P]>
      : GetScalarType<T[P], AggregateLessonProgress[P]>
  }




  export type LessonProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithAggregationInput | LessonProgressOrderByWithAggregationInput[]
    by: LessonProgressScalarFieldEnum[] | LessonProgressScalarFieldEnum
    having?: LessonProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonProgressCountAggregateInputType | true
    _avg?: LessonProgressAvgAggregateInputType
    _sum?: LessonProgressSumAggregateInputType
    _min?: LessonProgressMinAggregateInputType
    _max?: LessonProgressMaxAggregateInputType
  }

  export type LessonProgressGroupByOutputType = {
    id: bigint
    user_id: bigint
    content_id: bigint
    is_completed: boolean | null
    completed_at: Date | null
    _count: LessonProgressCountAggregateOutputType | null
    _avg: LessonProgressAvgAggregateOutputType | null
    _sum: LessonProgressSumAggregateOutputType | null
    _min: LessonProgressMinAggregateOutputType | null
    _max: LessonProgressMaxAggregateOutputType | null
  }

  type GetLessonProgressGroupByPayload<T extends LessonProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonProgressGroupByOutputType[P]>
            : GetScalarType<T[P], LessonProgressGroupByOutputType[P]>
        }
      >
    >


  export type LessonProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    content_id?: boolean
    is_completed?: boolean
    completed_at?: boolean
    CourseContent?: boolean | CourseContentDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgress"]>


  export type LessonProgressSelectScalar = {
    id?: boolean
    user_id?: boolean
    content_id?: boolean
    is_completed?: boolean
    completed_at?: boolean
  }

  export type LessonProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseContent?: boolean | CourseContentDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $LessonProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonProgress"
    objects: {
      CourseContent: Prisma.$CourseContentPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      content_id: bigint
      is_completed: boolean | null
      completed_at: Date | null
    }, ExtArgs["result"]["lessonProgress"]>
    composites: {}
  }

  type LessonProgressGetPayload<S extends boolean | null | undefined | LessonProgressDefaultArgs> = $Result.GetResult<Prisma.$LessonProgressPayload, S>

  type LessonProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonProgressCountAggregateInputType | true
    }

  export interface LessonProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonProgress'], meta: { name: 'LessonProgress' } }
    /**
     * Find zero or one LessonProgress that matches the filter.
     * @param {LessonProgressFindUniqueArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LessonProgressFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LessonProgressFindUniqueArgs<ExtArgs>>
    ): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LessonProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LessonProgressFindUniqueOrThrowArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LessonProgressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonProgressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LessonProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindFirstArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LessonProgressFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonProgressFindFirstArgs<ExtArgs>>
    ): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LessonProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindFirstOrThrowArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LessonProgressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonProgressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LessonProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonProgresses
     * const lessonProgresses = await prisma.lessonProgress.findMany()
     * 
     * // Get first 10 LessonProgresses
     * const lessonProgresses = await prisma.lessonProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonProgressWithIdOnly = await prisma.lessonProgress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LessonProgressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonProgressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LessonProgress.
     * @param {LessonProgressCreateArgs} args - Arguments to create a LessonProgress.
     * @example
     * // Create one LessonProgress
     * const LessonProgress = await prisma.lessonProgress.create({
     *   data: {
     *     // ... data to create a LessonProgress
     *   }
     * })
     * 
    **/
    create<T extends LessonProgressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LessonProgressCreateArgs<ExtArgs>>
    ): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LessonProgresses.
     * @param {LessonProgressCreateManyArgs} args - Arguments to create many LessonProgresses.
     * @example
     * // Create many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends LessonProgressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonProgressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LessonProgress.
     * @param {LessonProgressDeleteArgs} args - Arguments to delete one LessonProgress.
     * @example
     * // Delete one LessonProgress
     * const LessonProgress = await prisma.lessonProgress.delete({
     *   where: {
     *     // ... filter to delete one LessonProgress
     *   }
     * })
     * 
    **/
    delete<T extends LessonProgressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LessonProgressDeleteArgs<ExtArgs>>
    ): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LessonProgress.
     * @param {LessonProgressUpdateArgs} args - Arguments to update one LessonProgress.
     * @example
     * // Update one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LessonProgressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LessonProgressUpdateArgs<ExtArgs>>
    ): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LessonProgresses.
     * @param {LessonProgressDeleteManyArgs} args - Arguments to filter LessonProgresses to delete.
     * @example
     * // Delete a few LessonProgresses
     * const { count } = await prisma.lessonProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LessonProgressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonProgressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LessonProgressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LessonProgressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LessonProgress.
     * @param {LessonProgressUpsertArgs} args - Arguments to update or create a LessonProgress.
     * @example
     * // Update or create a LessonProgress
     * const lessonProgress = await prisma.lessonProgress.upsert({
     *   create: {
     *     // ... data to create a LessonProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonProgress we want to update
     *   }
     * })
    **/
    upsert<T extends LessonProgressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LessonProgressUpsertArgs<ExtArgs>>
    ): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressCountArgs} args - Arguments to filter LessonProgresses to count.
     * @example
     * // Count the number of LessonProgresses
     * const count = await prisma.lessonProgress.count({
     *   where: {
     *     // ... the filter for the LessonProgresses we want to count
     *   }
     * })
    **/
    count<T extends LessonProgressCountArgs>(
      args?: Subset<T, LessonProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonProgressAggregateArgs>(args: Subset<T, LessonProgressAggregateArgs>): Prisma.PrismaPromise<GetLessonProgressAggregateType<T>>

    /**
     * Group by LessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonProgressGroupByArgs['orderBy'] }
        : { orderBy?: LessonProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonProgress model
   */
  readonly fields: LessonProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CourseContent<T extends CourseContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseContentDefaultArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LessonProgress model
   */ 
  interface LessonProgressFieldRefs {
    readonly id: FieldRef<"LessonProgress", 'BigInt'>
    readonly user_id: FieldRef<"LessonProgress", 'BigInt'>
    readonly content_id: FieldRef<"LessonProgress", 'BigInt'>
    readonly is_completed: FieldRef<"LessonProgress", 'Boolean'>
    readonly completed_at: FieldRef<"LessonProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LessonProgress findUnique
   */
  export type LessonProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress findUniqueOrThrow
   */
  export type LessonProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress findFirst
   */
  export type LessonProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgresses.
     */
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress findFirstOrThrow
   */
  export type LessonProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgresses.
     */
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress findMany
   */
  export type LessonProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgresses to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress create
   */
  export type LessonProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonProgress.
     */
    data: XOR<LessonProgressCreateInput, LessonProgressUncheckedCreateInput>
  }

  /**
   * LessonProgress createMany
   */
  export type LessonProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonProgresses.
     */
    data: LessonProgressCreateManyInput | LessonProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonProgress update
   */
  export type LessonProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonProgress.
     */
    data: XOR<LessonProgressUpdateInput, LessonProgressUncheckedUpdateInput>
    /**
     * Choose, which LessonProgress to update.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress updateMany
   */
  export type LessonProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonProgresses.
     */
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgresses to update
     */
    where?: LessonProgressWhereInput
  }

  /**
   * LessonProgress upsert
   */
  export type LessonProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonProgress to update in case it exists.
     */
    where: LessonProgressWhereUniqueInput
    /**
     * In case the LessonProgress found by the `where` argument doesn't exist, create a new LessonProgress with this data.
     */
    create: XOR<LessonProgressCreateInput, LessonProgressUncheckedCreateInput>
    /**
     * In case the LessonProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonProgressUpdateInput, LessonProgressUncheckedUpdateInput>
  }

  /**
   * LessonProgress delete
   */
  export type LessonProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter which LessonProgress to delete.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress deleteMany
   */
  export type LessonProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgresses to delete
     */
    where?: LessonProgressWhereInput
  }

  /**
   * LessonProgress without action
   */
  export type LessonProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
  }


  /**
   * Model Messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesAvgAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
  }

  export type MessagesSumAggregateOutputType = {
    id: bigint | null
    sender_id: bigint | null
    receiver_id: bigint | null
  }

  export type MessagesMinAggregateOutputType = {
    id: bigint | null
    sender_id: bigint | null
    receiver_id: bigint | null
    content: string | null
    created_at: Date | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: bigint | null
    sender_id: bigint | null
    receiver_id: bigint | null
    content: string | null
    created_at: Date | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    sender_id: number
    receiver_id: number
    content: number
    created_at: number
    _all: number
  }


  export type MessagesAvgAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
  }

  export type MessagesSumAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
  }

  export type MessagesMinAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    content?: true
    created_at?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    content?: true
    created_at?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    content?: true
    created_at?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to aggregate.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type MessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithAggregationInput | MessagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: MessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _avg?: MessagesAvgAggregateInputType
    _sum?: MessagesSumAggregateInputType
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: bigint
    sender_id: bigint
    receiver_id: bigint
    content: string
    created_at: Date | null
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends MessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type MessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    created_at?: boolean
    Users_Messages_receiver_idToUsers?: boolean | UsersDefaultArgs<ExtArgs>
    Users_Messages_sender_idToUsers?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>


  export type MessagesSelectScalar = {
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    created_at?: boolean
  }

  export type MessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users_Messages_receiver_idToUsers?: boolean | UsersDefaultArgs<ExtArgs>
    Users_Messages_sender_idToUsers?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $MessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Messages"
    objects: {
      Users_Messages_receiver_idToUsers: Prisma.$UsersPayload<ExtArgs>
      Users_Messages_sender_idToUsers: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      sender_id: bigint
      receiver_id: bigint
      content: string
      created_at: Date | null
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type MessagesGetPayload<S extends boolean | null | undefined | MessagesDefaultArgs> = $Result.GetResult<Prisma.$MessagesPayload, S>

  type MessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface MessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Messages'], meta: { name: 'Messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {MessagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessagesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessagesFindUniqueArgs<ExtArgs>>
    ): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessagesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessagesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessagesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessagesFindFirstArgs<ExtArgs>>
    ): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessagesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessagesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessagesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessagesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Messages.
     * @param {MessagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
    **/
    create<T extends MessagesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessagesCreateArgs<ExtArgs>>
    ): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends MessagesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessagesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Messages.
     * @param {MessagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
    **/
    delete<T extends MessagesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessagesDeleteArgs<ExtArgs>>
    ): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Messages.
     * @param {MessagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessagesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessagesUpdateArgs<ExtArgs>>
    ): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessagesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessagesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessagesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessagesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Messages.
     * @param {MessagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
    **/
    upsert<T extends MessagesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessagesUpsertArgs<ExtArgs>>
    ): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessagesCountArgs>(
      args?: Subset<T, MessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessagesGroupByArgs['orderBy'] }
        : { orderBy?: MessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Messages model
   */
  readonly fields: MessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users_Messages_receiver_idToUsers<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Users_Messages_sender_idToUsers<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Messages model
   */ 
  interface MessagesFieldRefs {
    readonly id: FieldRef<"Messages", 'BigInt'>
    readonly sender_id: FieldRef<"Messages", 'BigInt'>
    readonly receiver_id: FieldRef<"Messages", 'BigInt'>
    readonly content: FieldRef<"Messages", 'String'>
    readonly created_at: FieldRef<"Messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Messages findUnique
   */
  export type MessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findUniqueOrThrow
   */
  export type MessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findFirst
   */
  export type MessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findFirstOrThrow
   */
  export type MessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findMany
   */
  export type MessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages create
   */
  export type MessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a Messages.
     */
    data: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
  }

  /**
   * Messages createMany
   */
  export type MessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessagesCreateManyInput | MessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Messages update
   */
  export type MessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a Messages.
     */
    data: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
    /**
     * Choose, which Messages to update.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages updateMany
   */
  export type MessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessagesWhereInput
  }

  /**
   * Messages upsert
   */
  export type MessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the Messages to update in case it exists.
     */
    where: MessagesWhereUniqueInput
    /**
     * In case the Messages found by the `where` argument doesn't exist, create a new Messages with this data.
     */
    create: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
    /**
     * In case the Messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
  }

  /**
   * Messages delete
   */
  export type MessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter which Messages to delete.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages deleteMany
   */
  export type MessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessagesWhereInput
  }

  /**
   * Messages without action
   */
  export type MessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
  }


  /**
   * Model MultiFactorAuth
   */

  export type AggregateMultiFactorAuth = {
    _count: MultiFactorAuthCountAggregateOutputType | null
    _avg: MultiFactorAuthAvgAggregateOutputType | null
    _sum: MultiFactorAuthSumAggregateOutputType | null
    _min: MultiFactorAuthMinAggregateOutputType | null
    _max: MultiFactorAuthMaxAggregateOutputType | null
  }

  export type MultiFactorAuthAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type MultiFactorAuthSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
  }

  export type MultiFactorAuthMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    mfa_type: $Enums.MultiFactorAuth_mfa_type | null
    secret_key: string | null
    is_enabled: boolean | null
    created_at: Date | null
  }

  export type MultiFactorAuthMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    mfa_type: $Enums.MultiFactorAuth_mfa_type | null
    secret_key: string | null
    is_enabled: boolean | null
    created_at: Date | null
  }

  export type MultiFactorAuthCountAggregateOutputType = {
    id: number
    user_id: number
    mfa_type: number
    secret_key: number
    is_enabled: number
    created_at: number
    _all: number
  }


  export type MultiFactorAuthAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type MultiFactorAuthSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type MultiFactorAuthMinAggregateInputType = {
    id?: true
    user_id?: true
    mfa_type?: true
    secret_key?: true
    is_enabled?: true
    created_at?: true
  }

  export type MultiFactorAuthMaxAggregateInputType = {
    id?: true
    user_id?: true
    mfa_type?: true
    secret_key?: true
    is_enabled?: true
    created_at?: true
  }

  export type MultiFactorAuthCountAggregateInputType = {
    id?: true
    user_id?: true
    mfa_type?: true
    secret_key?: true
    is_enabled?: true
    created_at?: true
    _all?: true
  }

  export type MultiFactorAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiFactorAuth to aggregate.
     */
    where?: MultiFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiFactorAuths to fetch.
     */
    orderBy?: MultiFactorAuthOrderByWithRelationInput | MultiFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultiFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultiFactorAuths
    **/
    _count?: true | MultiFactorAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultiFactorAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultiFactorAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultiFactorAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultiFactorAuthMaxAggregateInputType
  }

  export type GetMultiFactorAuthAggregateType<T extends MultiFactorAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateMultiFactorAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultiFactorAuth[P]>
      : GetScalarType<T[P], AggregateMultiFactorAuth[P]>
  }




  export type MultiFactorAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiFactorAuthWhereInput
    orderBy?: MultiFactorAuthOrderByWithAggregationInput | MultiFactorAuthOrderByWithAggregationInput[]
    by: MultiFactorAuthScalarFieldEnum[] | MultiFactorAuthScalarFieldEnum
    having?: MultiFactorAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultiFactorAuthCountAggregateInputType | true
    _avg?: MultiFactorAuthAvgAggregateInputType
    _sum?: MultiFactorAuthSumAggregateInputType
    _min?: MultiFactorAuthMinAggregateInputType
    _max?: MultiFactorAuthMaxAggregateInputType
  }

  export type MultiFactorAuthGroupByOutputType = {
    id: bigint
    user_id: bigint
    mfa_type: $Enums.MultiFactorAuth_mfa_type
    secret_key: string | null
    is_enabled: boolean | null
    created_at: Date | null
    _count: MultiFactorAuthCountAggregateOutputType | null
    _avg: MultiFactorAuthAvgAggregateOutputType | null
    _sum: MultiFactorAuthSumAggregateOutputType | null
    _min: MultiFactorAuthMinAggregateOutputType | null
    _max: MultiFactorAuthMaxAggregateOutputType | null
  }

  type GetMultiFactorAuthGroupByPayload<T extends MultiFactorAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultiFactorAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultiFactorAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultiFactorAuthGroupByOutputType[P]>
            : GetScalarType<T[P], MultiFactorAuthGroupByOutputType[P]>
        }
      >
    >


  export type MultiFactorAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    mfa_type?: boolean
    secret_key?: boolean
    is_enabled?: boolean
    created_at?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiFactorAuth"]>


  export type MultiFactorAuthSelectScalar = {
    id?: boolean
    user_id?: boolean
    mfa_type?: boolean
    secret_key?: boolean
    is_enabled?: boolean
    created_at?: boolean
  }

  export type MultiFactorAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $MultiFactorAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultiFactorAuth"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      mfa_type: $Enums.MultiFactorAuth_mfa_type
      secret_key: string | null
      is_enabled: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["multiFactorAuth"]>
    composites: {}
  }

  type MultiFactorAuthGetPayload<S extends boolean | null | undefined | MultiFactorAuthDefaultArgs> = $Result.GetResult<Prisma.$MultiFactorAuthPayload, S>

  type MultiFactorAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MultiFactorAuthFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MultiFactorAuthCountAggregateInputType | true
    }

  export interface MultiFactorAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultiFactorAuth'], meta: { name: 'MultiFactorAuth' } }
    /**
     * Find zero or one MultiFactorAuth that matches the filter.
     * @param {MultiFactorAuthFindUniqueArgs} args - Arguments to find a MultiFactorAuth
     * @example
     * // Get one MultiFactorAuth
     * const multiFactorAuth = await prisma.multiFactorAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MultiFactorAuthFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MultiFactorAuthFindUniqueArgs<ExtArgs>>
    ): Prisma__MultiFactorAuthClient<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MultiFactorAuth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MultiFactorAuthFindUniqueOrThrowArgs} args - Arguments to find a MultiFactorAuth
     * @example
     * // Get one MultiFactorAuth
     * const multiFactorAuth = await prisma.multiFactorAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MultiFactorAuthFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MultiFactorAuthFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MultiFactorAuthClient<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MultiFactorAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthFindFirstArgs} args - Arguments to find a MultiFactorAuth
     * @example
     * // Get one MultiFactorAuth
     * const multiFactorAuth = await prisma.multiFactorAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MultiFactorAuthFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MultiFactorAuthFindFirstArgs<ExtArgs>>
    ): Prisma__MultiFactorAuthClient<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MultiFactorAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthFindFirstOrThrowArgs} args - Arguments to find a MultiFactorAuth
     * @example
     * // Get one MultiFactorAuth
     * const multiFactorAuth = await prisma.multiFactorAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MultiFactorAuthFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MultiFactorAuthFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MultiFactorAuthClient<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MultiFactorAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultiFactorAuths
     * const multiFactorAuths = await prisma.multiFactorAuth.findMany()
     * 
     * // Get first 10 MultiFactorAuths
     * const multiFactorAuths = await prisma.multiFactorAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multiFactorAuthWithIdOnly = await prisma.multiFactorAuth.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MultiFactorAuthFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MultiFactorAuthFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MultiFactorAuth.
     * @param {MultiFactorAuthCreateArgs} args - Arguments to create a MultiFactorAuth.
     * @example
     * // Create one MultiFactorAuth
     * const MultiFactorAuth = await prisma.multiFactorAuth.create({
     *   data: {
     *     // ... data to create a MultiFactorAuth
     *   }
     * })
     * 
    **/
    create<T extends MultiFactorAuthCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MultiFactorAuthCreateArgs<ExtArgs>>
    ): Prisma__MultiFactorAuthClient<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MultiFactorAuths.
     * @param {MultiFactorAuthCreateManyArgs} args - Arguments to create many MultiFactorAuths.
     * @example
     * // Create many MultiFactorAuths
     * const multiFactorAuth = await prisma.multiFactorAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends MultiFactorAuthCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MultiFactorAuthCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MultiFactorAuth.
     * @param {MultiFactorAuthDeleteArgs} args - Arguments to delete one MultiFactorAuth.
     * @example
     * // Delete one MultiFactorAuth
     * const MultiFactorAuth = await prisma.multiFactorAuth.delete({
     *   where: {
     *     // ... filter to delete one MultiFactorAuth
     *   }
     * })
     * 
    **/
    delete<T extends MultiFactorAuthDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MultiFactorAuthDeleteArgs<ExtArgs>>
    ): Prisma__MultiFactorAuthClient<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MultiFactorAuth.
     * @param {MultiFactorAuthUpdateArgs} args - Arguments to update one MultiFactorAuth.
     * @example
     * // Update one MultiFactorAuth
     * const multiFactorAuth = await prisma.multiFactorAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MultiFactorAuthUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MultiFactorAuthUpdateArgs<ExtArgs>>
    ): Prisma__MultiFactorAuthClient<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MultiFactorAuths.
     * @param {MultiFactorAuthDeleteManyArgs} args - Arguments to filter MultiFactorAuths to delete.
     * @example
     * // Delete a few MultiFactorAuths
     * const { count } = await prisma.multiFactorAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MultiFactorAuthDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MultiFactorAuthDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiFactorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultiFactorAuths
     * const multiFactorAuth = await prisma.multiFactorAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MultiFactorAuthUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MultiFactorAuthUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MultiFactorAuth.
     * @param {MultiFactorAuthUpsertArgs} args - Arguments to update or create a MultiFactorAuth.
     * @example
     * // Update or create a MultiFactorAuth
     * const multiFactorAuth = await prisma.multiFactorAuth.upsert({
     *   create: {
     *     // ... data to create a MultiFactorAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultiFactorAuth we want to update
     *   }
     * })
    **/
    upsert<T extends MultiFactorAuthUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MultiFactorAuthUpsertArgs<ExtArgs>>
    ): Prisma__MultiFactorAuthClient<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MultiFactorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthCountArgs} args - Arguments to filter MultiFactorAuths to count.
     * @example
     * // Count the number of MultiFactorAuths
     * const count = await prisma.multiFactorAuth.count({
     *   where: {
     *     // ... the filter for the MultiFactorAuths we want to count
     *   }
     * })
    **/
    count<T extends MultiFactorAuthCountArgs>(
      args?: Subset<T, MultiFactorAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultiFactorAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultiFactorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultiFactorAuthAggregateArgs>(args: Subset<T, MultiFactorAuthAggregateArgs>): Prisma.PrismaPromise<GetMultiFactorAuthAggregateType<T>>

    /**
     * Group by MultiFactorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultiFactorAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultiFactorAuthGroupByArgs['orderBy'] }
        : { orderBy?: MultiFactorAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultiFactorAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultiFactorAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultiFactorAuth model
   */
  readonly fields: MultiFactorAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultiFactorAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultiFactorAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MultiFactorAuth model
   */ 
  interface MultiFactorAuthFieldRefs {
    readonly id: FieldRef<"MultiFactorAuth", 'BigInt'>
    readonly user_id: FieldRef<"MultiFactorAuth", 'BigInt'>
    readonly mfa_type: FieldRef<"MultiFactorAuth", 'MultiFactorAuth_mfa_type'>
    readonly secret_key: FieldRef<"MultiFactorAuth", 'String'>
    readonly is_enabled: FieldRef<"MultiFactorAuth", 'Boolean'>
    readonly created_at: FieldRef<"MultiFactorAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MultiFactorAuth findUnique
   */
  export type MultiFactorAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuth to fetch.
     */
    where: MultiFactorAuthWhereUniqueInput
  }

  /**
   * MultiFactorAuth findUniqueOrThrow
   */
  export type MultiFactorAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuth to fetch.
     */
    where: MultiFactorAuthWhereUniqueInput
  }

  /**
   * MultiFactorAuth findFirst
   */
  export type MultiFactorAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuth to fetch.
     */
    where?: MultiFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiFactorAuths to fetch.
     */
    orderBy?: MultiFactorAuthOrderByWithRelationInput | MultiFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiFactorAuths.
     */
    cursor?: MultiFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiFactorAuths.
     */
    distinct?: MultiFactorAuthScalarFieldEnum | MultiFactorAuthScalarFieldEnum[]
  }

  /**
   * MultiFactorAuth findFirstOrThrow
   */
  export type MultiFactorAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuth to fetch.
     */
    where?: MultiFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiFactorAuths to fetch.
     */
    orderBy?: MultiFactorAuthOrderByWithRelationInput | MultiFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiFactorAuths.
     */
    cursor?: MultiFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiFactorAuths.
     */
    distinct?: MultiFactorAuthScalarFieldEnum | MultiFactorAuthScalarFieldEnum[]
  }

  /**
   * MultiFactorAuth findMany
   */
  export type MultiFactorAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuths to fetch.
     */
    where?: MultiFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiFactorAuths to fetch.
     */
    orderBy?: MultiFactorAuthOrderByWithRelationInput | MultiFactorAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultiFactorAuths.
     */
    cursor?: MultiFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiFactorAuths.
     */
    skip?: number
    distinct?: MultiFactorAuthScalarFieldEnum | MultiFactorAuthScalarFieldEnum[]
  }

  /**
   * MultiFactorAuth create
   */
  export type MultiFactorAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a MultiFactorAuth.
     */
    data: XOR<MultiFactorAuthCreateInput, MultiFactorAuthUncheckedCreateInput>
  }

  /**
   * MultiFactorAuth createMany
   */
  export type MultiFactorAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultiFactorAuths.
     */
    data: MultiFactorAuthCreateManyInput | MultiFactorAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultiFactorAuth update
   */
  export type MultiFactorAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a MultiFactorAuth.
     */
    data: XOR<MultiFactorAuthUpdateInput, MultiFactorAuthUncheckedUpdateInput>
    /**
     * Choose, which MultiFactorAuth to update.
     */
    where: MultiFactorAuthWhereUniqueInput
  }

  /**
   * MultiFactorAuth updateMany
   */
  export type MultiFactorAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultiFactorAuths.
     */
    data: XOR<MultiFactorAuthUpdateManyMutationInput, MultiFactorAuthUncheckedUpdateManyInput>
    /**
     * Filter which MultiFactorAuths to update
     */
    where?: MultiFactorAuthWhereInput
  }

  /**
   * MultiFactorAuth upsert
   */
  export type MultiFactorAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the MultiFactorAuth to update in case it exists.
     */
    where: MultiFactorAuthWhereUniqueInput
    /**
     * In case the MultiFactorAuth found by the `where` argument doesn't exist, create a new MultiFactorAuth with this data.
     */
    create: XOR<MultiFactorAuthCreateInput, MultiFactorAuthUncheckedCreateInput>
    /**
     * In case the MultiFactorAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultiFactorAuthUpdateInput, MultiFactorAuthUncheckedUpdateInput>
  }

  /**
   * MultiFactorAuth delete
   */
  export type MultiFactorAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    /**
     * Filter which MultiFactorAuth to delete.
     */
    where: MultiFactorAuthWhereUniqueInput
  }

  /**
   * MultiFactorAuth deleteMany
   */
  export type MultiFactorAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiFactorAuths to delete
     */
    where?: MultiFactorAuthWhereInput
  }

  /**
   * MultiFactorAuth without action
   */
  export type MultiFactorAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
  }


  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    message: string | null
    type: $Enums.Notifications_type | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    message: string | null
    type: $Enums.Notifications_type | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    user_id: number
    message: number
    type: number
    is_read: number
    created_at: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    message?: true
    type?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    message?: true
    type?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    message?: true
    type?: true
    is_read?: true
    created_at?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithAggregationInput | NotificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: bigint
    user_id: bigint
    message: string
    type: $Enums.Notifications_type | null
    is_read: boolean | null
    created_at: Date | null
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    message?: boolean
    type?: boolean
    is_read?: boolean
    created_at?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>


  export type NotificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    message?: boolean
    type?: boolean
    is_read?: boolean
    created_at?: boolean
  }

  export type NotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $NotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifications"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      message: string
      type: $Enums.Notifications_type | null
      is_read: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type NotificationsGetPayload<S extends boolean | null | undefined | NotificationsDefaultArgs> = $Result.GetResult<Prisma.$NotificationsPayload, S>

  type NotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface NotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifications'], meta: { name: 'Notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
    **/
    create<T extends NotificationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends NotificationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
    **/
    delete<T extends NotificationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>
    ): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifications model
   */
  readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notifications model
   */ 
  interface NotificationsFieldRefs {
    readonly id: FieldRef<"Notifications", 'BigInt'>
    readonly user_id: FieldRef<"Notifications", 'BigInt'>
    readonly message: FieldRef<"Notifications", 'String'>
    readonly type: FieldRef<"Notifications", 'Notifications_type'>
    readonly is_read: FieldRef<"Notifications", 'Boolean'>
    readonly created_at: FieldRef<"Notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Notifications.
     */
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }

  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
  }

  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }

  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput
  }

  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
  }


  /**
   * Model Payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    course_id: number | null
    subscription_plan_id: number | null
    amount: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    subscription_plan_id: bigint | null
    amount: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    subscription_plan_id: bigint | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.Payments_method | null
    status: $Enums.Payments_status | null
    transaction_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    subscription_plan_id: bigint | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.Payments_method | null
    status: $Enums.Payments_status | null
    transaction_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    user_id: number
    course_id: number
    subscription_plan_id: number
    amount: number
    currency: number
    method: number
    status: number
    transaction_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    subscription_plan_id?: true
    amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    subscription_plan_id?: true
    amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    subscription_plan_id?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    transaction_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    subscription_plan_id?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    transaction_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    subscription_plan_id?: true
    amount?: true
    currency?: true
    method?: true
    status?: true
    transaction_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to aggregate.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type PaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithAggregationInput | PaymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: PaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: bigint
    user_id: bigint
    course_id: bigint | null
    subscription_plan_id: bigint | null
    amount: Decimal
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends PaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    subscription_plan_id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    Courses?: boolean | Payments$CoursesArgs<ExtArgs>
    SubscriptionPlans?: boolean | Payments$SubscriptionPlansArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>


  export type PaymentsSelectScalar = {
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    subscription_plan_id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | Payments$CoursesArgs<ExtArgs>
    SubscriptionPlans?: boolean | Payments$SubscriptionPlansArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $PaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payments"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs> | null
      SubscriptionPlans: Prisma.$SubscriptionPlansPayload<ExtArgs> | null
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      course_id: bigint | null
      subscription_plan_id: bigint | null
      amount: Prisma.Decimal
      currency: string
      method: $Enums.Payments_method
      status: $Enums.Payments_status
      transaction_id: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type PaymentsGetPayload<S extends boolean | null | undefined | PaymentsDefaultArgs> = $Result.GetResult<Prisma.$PaymentsPayload, S>

  type PaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface PaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payments'], meta: { name: 'Payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {PaymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentsFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentsFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Payments.
     * @param {PaymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
    **/
    create<T extends PaymentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentsCreateArgs<ExtArgs>>
    ): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PaymentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payments.
     * @param {PaymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
    **/
    delete<T extends PaymentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentsDeleteArgs<ExtArgs>>
    ): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Payments.
     * @param {PaymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentsUpdateArgs<ExtArgs>>
    ): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payments.
     * @param {PaymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentsUpsertArgs<ExtArgs>>
    ): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentsCountArgs>(
      args?: Subset<T, PaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payments model
   */
  readonly fields: PaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends Payments$CoursesArgs<ExtArgs> = {}>(args?: Subset<T, Payments$CoursesArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    SubscriptionPlans<T extends Payments$SubscriptionPlansArgs<ExtArgs> = {}>(args?: Subset<T, Payments$SubscriptionPlansArgs<ExtArgs>>): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Payments model
   */ 
  interface PaymentsFieldRefs {
    readonly id: FieldRef<"Payments", 'BigInt'>
    readonly user_id: FieldRef<"Payments", 'BigInt'>
    readonly course_id: FieldRef<"Payments", 'BigInt'>
    readonly subscription_plan_id: FieldRef<"Payments", 'BigInt'>
    readonly amount: FieldRef<"Payments", 'Decimal'>
    readonly currency: FieldRef<"Payments", 'String'>
    readonly method: FieldRef<"Payments", 'Payments_method'>
    readonly status: FieldRef<"Payments", 'Payments_status'>
    readonly transaction_id: FieldRef<"Payments", 'String'>
    readonly created_at: FieldRef<"Payments", 'DateTime'>
    readonly updated_at: FieldRef<"Payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payments findUnique
   */
  export type PaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findUniqueOrThrow
   */
  export type PaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findFirst
   */
  export type PaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findFirstOrThrow
   */
  export type PaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findMany
   */
  export type PaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments create
   */
  export type PaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Payments.
     */
    data: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
  }

  /**
   * Payments createMany
   */
  export type PaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payments update
   */
  export type PaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Payments.
     */
    data: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
    /**
     * Choose, which Payments to update.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments updateMany
   */
  export type PaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
  }

  /**
   * Payments upsert
   */
  export type PaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Payments to update in case it exists.
     */
    where: PaymentsWhereUniqueInput
    /**
     * In case the Payments found by the `where` argument doesn't exist, create a new Payments with this data.
     */
    create: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
    /**
     * In case the Payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
  }

  /**
   * Payments delete
   */
  export type PaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter which Payments to delete.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments deleteMany
   */
  export type PaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentsWhereInput
  }

  /**
   * Payments.Courses
   */
  export type Payments$CoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    where?: CoursesWhereInput
  }

  /**
   * Payments.SubscriptionPlans
   */
  export type Payments$SubscriptionPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    where?: SubscriptionPlansWhereInput
  }

  /**
   * Payments without action
   */
  export type PaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
  }


  /**
   * Model QuizAttempts
   */

  export type AggregateQuizAttempts = {
    _count: QuizAttemptsCountAggregateOutputType | null
    _avg: QuizAttemptsAvgAggregateOutputType | null
    _sum: QuizAttemptsSumAggregateOutputType | null
    _min: QuizAttemptsMinAggregateOutputType | null
    _max: QuizAttemptsMaxAggregateOutputType | null
  }

  export type QuizAttemptsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    assessment_id: number | null
    score: number | null
  }

  export type QuizAttemptsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    assessment_id: bigint | null
    score: number | null
  }

  export type QuizAttemptsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    assessment_id: bigint | null
    score: number | null
    started_at: Date | null
    completed_at: Date | null
  }

  export type QuizAttemptsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    assessment_id: bigint | null
    score: number | null
    started_at: Date | null
    completed_at: Date | null
  }

  export type QuizAttemptsCountAggregateOutputType = {
    id: number
    user_id: number
    assessment_id: number
    score: number
    started_at: number
    completed_at: number
    _all: number
  }


  export type QuizAttemptsAvgAggregateInputType = {
    id?: true
    user_id?: true
    assessment_id?: true
    score?: true
  }

  export type QuizAttemptsSumAggregateInputType = {
    id?: true
    user_id?: true
    assessment_id?: true
    score?: true
  }

  export type QuizAttemptsMinAggregateInputType = {
    id?: true
    user_id?: true
    assessment_id?: true
    score?: true
    started_at?: true
    completed_at?: true
  }

  export type QuizAttemptsMaxAggregateInputType = {
    id?: true
    user_id?: true
    assessment_id?: true
    score?: true
    started_at?: true
    completed_at?: true
  }

  export type QuizAttemptsCountAggregateInputType = {
    id?: true
    user_id?: true
    assessment_id?: true
    score?: true
    started_at?: true
    completed_at?: true
    _all?: true
  }

  export type QuizAttemptsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempts to aggregate.
     */
    where?: QuizAttemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptsOrderByWithRelationInput | QuizAttemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAttemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAttempts
    **/
    _count?: true | QuizAttemptsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAttemptsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAttemptsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAttemptsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAttemptsMaxAggregateInputType
  }

  export type GetQuizAttemptsAggregateType<T extends QuizAttemptsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAttempts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAttempts[P]>
      : GetScalarType<T[P], AggregateQuizAttempts[P]>
  }




  export type QuizAttemptsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptsWhereInput
    orderBy?: QuizAttemptsOrderByWithAggregationInput | QuizAttemptsOrderByWithAggregationInput[]
    by: QuizAttemptsScalarFieldEnum[] | QuizAttemptsScalarFieldEnum
    having?: QuizAttemptsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAttemptsCountAggregateInputType | true
    _avg?: QuizAttemptsAvgAggregateInputType
    _sum?: QuizAttemptsSumAggregateInputType
    _min?: QuizAttemptsMinAggregateInputType
    _max?: QuizAttemptsMaxAggregateInputType
  }

  export type QuizAttemptsGroupByOutputType = {
    id: bigint
    user_id: bigint
    assessment_id: bigint
    score: number | null
    started_at: Date | null
    completed_at: Date | null
    _count: QuizAttemptsCountAggregateOutputType | null
    _avg: QuizAttemptsAvgAggregateOutputType | null
    _sum: QuizAttemptsSumAggregateOutputType | null
    _min: QuizAttemptsMinAggregateOutputType | null
    _max: QuizAttemptsMaxAggregateOutputType | null
  }

  type GetQuizAttemptsGroupByPayload<T extends QuizAttemptsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAttemptsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAttemptsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAttemptsGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAttemptsGroupByOutputType[P]>
        }
      >
    >


  export type QuizAttemptsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    assessment_id?: boolean
    score?: boolean
    started_at?: boolean
    completed_at?: boolean
    Assessments?: boolean | AssessmentsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    UserAnswers?: boolean | QuizAttempts$UserAnswersArgs<ExtArgs>
    _count?: boolean | QuizAttemptsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempts"]>


  export type QuizAttemptsSelectScalar = {
    id?: boolean
    user_id?: boolean
    assessment_id?: boolean
    score?: boolean
    started_at?: boolean
    completed_at?: boolean
  }

  export type QuizAttemptsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Assessments?: boolean | AssessmentsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    UserAnswers?: boolean | QuizAttempts$UserAnswersArgs<ExtArgs>
    _count?: boolean | QuizAttemptsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QuizAttemptsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAttempts"
    objects: {
      Assessments: Prisma.$AssessmentsPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
      UserAnswers: Prisma.$UserAnswersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      assessment_id: bigint
      score: number | null
      started_at: Date | null
      completed_at: Date | null
    }, ExtArgs["result"]["quizAttempts"]>
    composites: {}
  }

  type QuizAttemptsGetPayload<S extends boolean | null | undefined | QuizAttemptsDefaultArgs> = $Result.GetResult<Prisma.$QuizAttemptsPayload, S>

  type QuizAttemptsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizAttemptsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizAttemptsCountAggregateInputType | true
    }

  export interface QuizAttemptsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAttempts'], meta: { name: 'QuizAttempts' } }
    /**
     * Find zero or one QuizAttempts that matches the filter.
     * @param {QuizAttemptsFindUniqueArgs} args - Arguments to find a QuizAttempts
     * @example
     * // Get one QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizAttemptsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuizAttemptsFindUniqueArgs<ExtArgs>>
    ): Prisma__QuizAttemptsClient<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one QuizAttempts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizAttemptsFindUniqueOrThrowArgs} args - Arguments to find a QuizAttempts
     * @example
     * // Get one QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizAttemptsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuizAttemptsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuizAttemptsClient<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first QuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptsFindFirstArgs} args - Arguments to find a QuizAttempts
     * @example
     * // Get one QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizAttemptsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuizAttemptsFindFirstArgs<ExtArgs>>
    ): Prisma__QuizAttemptsClient<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first QuizAttempts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptsFindFirstOrThrowArgs} args - Arguments to find a QuizAttempts
     * @example
     * // Get one QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizAttemptsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuizAttemptsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuizAttemptsClient<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more QuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.findMany()
     * 
     * // Get first 10 QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAttemptsWithIdOnly = await prisma.quizAttempts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizAttemptsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuizAttemptsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a QuizAttempts.
     * @param {QuizAttemptsCreateArgs} args - Arguments to create a QuizAttempts.
     * @example
     * // Create one QuizAttempts
     * const QuizAttempts = await prisma.quizAttempts.create({
     *   data: {
     *     // ... data to create a QuizAttempts
     *   }
     * })
     * 
    **/
    create<T extends QuizAttemptsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuizAttemptsCreateArgs<ExtArgs>>
    ): Prisma__QuizAttemptsClient<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many QuizAttempts.
     * @param {QuizAttemptsCreateManyArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends QuizAttemptsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuizAttemptsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizAttempts.
     * @param {QuizAttemptsDeleteArgs} args - Arguments to delete one QuizAttempts.
     * @example
     * // Delete one QuizAttempts
     * const QuizAttempts = await prisma.quizAttempts.delete({
     *   where: {
     *     // ... filter to delete one QuizAttempts
     *   }
     * })
     * 
    **/
    delete<T extends QuizAttemptsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuizAttemptsDeleteArgs<ExtArgs>>
    ): Prisma__QuizAttemptsClient<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one QuizAttempts.
     * @param {QuizAttemptsUpdateArgs} args - Arguments to update one QuizAttempts.
     * @example
     * // Update one QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizAttemptsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuizAttemptsUpdateArgs<ExtArgs>>
    ): Prisma__QuizAttemptsClient<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more QuizAttempts.
     * @param {QuizAttemptsDeleteManyArgs} args - Arguments to filter QuizAttempts to delete.
     * @example
     * // Delete a few QuizAttempts
     * const { count } = await prisma.quizAttempts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizAttemptsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuizAttemptsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizAttemptsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuizAttemptsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizAttempts.
     * @param {QuizAttemptsUpsertArgs} args - Arguments to update or create a QuizAttempts.
     * @example
     * // Update or create a QuizAttempts
     * const quizAttempts = await prisma.quizAttempts.upsert({
     *   create: {
     *     // ... data to create a QuizAttempts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAttempts we want to update
     *   }
     * })
    **/
    upsert<T extends QuizAttemptsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuizAttemptsUpsertArgs<ExtArgs>>
    ): Prisma__QuizAttemptsClient<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptsCountArgs} args - Arguments to filter QuizAttempts to count.
     * @example
     * // Count the number of QuizAttempts
     * const count = await prisma.quizAttempts.count({
     *   where: {
     *     // ... the filter for the QuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuizAttemptsCountArgs>(
      args?: Subset<T, QuizAttemptsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAttemptsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAttemptsAggregateArgs>(args: Subset<T, QuizAttemptsAggregateArgs>): Prisma.PrismaPromise<GetQuizAttemptsAggregateType<T>>

    /**
     * Group by QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAttemptsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAttemptsGroupByArgs['orderBy'] }
        : { orderBy?: QuizAttemptsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAttemptsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAttemptsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAttempts model
   */
  readonly fields: QuizAttemptsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAttempts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAttemptsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Assessments<T extends AssessmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentsDefaultArgs<ExtArgs>>): Prisma__AssessmentsClient<$Result.GetResult<Prisma.$AssessmentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    UserAnswers<T extends QuizAttempts$UserAnswersArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttempts$UserAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the QuizAttempts model
   */ 
  interface QuizAttemptsFieldRefs {
    readonly id: FieldRef<"QuizAttempts", 'BigInt'>
    readonly user_id: FieldRef<"QuizAttempts", 'BigInt'>
    readonly assessment_id: FieldRef<"QuizAttempts", 'BigInt'>
    readonly score: FieldRef<"QuizAttempts", 'Int'>
    readonly started_at: FieldRef<"QuizAttempts", 'DateTime'>
    readonly completed_at: FieldRef<"QuizAttempts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizAttempts findUnique
   */
  export type QuizAttemptsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where: QuizAttemptsWhereUniqueInput
  }

  /**
   * QuizAttempts findUniqueOrThrow
   */
  export type QuizAttemptsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where: QuizAttemptsWhereUniqueInput
  }

  /**
   * QuizAttempts findFirst
   */
  export type QuizAttemptsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptsOrderByWithRelationInput | QuizAttemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptsScalarFieldEnum | QuizAttemptsScalarFieldEnum[]
  }

  /**
   * QuizAttempts findFirstOrThrow
   */
  export type QuizAttemptsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptsOrderByWithRelationInput | QuizAttemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptsScalarFieldEnum | QuizAttemptsScalarFieldEnum[]
  }

  /**
   * QuizAttempts findMany
   */
  export type QuizAttemptsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptsOrderByWithRelationInput | QuizAttemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAttempts.
     */
    cursor?: QuizAttemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    distinct?: QuizAttemptsScalarFieldEnum | QuizAttemptsScalarFieldEnum[]
  }

  /**
   * QuizAttempts create
   */
  export type QuizAttemptsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAttempts.
     */
    data: XOR<QuizAttemptsCreateInput, QuizAttemptsUncheckedCreateInput>
  }

  /**
   * QuizAttempts createMany
   */
  export type QuizAttemptsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptsCreateManyInput | QuizAttemptsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAttempts update
   */
  export type QuizAttemptsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAttempts.
     */
    data: XOR<QuizAttemptsUpdateInput, QuizAttemptsUncheckedUpdateInput>
    /**
     * Choose, which QuizAttempts to update.
     */
    where: QuizAttemptsWhereUniqueInput
  }

  /**
   * QuizAttempts updateMany
   */
  export type QuizAttemptsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptsUpdateManyMutationInput, QuizAttemptsUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptsWhereInput
  }

  /**
   * QuizAttempts upsert
   */
  export type QuizAttemptsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAttempts to update in case it exists.
     */
    where: QuizAttemptsWhereUniqueInput
    /**
     * In case the QuizAttempts found by the `where` argument doesn't exist, create a new QuizAttempts with this data.
     */
    create: XOR<QuizAttemptsCreateInput, QuizAttemptsUncheckedCreateInput>
    /**
     * In case the QuizAttempts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAttemptsUpdateInput, QuizAttemptsUncheckedUpdateInput>
  }

  /**
   * QuizAttempts delete
   */
  export type QuizAttemptsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    /**
     * Filter which QuizAttempts to delete.
     */
    where: QuizAttemptsWhereUniqueInput
  }

  /**
   * QuizAttempts deleteMany
   */
  export type QuizAttemptsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempts to delete
     */
    where?: QuizAttemptsWhereInput
  }

  /**
   * QuizAttempts.UserAnswers
   */
  export type QuizAttempts$UserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    where?: UserAnswersWhereInput
    orderBy?: UserAnswersOrderByWithRelationInput | UserAnswersOrderByWithRelationInput[]
    cursor?: UserAnswersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAnswersScalarFieldEnum | UserAnswersScalarFieldEnum[]
  }

  /**
   * QuizAttempts without action
   */
  export type QuizAttemptsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
  }


  /**
   * Model Reviews
   */

  export type AggregateReviews = {
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    course_id: number | null
    instructor_id: number | null
    rating: number | null
  }

  export type ReviewsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    instructor_id: bigint | null
    rating: number | null
  }

  export type ReviewsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    instructor_id: bigint | null
    rating: number | null
    review_text: string | null
    created_at: Date | null
  }

  export type ReviewsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    instructor_id: bigint | null
    rating: number | null
    review_text: string | null
    created_at: Date | null
  }

  export type ReviewsCountAggregateOutputType = {
    id: number
    user_id: number
    course_id: number
    instructor_id: number
    rating: number
    review_text: number
    created_at: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    instructor_id?: true
    rating?: true
  }

  export type ReviewsSumAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    instructor_id?: true
    rating?: true
  }

  export type ReviewsMinAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    instructor_id?: true
    rating?: true
    review_text?: true
    created_at?: true
  }

  export type ReviewsMaxAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    instructor_id?: true
    rating?: true
    review_text?: true
    created_at?: true
  }

  export type ReviewsCountAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    instructor_id?: true
    rating?: true
    review_text?: true
    created_at?: true
    _all?: true
  }

  export type ReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to aggregate.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends ReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews[P]>
      : GetScalarType<T[P], AggregateReviews[P]>
  }




  export type ReviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewsWhereInput
    orderBy?: ReviewsOrderByWithAggregationInput | ReviewsOrderByWithAggregationInput[]
    by: ReviewsScalarFieldEnum[] | ReviewsScalarFieldEnum
    having?: ReviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCountAggregateInputType | true
    _avg?: ReviewsAvgAggregateInputType
    _sum?: ReviewsSumAggregateInputType
    _min?: ReviewsMinAggregateInputType
    _max?: ReviewsMaxAggregateInputType
  }

  export type ReviewsGroupByOutputType = {
    id: bigint
    user_id: bigint
    course_id: bigint | null
    instructor_id: bigint | null
    rating: number
    review_text: string | null
    created_at: Date | null
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  type GetReviewsGroupByPayload<T extends ReviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
        }
      >
    >


  export type ReviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    instructor_id?: boolean
    rating?: boolean
    review_text?: boolean
    created_at?: boolean
    Courses?: boolean | Reviews$CoursesArgs<ExtArgs>
    Users_Reviews_instructor_idToUsers?: boolean | Reviews$Users_Reviews_instructor_idToUsersArgs<ExtArgs>
    Users_Reviews_user_idToUsers?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>


  export type ReviewsSelectScalar = {
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    instructor_id?: boolean
    rating?: boolean
    review_text?: boolean
    created_at?: boolean
  }

  export type ReviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | Reviews$CoursesArgs<ExtArgs>
    Users_Reviews_instructor_idToUsers?: boolean | Reviews$Users_Reviews_instructor_idToUsersArgs<ExtArgs>
    Users_Reviews_user_idToUsers?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ReviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reviews"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs> | null
      Users_Reviews_instructor_idToUsers: Prisma.$UsersPayload<ExtArgs> | null
      Users_Reviews_user_idToUsers: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      course_id: bigint | null
      instructor_id: bigint | null
      rating: number
      review_text: string | null
      created_at: Date | null
    }, ExtArgs["result"]["reviews"]>
    composites: {}
  }

  type ReviewsGetPayload<S extends boolean | null | undefined | ReviewsDefaultArgs> = $Result.GetResult<Prisma.$ReviewsPayload, S>

  type ReviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewsCountAggregateInputType | true
    }

  export interface ReviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reviews'], meta: { name: 'Reviews' } }
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {ReviewsFindUniqueArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewsFindUniqueArgs<ExtArgs>>
    ): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Reviews that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewsFindUniqueOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReviewsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsFindFirstArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewsFindFirstArgs<ExtArgs>>
    ): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsFindFirstOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReviewsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsWithIdOnly = await prisma.reviews.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReviewsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Reviews.
     * @param {ReviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
    **/
    create<T extends ReviewsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewsCreateArgs<ExtArgs>>
    ): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewsCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ReviewsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reviews.
     * @param {ReviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
    **/
    delete<T extends ReviewsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewsDeleteArgs<ExtArgs>>
    ): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Reviews.
     * @param {ReviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewsUpdateArgs<ExtArgs>>
    ): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reviews.
     * @param {ReviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewsUpsertArgs<ExtArgs>>
    ): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.reviews.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewsCountArgs>(
      args?: Subset<T, ReviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsAggregateArgs>(args: Subset<T, ReviewsAggregateArgs>): Prisma.PrismaPromise<GetReviewsAggregateType<T>>

    /**
     * Group by Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewsGroupByArgs['orderBy'] }
        : { orderBy?: ReviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reviews model
   */
  readonly fields: ReviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends Reviews$CoursesArgs<ExtArgs> = {}>(args?: Subset<T, Reviews$CoursesArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Users_Reviews_instructor_idToUsers<T extends Reviews$Users_Reviews_instructor_idToUsersArgs<ExtArgs> = {}>(args?: Subset<T, Reviews$Users_Reviews_instructor_idToUsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Users_Reviews_user_idToUsers<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Reviews model
   */ 
  interface ReviewsFieldRefs {
    readonly id: FieldRef<"Reviews", 'BigInt'>
    readonly user_id: FieldRef<"Reviews", 'BigInt'>
    readonly course_id: FieldRef<"Reviews", 'BigInt'>
    readonly instructor_id: FieldRef<"Reviews", 'BigInt'>
    readonly rating: FieldRef<"Reviews", 'Int'>
    readonly review_text: FieldRef<"Reviews", 'String'>
    readonly created_at: FieldRef<"Reviews", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reviews findUnique
   */
  export type ReviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews findUniqueOrThrow
   */
  export type ReviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews findFirst
   */
  export type ReviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Reviews findFirstOrThrow
   */
  export type ReviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Reviews findMany
   */
  export type ReviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Reviews create
   */
  export type ReviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a Reviews.
     */
    data: XOR<ReviewsCreateInput, ReviewsUncheckedCreateInput>
  }

  /**
   * Reviews createMany
   */
  export type ReviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewsCreateManyInput | ReviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reviews update
   */
  export type ReviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a Reviews.
     */
    data: XOR<ReviewsUpdateInput, ReviewsUncheckedUpdateInput>
    /**
     * Choose, which Reviews to update.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews updateMany
   */
  export type ReviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewsWhereInput
  }

  /**
   * Reviews upsert
   */
  export type ReviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the Reviews to update in case it exists.
     */
    where: ReviewsWhereUniqueInput
    /**
     * In case the Reviews found by the `where` argument doesn't exist, create a new Reviews with this data.
     */
    create: XOR<ReviewsCreateInput, ReviewsUncheckedCreateInput>
    /**
     * In case the Reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewsUpdateInput, ReviewsUncheckedUpdateInput>
  }

  /**
   * Reviews delete
   */
  export type ReviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter which Reviews to delete.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews deleteMany
   */
  export type ReviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewsWhereInput
  }

  /**
   * Reviews.Courses
   */
  export type Reviews$CoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    where?: CoursesWhereInput
  }

  /**
   * Reviews.Users_Reviews_instructor_idToUsers
   */
  export type Reviews$Users_Reviews_instructor_idToUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Reviews without action
   */
  export type ReviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
  }


  /**
   * Model ShoppingCart
   */

  export type AggregateShoppingCart = {
    _count: ShoppingCartCountAggregateOutputType | null
    _avg: ShoppingCartAvgAggregateOutputType | null
    _sum: ShoppingCartSumAggregateOutputType | null
    _min: ShoppingCartMinAggregateOutputType | null
    _max: ShoppingCartMaxAggregateOutputType | null
  }

  export type ShoppingCartAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    course_id: number | null
  }

  export type ShoppingCartSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
  }

  export type ShoppingCartMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    added_at: Date | null
  }

  export type ShoppingCartMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    added_at: Date | null
  }

  export type ShoppingCartCountAggregateOutputType = {
    id: number
    user_id: number
    course_id: number
    added_at: number
    _all: number
  }


  export type ShoppingCartAvgAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type ShoppingCartSumAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type ShoppingCartMinAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    added_at?: true
  }

  export type ShoppingCartMaxAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    added_at?: true
  }

  export type ShoppingCartCountAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    added_at?: true
    _all?: true
  }

  export type ShoppingCartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShoppingCart to aggregate.
     */
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     */
    orderBy?: ShoppingCartOrderByWithRelationInput | ShoppingCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShoppingCarts
    **/
    _count?: true | ShoppingCartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShoppingCartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShoppingCartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShoppingCartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShoppingCartMaxAggregateInputType
  }

  export type GetShoppingCartAggregateType<T extends ShoppingCartAggregateArgs> = {
        [P in keyof T & keyof AggregateShoppingCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShoppingCart[P]>
      : GetScalarType<T[P], AggregateShoppingCart[P]>
  }




  export type ShoppingCartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShoppingCartWhereInput
    orderBy?: ShoppingCartOrderByWithAggregationInput | ShoppingCartOrderByWithAggregationInput[]
    by: ShoppingCartScalarFieldEnum[] | ShoppingCartScalarFieldEnum
    having?: ShoppingCartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShoppingCartCountAggregateInputType | true
    _avg?: ShoppingCartAvgAggregateInputType
    _sum?: ShoppingCartSumAggregateInputType
    _min?: ShoppingCartMinAggregateInputType
    _max?: ShoppingCartMaxAggregateInputType
  }

  export type ShoppingCartGroupByOutputType = {
    id: bigint
    user_id: bigint
    course_id: bigint
    added_at: Date | null
    _count: ShoppingCartCountAggregateOutputType | null
    _avg: ShoppingCartAvgAggregateOutputType | null
    _sum: ShoppingCartSumAggregateOutputType | null
    _min: ShoppingCartMinAggregateOutputType | null
    _max: ShoppingCartMaxAggregateOutputType | null
  }

  type GetShoppingCartGroupByPayload<T extends ShoppingCartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShoppingCartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShoppingCartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShoppingCartGroupByOutputType[P]>
            : GetScalarType<T[P], ShoppingCartGroupByOutputType[P]>
        }
      >
    >


  export type ShoppingCartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    added_at?: boolean
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shoppingCart"]>


  export type ShoppingCartSelectScalar = {
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    added_at?: boolean
  }

  export type ShoppingCartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ShoppingCartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShoppingCart"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      course_id: bigint
      added_at: Date | null
    }, ExtArgs["result"]["shoppingCart"]>
    composites: {}
  }

  type ShoppingCartGetPayload<S extends boolean | null | undefined | ShoppingCartDefaultArgs> = $Result.GetResult<Prisma.$ShoppingCartPayload, S>

  type ShoppingCartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShoppingCartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShoppingCartCountAggregateInputType | true
    }

  export interface ShoppingCartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShoppingCart'], meta: { name: 'ShoppingCart' } }
    /**
     * Find zero or one ShoppingCart that matches the filter.
     * @param {ShoppingCartFindUniqueArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShoppingCartFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShoppingCartFindUniqueArgs<ExtArgs>>
    ): Prisma__ShoppingCartClient<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShoppingCart that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShoppingCartFindUniqueOrThrowArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShoppingCartFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoppingCartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShoppingCartClient<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShoppingCart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindFirstArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShoppingCartFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoppingCartFindFirstArgs<ExtArgs>>
    ): Prisma__ShoppingCartClient<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShoppingCart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindFirstOrThrowArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShoppingCartFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoppingCartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShoppingCartClient<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShoppingCarts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShoppingCarts
     * const shoppingCarts = await prisma.shoppingCart.findMany()
     * 
     * // Get first 10 ShoppingCarts
     * const shoppingCarts = await prisma.shoppingCart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shoppingCartWithIdOnly = await prisma.shoppingCart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShoppingCartFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoppingCartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShoppingCart.
     * @param {ShoppingCartCreateArgs} args - Arguments to create a ShoppingCart.
     * @example
     * // Create one ShoppingCart
     * const ShoppingCart = await prisma.shoppingCart.create({
     *   data: {
     *     // ... data to create a ShoppingCart
     *   }
     * })
     * 
    **/
    create<T extends ShoppingCartCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShoppingCartCreateArgs<ExtArgs>>
    ): Prisma__ShoppingCartClient<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShoppingCarts.
     * @param {ShoppingCartCreateManyArgs} args - Arguments to create many ShoppingCarts.
     * @example
     * // Create many ShoppingCarts
     * const shoppingCart = await prisma.shoppingCart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ShoppingCartCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoppingCartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShoppingCart.
     * @param {ShoppingCartDeleteArgs} args - Arguments to delete one ShoppingCart.
     * @example
     * // Delete one ShoppingCart
     * const ShoppingCart = await prisma.shoppingCart.delete({
     *   where: {
     *     // ... filter to delete one ShoppingCart
     *   }
     * })
     * 
    **/
    delete<T extends ShoppingCartDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShoppingCartDeleteArgs<ExtArgs>>
    ): Prisma__ShoppingCartClient<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShoppingCart.
     * @param {ShoppingCartUpdateArgs} args - Arguments to update one ShoppingCart.
     * @example
     * // Update one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShoppingCartUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShoppingCartUpdateArgs<ExtArgs>>
    ): Prisma__ShoppingCartClient<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShoppingCarts.
     * @param {ShoppingCartDeleteManyArgs} args - Arguments to filter ShoppingCarts to delete.
     * @example
     * // Delete a few ShoppingCarts
     * const { count } = await prisma.shoppingCart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShoppingCartDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoppingCartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoppingCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShoppingCarts
     * const shoppingCart = await prisma.shoppingCart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShoppingCartUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShoppingCartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShoppingCart.
     * @param {ShoppingCartUpsertArgs} args - Arguments to update or create a ShoppingCart.
     * @example
     * // Update or create a ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.upsert({
     *   create: {
     *     // ... data to create a ShoppingCart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShoppingCart we want to update
     *   }
     * })
    **/
    upsert<T extends ShoppingCartUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShoppingCartUpsertArgs<ExtArgs>>
    ): Prisma__ShoppingCartClient<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShoppingCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartCountArgs} args - Arguments to filter ShoppingCarts to count.
     * @example
     * // Count the number of ShoppingCarts
     * const count = await prisma.shoppingCart.count({
     *   where: {
     *     // ... the filter for the ShoppingCarts we want to count
     *   }
     * })
    **/
    count<T extends ShoppingCartCountArgs>(
      args?: Subset<T, ShoppingCartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoppingCartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShoppingCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoppingCartAggregateArgs>(args: Subset<T, ShoppingCartAggregateArgs>): Prisma.PrismaPromise<GetShoppingCartAggregateType<T>>

    /**
     * Group by ShoppingCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShoppingCartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShoppingCartGroupByArgs['orderBy'] }
        : { orderBy?: ShoppingCartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShoppingCartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShoppingCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShoppingCart model
   */
  readonly fields: ShoppingCartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShoppingCart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShoppingCartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShoppingCart model
   */ 
  interface ShoppingCartFieldRefs {
    readonly id: FieldRef<"ShoppingCart", 'BigInt'>
    readonly user_id: FieldRef<"ShoppingCart", 'BigInt'>
    readonly course_id: FieldRef<"ShoppingCart", 'BigInt'>
    readonly added_at: FieldRef<"ShoppingCart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShoppingCart findUnique
   */
  export type ShoppingCartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingCart to fetch.
     */
    where: ShoppingCartWhereUniqueInput
  }

  /**
   * ShoppingCart findUniqueOrThrow
   */
  export type ShoppingCartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingCart to fetch.
     */
    where: ShoppingCartWhereUniqueInput
  }

  /**
   * ShoppingCart findFirst
   */
  export type ShoppingCartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingCart to fetch.
     */
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     */
    orderBy?: ShoppingCartOrderByWithRelationInput | ShoppingCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingCarts.
     */
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingCarts.
     */
    distinct?: ShoppingCartScalarFieldEnum | ShoppingCartScalarFieldEnum[]
  }

  /**
   * ShoppingCart findFirstOrThrow
   */
  export type ShoppingCartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingCart to fetch.
     */
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     */
    orderBy?: ShoppingCartOrderByWithRelationInput | ShoppingCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingCarts.
     */
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingCarts.
     */
    distinct?: ShoppingCartScalarFieldEnum | ShoppingCartScalarFieldEnum[]
  }

  /**
   * ShoppingCart findMany
   */
  export type ShoppingCartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingCarts to fetch.
     */
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     */
    orderBy?: ShoppingCartOrderByWithRelationInput | ShoppingCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShoppingCarts.
     */
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     */
    skip?: number
    distinct?: ShoppingCartScalarFieldEnum | ShoppingCartScalarFieldEnum[]
  }

  /**
   * ShoppingCart create
   */
  export type ShoppingCartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    /**
     * The data needed to create a ShoppingCart.
     */
    data: XOR<ShoppingCartCreateInput, ShoppingCartUncheckedCreateInput>
  }

  /**
   * ShoppingCart createMany
   */
  export type ShoppingCartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShoppingCarts.
     */
    data: ShoppingCartCreateManyInput | ShoppingCartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShoppingCart update
   */
  export type ShoppingCartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    /**
     * The data needed to update a ShoppingCart.
     */
    data: XOR<ShoppingCartUpdateInput, ShoppingCartUncheckedUpdateInput>
    /**
     * Choose, which ShoppingCart to update.
     */
    where: ShoppingCartWhereUniqueInput
  }

  /**
   * ShoppingCart updateMany
   */
  export type ShoppingCartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShoppingCarts.
     */
    data: XOR<ShoppingCartUpdateManyMutationInput, ShoppingCartUncheckedUpdateManyInput>
    /**
     * Filter which ShoppingCarts to update
     */
    where?: ShoppingCartWhereInput
  }

  /**
   * ShoppingCart upsert
   */
  export type ShoppingCartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    /**
     * The filter to search for the ShoppingCart to update in case it exists.
     */
    where: ShoppingCartWhereUniqueInput
    /**
     * In case the ShoppingCart found by the `where` argument doesn't exist, create a new ShoppingCart with this data.
     */
    create: XOR<ShoppingCartCreateInput, ShoppingCartUncheckedCreateInput>
    /**
     * In case the ShoppingCart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShoppingCartUpdateInput, ShoppingCartUncheckedUpdateInput>
  }

  /**
   * ShoppingCart delete
   */
  export type ShoppingCartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    /**
     * Filter which ShoppingCart to delete.
     */
    where: ShoppingCartWhereUniqueInput
  }

  /**
   * ShoppingCart deleteMany
   */
  export type ShoppingCartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShoppingCarts to delete
     */
    where?: ShoppingCartWhereInput
  }

  /**
   * ShoppingCart without action
   */
  export type ShoppingCartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlans
   */

  export type AggregateSubscriptionPlans = {
    _count: SubscriptionPlansCountAggregateOutputType | null
    _avg: SubscriptionPlansAvgAggregateOutputType | null
    _sum: SubscriptionPlansSumAggregateOutputType | null
    _min: SubscriptionPlansMinAggregateOutputType | null
    _max: SubscriptionPlansMaxAggregateOutputType | null
  }

  export type SubscriptionPlansAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    duration_days: number | null
  }

  export type SubscriptionPlansSumAggregateOutputType = {
    id: bigint | null
    price: Decimal | null
    duration_days: number | null
  }

  export type SubscriptionPlansMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    price: Decimal | null
    duration_days: number | null
    description: string | null
  }

  export type SubscriptionPlansMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    price: Decimal | null
    duration_days: number | null
    description: string | null
  }

  export type SubscriptionPlansCountAggregateOutputType = {
    id: number
    name: number
    price: number
    duration_days: number
    description: number
    _all: number
  }


  export type SubscriptionPlansAvgAggregateInputType = {
    id?: true
    price?: true
    duration_days?: true
  }

  export type SubscriptionPlansSumAggregateInputType = {
    id?: true
    price?: true
    duration_days?: true
  }

  export type SubscriptionPlansMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration_days?: true
    description?: true
  }

  export type SubscriptionPlansMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration_days?: true
    description?: true
  }

  export type SubscriptionPlansCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration_days?: true
    description?: true
    _all?: true
  }

  export type SubscriptionPlansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to aggregate.
     */
    where?: SubscriptionPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlansOrderByWithRelationInput | SubscriptionPlansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlansMaxAggregateInputType
  }

  export type GetSubscriptionPlansAggregateType<T extends SubscriptionPlansAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlans[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlans[P]>
  }




  export type SubscriptionPlansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlansWhereInput
    orderBy?: SubscriptionPlansOrderByWithAggregationInput | SubscriptionPlansOrderByWithAggregationInput[]
    by: SubscriptionPlansScalarFieldEnum[] | SubscriptionPlansScalarFieldEnum
    having?: SubscriptionPlansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlansCountAggregateInputType | true
    _avg?: SubscriptionPlansAvgAggregateInputType
    _sum?: SubscriptionPlansSumAggregateInputType
    _min?: SubscriptionPlansMinAggregateInputType
    _max?: SubscriptionPlansMaxAggregateInputType
  }

  export type SubscriptionPlansGroupByOutputType = {
    id: bigint
    name: string
    price: Decimal
    duration_days: number
    description: string | null
    _count: SubscriptionPlansCountAggregateOutputType | null
    _avg: SubscriptionPlansAvgAggregateOutputType | null
    _sum: SubscriptionPlansSumAggregateOutputType | null
    _min: SubscriptionPlansMinAggregateOutputType | null
    _max: SubscriptionPlansMaxAggregateOutputType | null
  }

  type GetSubscriptionPlansGroupByPayload<T extends SubscriptionPlansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlansGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlansGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration_days?: boolean
    description?: boolean
    Payments?: boolean | SubscriptionPlans$PaymentsArgs<ExtArgs>
    Subscriptions?: boolean | SubscriptionPlans$SubscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlans"]>


  export type SubscriptionPlansSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    duration_days?: boolean
    description?: boolean
  }

  export type SubscriptionPlansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Payments?: boolean | SubscriptionPlans$PaymentsArgs<ExtArgs>
    Subscriptions?: boolean | SubscriptionPlans$SubscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlansCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPlansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlans"
    objects: {
      Payments: Prisma.$PaymentsPayload<ExtArgs>[]
      Subscriptions: Prisma.$SubscriptionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      price: Prisma.Decimal
      duration_days: number
      description: string | null
    }, ExtArgs["result"]["subscriptionPlans"]>
    composites: {}
  }

  type SubscriptionPlansGetPayload<S extends boolean | null | undefined | SubscriptionPlansDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlansPayload, S>

  type SubscriptionPlansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionPlansFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionPlansCountAggregateInputType | true
    }

  export interface SubscriptionPlansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlans'], meta: { name: 'SubscriptionPlans' } }
    /**
     * Find zero or one SubscriptionPlans that matches the filter.
     * @param {SubscriptionPlansFindUniqueArgs} args - Arguments to find a SubscriptionPlans
     * @example
     * // Get one SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionPlansFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionPlansFindUniqueArgs<ExtArgs>>
    ): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SubscriptionPlans that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionPlansFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlans
     * @example
     * // Get one SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionPlansFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionPlansFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlansFindFirstArgs} args - Arguments to find a SubscriptionPlans
     * @example
     * // Get one SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionPlansFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionPlansFindFirstArgs<ExtArgs>>
    ): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionPlans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlansFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlans
     * @example
     * // Get one SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionPlansFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionPlansFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlansWithIdOnly = await prisma.subscriptionPlans.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionPlansFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionPlansFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SubscriptionPlans.
     * @param {SubscriptionPlansCreateArgs} args - Arguments to create a SubscriptionPlans.
     * @example
     * // Create one SubscriptionPlans
     * const SubscriptionPlans = await prisma.subscriptionPlans.create({
     *   data: {
     *     // ... data to create a SubscriptionPlans
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionPlansCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionPlansCreateArgs<ExtArgs>>
    ): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlansCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends SubscriptionPlansCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionPlansCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubscriptionPlans.
     * @param {SubscriptionPlansDeleteArgs} args - Arguments to delete one SubscriptionPlans.
     * @example
     * // Delete one SubscriptionPlans
     * const SubscriptionPlans = await prisma.subscriptionPlans.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlans
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionPlansDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionPlansDeleteArgs<ExtArgs>>
    ): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SubscriptionPlans.
     * @param {SubscriptionPlansUpdateArgs} args - Arguments to update one SubscriptionPlans.
     * @example
     * // Update one SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionPlansUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionPlansUpdateArgs<ExtArgs>>
    ): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlansDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionPlansDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionPlansDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionPlansUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionPlansUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionPlans.
     * @param {SubscriptionPlansUpsertArgs} args - Arguments to update or create a SubscriptionPlans.
     * @example
     * // Update or create a SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlans.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionPlansUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionPlansUpsertArgs<ExtArgs>>
    ): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlansCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlans.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlansCountArgs>(
      args?: Subset<T, SubscriptionPlansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlansAggregateArgs>(args: Subset<T, SubscriptionPlansAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlansAggregateType<T>>

    /**
     * Group by SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlansGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlans model
   */
  readonly fields: SubscriptionPlansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Payments<T extends SubscriptionPlans$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlans$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Subscriptions<T extends SubscriptionPlans$SubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlans$SubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SubscriptionPlans model
   */ 
  interface SubscriptionPlansFieldRefs {
    readonly id: FieldRef<"SubscriptionPlans", 'BigInt'>
    readonly name: FieldRef<"SubscriptionPlans", 'String'>
    readonly price: FieldRef<"SubscriptionPlans", 'Decimal'>
    readonly duration_days: FieldRef<"SubscriptionPlans", 'Int'>
    readonly description: FieldRef<"SubscriptionPlans", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlans findUnique
   */
  export type SubscriptionPlansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where: SubscriptionPlansWhereUniqueInput
  }

  /**
   * SubscriptionPlans findUniqueOrThrow
   */
  export type SubscriptionPlansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where: SubscriptionPlansWhereUniqueInput
  }

  /**
   * SubscriptionPlans findFirst
   */
  export type SubscriptionPlansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlansOrderByWithRelationInput | SubscriptionPlansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlansScalarFieldEnum | SubscriptionPlansScalarFieldEnum[]
  }

  /**
   * SubscriptionPlans findFirstOrThrow
   */
  export type SubscriptionPlansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlansOrderByWithRelationInput | SubscriptionPlansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlansScalarFieldEnum | SubscriptionPlansScalarFieldEnum[]
  }

  /**
   * SubscriptionPlans findMany
   */
  export type SubscriptionPlansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlansOrderByWithRelationInput | SubscriptionPlansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlansScalarFieldEnum | SubscriptionPlansScalarFieldEnum[]
  }

  /**
   * SubscriptionPlans create
   */
  export type SubscriptionPlansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlans.
     */
    data: XOR<SubscriptionPlansCreateInput, SubscriptionPlansUncheckedCreateInput>
  }

  /**
   * SubscriptionPlans createMany
   */
  export type SubscriptionPlansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlansCreateManyInput | SubscriptionPlansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlans update
   */
  export type SubscriptionPlansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlans.
     */
    data: XOR<SubscriptionPlansUpdateInput, SubscriptionPlansUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlans to update.
     */
    where: SubscriptionPlansWhereUniqueInput
  }

  /**
   * SubscriptionPlans updateMany
   */
  export type SubscriptionPlansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlansUpdateManyMutationInput, SubscriptionPlansUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlansWhereInput
  }

  /**
   * SubscriptionPlans upsert
   */
  export type SubscriptionPlansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlans to update in case it exists.
     */
    where: SubscriptionPlansWhereUniqueInput
    /**
     * In case the SubscriptionPlans found by the `where` argument doesn't exist, create a new SubscriptionPlans with this data.
     */
    create: XOR<SubscriptionPlansCreateInput, SubscriptionPlansUncheckedCreateInput>
    /**
     * In case the SubscriptionPlans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlansUpdateInput, SubscriptionPlansUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlans delete
   */
  export type SubscriptionPlansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlans to delete.
     */
    where: SubscriptionPlansWhereUniqueInput
  }

  /**
   * SubscriptionPlans deleteMany
   */
  export type SubscriptionPlansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlansWhereInput
  }

  /**
   * SubscriptionPlans.Payments
   */
  export type SubscriptionPlans$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * SubscriptionPlans.Subscriptions
   */
  export type SubscriptionPlans$SubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    where?: SubscriptionsWhereInput
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    cursor?: SubscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * SubscriptionPlans without action
   */
  export type SubscriptionPlansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlans
     */
    select?: SubscriptionPlansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlansInclude<ExtArgs> | null
  }


  /**
   * Model Subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
  }

  export type SubscriptionsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    plan_id: bigint | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    plan_id: bigint | null
    status: $Enums.Subscriptions_status | null
    start_date: Date | null
    end_date: Date | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    plan_id: bigint | null
    status: $Enums.Subscriptions_status | null
    start_date: Date | null
    end_date: Date | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    id: number
    user_id: number
    plan_id: number
    status: number
    start_date: number
    end_date: number
    _all: number
  }


  export type SubscriptionsAvgAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
  }

  export type SubscriptionsSumAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
  }

  export type SubscriptionsMinAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    status?: true
    start_date?: true
    end_date?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    status?: true
    start_date?: true
    end_date?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    status?: true
    start_date?: true
    end_date?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to aggregate.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type SubscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionsWhereInput
    orderBy?: SubscriptionsOrderByWithAggregationInput | SubscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: SubscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _avg?: SubscriptionsAvgAggregateInputType
    _sum?: SubscriptionsSumAggregateInputType
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    id: bigint
    user_id: bigint
    plan_id: bigint
    status: $Enums.Subscriptions_status
    start_date: Date
    end_date: Date
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends SubscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    plan_id?: boolean
    status?: boolean
    start_date?: boolean
    end_date?: boolean
    SubscriptionPlans?: boolean | SubscriptionPlansDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>


  export type SubscriptionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    plan_id?: boolean
    status?: boolean
    start_date?: boolean
    end_date?: boolean
  }

  export type SubscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubscriptionPlans?: boolean | SubscriptionPlansDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $SubscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscriptions"
    objects: {
      SubscriptionPlans: Prisma.$SubscriptionPlansPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      plan_id: bigint
      status: $Enums.Subscriptions_status
      start_date: Date
      end_date: Date
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type SubscriptionsGetPayload<S extends boolean | null | undefined | SubscriptionsDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionsPayload, S>

  type SubscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface SubscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscriptions'], meta: { name: 'Subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {SubscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionsFindUniqueArgs<ExtArgs>>
    ): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionsFindFirstArgs<ExtArgs>>
    ): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Subscriptions.
     * @param {SubscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionsCreateArgs<ExtArgs>>
    ): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends SubscriptionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscriptions.
     * @param {SubscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionsDeleteArgs<ExtArgs>>
    ): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Subscriptions.
     * @param {SubscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionsUpdateArgs<ExtArgs>>
    ): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriptions.
     * @param {SubscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionsUpsertArgs<ExtArgs>>
    ): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionsCountArgs>(
      args?: Subset<T, SubscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscriptions model
   */
  readonly fields: SubscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    SubscriptionPlans<T extends SubscriptionPlansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlansDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlansClient<$Result.GetResult<Prisma.$SubscriptionPlansPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Subscriptions model
   */ 
  interface SubscriptionsFieldRefs {
    readonly id: FieldRef<"Subscriptions", 'BigInt'>
    readonly user_id: FieldRef<"Subscriptions", 'BigInt'>
    readonly plan_id: FieldRef<"Subscriptions", 'BigInt'>
    readonly status: FieldRef<"Subscriptions", 'Subscriptions_status'>
    readonly start_date: FieldRef<"Subscriptions", 'DateTime'>
    readonly end_date: FieldRef<"Subscriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscriptions findUnique
   */
  export type SubscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions findUniqueOrThrow
   */
  export type SubscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions findFirst
   */
  export type SubscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions findFirstOrThrow
   */
  export type SubscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions findMany
   */
  export type SubscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions create
   */
  export type SubscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscriptions.
     */
    data: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
  }

  /**
   * Subscriptions createMany
   */
  export type SubscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionsCreateManyInput | SubscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriptions update
   */
  export type SubscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscriptions.
     */
    data: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
    /**
     * Choose, which Subscriptions to update.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions updateMany
   */
  export type SubscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionsWhereInput
  }

  /**
   * Subscriptions upsert
   */
  export type SubscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscriptions to update in case it exists.
     */
    where: SubscriptionsWhereUniqueInput
    /**
     * In case the Subscriptions found by the `where` argument doesn't exist, create a new Subscriptions with this data.
     */
    create: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
    /**
     * In case the Subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
  }

  /**
   * Subscriptions delete
   */
  export type SubscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter which Subscriptions to delete.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions deleteMany
   */
  export type SubscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionsWhereInput
  }

  /**
   * Subscriptions without action
   */
  export type SubscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
  }


  /**
   * Model UserAnswers
   */

  export type AggregateUserAnswers = {
    _count: UserAnswersCountAggregateOutputType | null
    _avg: UserAnswersAvgAggregateOutputType | null
    _sum: UserAnswersSumAggregateOutputType | null
    _min: UserAnswersMinAggregateOutputType | null
    _max: UserAnswersMaxAggregateOutputType | null
  }

  export type UserAnswersAvgAggregateOutputType = {
    id: number | null
    attempt_id: number | null
    question_id: number | null
    selected_option_id: number | null
  }

  export type UserAnswersSumAggregateOutputType = {
    id: bigint | null
    attempt_id: bigint | null
    question_id: bigint | null
    selected_option_id: bigint | null
  }

  export type UserAnswersMinAggregateOutputType = {
    id: bigint | null
    attempt_id: bigint | null
    question_id: bigint | null
    selected_option_id: bigint | null
    answer_text: string | null
  }

  export type UserAnswersMaxAggregateOutputType = {
    id: bigint | null
    attempt_id: bigint | null
    question_id: bigint | null
    selected_option_id: bigint | null
    answer_text: string | null
  }

  export type UserAnswersCountAggregateOutputType = {
    id: number
    attempt_id: number
    question_id: number
    selected_option_id: number
    answer_text: number
    _all: number
  }


  export type UserAnswersAvgAggregateInputType = {
    id?: true
    attempt_id?: true
    question_id?: true
    selected_option_id?: true
  }

  export type UserAnswersSumAggregateInputType = {
    id?: true
    attempt_id?: true
    question_id?: true
    selected_option_id?: true
  }

  export type UserAnswersMinAggregateInputType = {
    id?: true
    attempt_id?: true
    question_id?: true
    selected_option_id?: true
    answer_text?: true
  }

  export type UserAnswersMaxAggregateInputType = {
    id?: true
    attempt_id?: true
    question_id?: true
    selected_option_id?: true
    answer_text?: true
  }

  export type UserAnswersCountAggregateInputType = {
    id?: true
    attempt_id?: true
    question_id?: true
    selected_option_id?: true
    answer_text?: true
    _all?: true
  }

  export type UserAnswersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnswers to aggregate.
     */
    where?: UserAnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswersOrderByWithRelationInput | UserAnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAnswers
    **/
    _count?: true | UserAnswersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAnswersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAnswersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAnswersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAnswersMaxAggregateInputType
  }

  export type GetUserAnswersAggregateType<T extends UserAnswersAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAnswers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAnswers[P]>
      : GetScalarType<T[P], AggregateUserAnswers[P]>
  }




  export type UserAnswersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswersWhereInput
    orderBy?: UserAnswersOrderByWithAggregationInput | UserAnswersOrderByWithAggregationInput[]
    by: UserAnswersScalarFieldEnum[] | UserAnswersScalarFieldEnum
    having?: UserAnswersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAnswersCountAggregateInputType | true
    _avg?: UserAnswersAvgAggregateInputType
    _sum?: UserAnswersSumAggregateInputType
    _min?: UserAnswersMinAggregateInputType
    _max?: UserAnswersMaxAggregateInputType
  }

  export type UserAnswersGroupByOutputType = {
    id: bigint
    attempt_id: bigint
    question_id: bigint
    selected_option_id: bigint | null
    answer_text: string | null
    _count: UserAnswersCountAggregateOutputType | null
    _avg: UserAnswersAvgAggregateOutputType | null
    _sum: UserAnswersSumAggregateOutputType | null
    _min: UserAnswersMinAggregateOutputType | null
    _max: UserAnswersMaxAggregateOutputType | null
  }

  type GetUserAnswersGroupByPayload<T extends UserAnswersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAnswersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAnswersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAnswersGroupByOutputType[P]>
            : GetScalarType<T[P], UserAnswersGroupByOutputType[P]>
        }
      >
    >


  export type UserAnswersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attempt_id?: boolean
    question_id?: boolean
    selected_option_id?: boolean
    answer_text?: boolean
    QuizAttempts?: boolean | QuizAttemptsDefaultArgs<ExtArgs>
    AssessmentOptions?: boolean | UserAnswers$AssessmentOptionsArgs<ExtArgs>
    AssessmentQuestions?: boolean | AssessmentQuestionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAnswers"]>


  export type UserAnswersSelectScalar = {
    id?: boolean
    attempt_id?: boolean
    question_id?: boolean
    selected_option_id?: boolean
    answer_text?: boolean
  }

  export type UserAnswersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QuizAttempts?: boolean | QuizAttemptsDefaultArgs<ExtArgs>
    AssessmentOptions?: boolean | UserAnswers$AssessmentOptionsArgs<ExtArgs>
    AssessmentQuestions?: boolean | AssessmentQuestionsDefaultArgs<ExtArgs>
  }

  export type $UserAnswersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAnswers"
    objects: {
      QuizAttempts: Prisma.$QuizAttemptsPayload<ExtArgs>
      AssessmentOptions: Prisma.$AssessmentOptionsPayload<ExtArgs> | null
      AssessmentQuestions: Prisma.$AssessmentQuestionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      attempt_id: bigint
      question_id: bigint
      selected_option_id: bigint | null
      answer_text: string | null
    }, ExtArgs["result"]["userAnswers"]>
    composites: {}
  }

  type UserAnswersGetPayload<S extends boolean | null | undefined | UserAnswersDefaultArgs> = $Result.GetResult<Prisma.$UserAnswersPayload, S>

  type UserAnswersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAnswersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAnswersCountAggregateInputType | true
    }

  export interface UserAnswersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAnswers'], meta: { name: 'UserAnswers' } }
    /**
     * Find zero or one UserAnswers that matches the filter.
     * @param {UserAnswersFindUniqueArgs} args - Arguments to find a UserAnswers
     * @example
     * // Get one UserAnswers
     * const userAnswers = await prisma.userAnswers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAnswersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserAnswersFindUniqueArgs<ExtArgs>>
    ): Prisma__UserAnswersClient<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserAnswers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAnswersFindUniqueOrThrowArgs} args - Arguments to find a UserAnswers
     * @example
     * // Get one UserAnswers
     * const userAnswers = await prisma.userAnswers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserAnswersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAnswersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAnswersClient<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswersFindFirstArgs} args - Arguments to find a UserAnswers
     * @example
     * // Get one UserAnswers
     * const userAnswers = await prisma.userAnswers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAnswersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAnswersFindFirstArgs<ExtArgs>>
    ): Prisma__UserAnswersClient<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserAnswers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswersFindFirstOrThrowArgs} args - Arguments to find a UserAnswers
     * @example
     * // Get one UserAnswers
     * const userAnswers = await prisma.userAnswers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserAnswersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAnswersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAnswersClient<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAnswers
     * const userAnswers = await prisma.userAnswers.findMany()
     * 
     * // Get first 10 UserAnswers
     * const userAnswers = await prisma.userAnswers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAnswersWithIdOnly = await prisma.userAnswers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserAnswersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAnswersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserAnswers.
     * @param {UserAnswersCreateArgs} args - Arguments to create a UserAnswers.
     * @example
     * // Create one UserAnswers
     * const UserAnswers = await prisma.userAnswers.create({
     *   data: {
     *     // ... data to create a UserAnswers
     *   }
     * })
     * 
    **/
    create<T extends UserAnswersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAnswersCreateArgs<ExtArgs>>
    ): Prisma__UserAnswersClient<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserAnswers.
     * @param {UserAnswersCreateManyArgs} args - Arguments to create many UserAnswers.
     * @example
     * // Create many UserAnswers
     * const userAnswers = await prisma.userAnswers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserAnswersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAnswersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAnswers.
     * @param {UserAnswersDeleteArgs} args - Arguments to delete one UserAnswers.
     * @example
     * // Delete one UserAnswers
     * const UserAnswers = await prisma.userAnswers.delete({
     *   where: {
     *     // ... filter to delete one UserAnswers
     *   }
     * })
     * 
    **/
    delete<T extends UserAnswersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserAnswersDeleteArgs<ExtArgs>>
    ): Prisma__UserAnswersClient<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserAnswers.
     * @param {UserAnswersUpdateArgs} args - Arguments to update one UserAnswers.
     * @example
     * // Update one UserAnswers
     * const userAnswers = await prisma.userAnswers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAnswersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAnswersUpdateArgs<ExtArgs>>
    ): Prisma__UserAnswersClient<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserAnswers.
     * @param {UserAnswersDeleteManyArgs} args - Arguments to filter UserAnswers to delete.
     * @example
     * // Delete a few UserAnswers
     * const { count } = await prisma.userAnswers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAnswersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAnswersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAnswers
     * const userAnswers = await prisma.userAnswers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAnswersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserAnswersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAnswers.
     * @param {UserAnswersUpsertArgs} args - Arguments to update or create a UserAnswers.
     * @example
     * // Update or create a UserAnswers
     * const userAnswers = await prisma.userAnswers.upsert({
     *   create: {
     *     // ... data to create a UserAnswers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAnswers we want to update
     *   }
     * })
    **/
    upsert<T extends UserAnswersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserAnswersUpsertArgs<ExtArgs>>
    ): Prisma__UserAnswersClient<$Result.GetResult<Prisma.$UserAnswersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswersCountArgs} args - Arguments to filter UserAnswers to count.
     * @example
     * // Count the number of UserAnswers
     * const count = await prisma.userAnswers.count({
     *   where: {
     *     // ... the filter for the UserAnswers we want to count
     *   }
     * })
    **/
    count<T extends UserAnswersCountArgs>(
      args?: Subset<T, UserAnswersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAnswersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAnswersAggregateArgs>(args: Subset<T, UserAnswersAggregateArgs>): Prisma.PrismaPromise<GetUserAnswersAggregateType<T>>

    /**
     * Group by UserAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAnswersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAnswersGroupByArgs['orderBy'] }
        : { orderBy?: UserAnswersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAnswersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAnswersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAnswers model
   */
  readonly fields: UserAnswersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAnswers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAnswersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    QuizAttempts<T extends QuizAttemptsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttemptsDefaultArgs<ExtArgs>>): Prisma__QuizAttemptsClient<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    AssessmentOptions<T extends UserAnswers$AssessmentOptionsArgs<ExtArgs> = {}>(args?: Subset<T, UserAnswers$AssessmentOptionsArgs<ExtArgs>>): Prisma__AssessmentOptionsClient<$Result.GetResult<Prisma.$AssessmentOptionsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    AssessmentQuestions<T extends AssessmentQuestionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentQuestionsDefaultArgs<ExtArgs>>): Prisma__AssessmentQuestionsClient<$Result.GetResult<Prisma.$AssessmentQuestionsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserAnswers model
   */ 
  interface UserAnswersFieldRefs {
    readonly id: FieldRef<"UserAnswers", 'BigInt'>
    readonly attempt_id: FieldRef<"UserAnswers", 'BigInt'>
    readonly question_id: FieldRef<"UserAnswers", 'BigInt'>
    readonly selected_option_id: FieldRef<"UserAnswers", 'BigInt'>
    readonly answer_text: FieldRef<"UserAnswers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAnswers findUnique
   */
  export type UserAnswersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswers to fetch.
     */
    where: UserAnswersWhereUniqueInput
  }

  /**
   * UserAnswers findUniqueOrThrow
   */
  export type UserAnswersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswers to fetch.
     */
    where: UserAnswersWhereUniqueInput
  }

  /**
   * UserAnswers findFirst
   */
  export type UserAnswersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswers to fetch.
     */
    where?: UserAnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswersOrderByWithRelationInput | UserAnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnswers.
     */
    cursor?: UserAnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnswers.
     */
    distinct?: UserAnswersScalarFieldEnum | UserAnswersScalarFieldEnum[]
  }

  /**
   * UserAnswers findFirstOrThrow
   */
  export type UserAnswersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswers to fetch.
     */
    where?: UserAnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswersOrderByWithRelationInput | UserAnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnswers.
     */
    cursor?: UserAnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnswers.
     */
    distinct?: UserAnswersScalarFieldEnum | UserAnswersScalarFieldEnum[]
  }

  /**
   * UserAnswers findMany
   */
  export type UserAnswersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswers to fetch.
     */
    where?: UserAnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswersOrderByWithRelationInput | UserAnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAnswers.
     */
    cursor?: UserAnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    distinct?: UserAnswersScalarFieldEnum | UserAnswersScalarFieldEnum[]
  }

  /**
   * UserAnswers create
   */
  export type UserAnswersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAnswers.
     */
    data: XOR<UserAnswersCreateInput, UserAnswersUncheckedCreateInput>
  }

  /**
   * UserAnswers createMany
   */
  export type UserAnswersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAnswers.
     */
    data: UserAnswersCreateManyInput | UserAnswersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAnswers update
   */
  export type UserAnswersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAnswers.
     */
    data: XOR<UserAnswersUpdateInput, UserAnswersUncheckedUpdateInput>
    /**
     * Choose, which UserAnswers to update.
     */
    where: UserAnswersWhereUniqueInput
  }

  /**
   * UserAnswers updateMany
   */
  export type UserAnswersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAnswers.
     */
    data: XOR<UserAnswersUpdateManyMutationInput, UserAnswersUncheckedUpdateManyInput>
    /**
     * Filter which UserAnswers to update
     */
    where?: UserAnswersWhereInput
  }

  /**
   * UserAnswers upsert
   */
  export type UserAnswersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAnswers to update in case it exists.
     */
    where: UserAnswersWhereUniqueInput
    /**
     * In case the UserAnswers found by the `where` argument doesn't exist, create a new UserAnswers with this data.
     */
    create: XOR<UserAnswersCreateInput, UserAnswersUncheckedCreateInput>
    /**
     * In case the UserAnswers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAnswersUpdateInput, UserAnswersUncheckedUpdateInput>
  }

  /**
   * UserAnswers delete
   */
  export type UserAnswersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
    /**
     * Filter which UserAnswers to delete.
     */
    where: UserAnswersWhereUniqueInput
  }

  /**
   * UserAnswers deleteMany
   */
  export type UserAnswersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnswers to delete
     */
    where?: UserAnswersWhereInput
  }

  /**
   * UserAnswers.AssessmentOptions
   */
  export type UserAnswers$AssessmentOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentOptions
     */
    select?: AssessmentOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentOptionsInclude<ExtArgs> | null
    where?: AssessmentOptionsWhereInput
  }

  /**
   * UserAnswers without action
   */
  export type UserAnswersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswers
     */
    select?: UserAnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswersInclude<ExtArgs> | null
  }


  /**
   * Model UserSavedCourses
   */

  export type AggregateUserSavedCourses = {
    _count: UserSavedCoursesCountAggregateOutputType | null
    _avg: UserSavedCoursesAvgAggregateOutputType | null
    _sum: UserSavedCoursesSumAggregateOutputType | null
    _min: UserSavedCoursesMinAggregateOutputType | null
    _max: UserSavedCoursesMaxAggregateOutputType | null
  }

  export type UserSavedCoursesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    course_id: number | null
  }

  export type UserSavedCoursesSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
  }

  export type UserSavedCoursesMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
  }

  export type UserSavedCoursesMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
  }

  export type UserSavedCoursesCountAggregateOutputType = {
    id: number
    user_id: number
    course_id: number
    _all: number
  }


  export type UserSavedCoursesAvgAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type UserSavedCoursesSumAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type UserSavedCoursesMinAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type UserSavedCoursesMaxAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
  }

  export type UserSavedCoursesCountAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    _all?: true
  }

  export type UserSavedCoursesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSavedCourses to aggregate.
     */
    where?: UserSavedCoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSavedCourses to fetch.
     */
    orderBy?: UserSavedCoursesOrderByWithRelationInput | UserSavedCoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSavedCoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSavedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSavedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSavedCourses
    **/
    _count?: true | UserSavedCoursesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSavedCoursesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSavedCoursesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSavedCoursesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSavedCoursesMaxAggregateInputType
  }

  export type GetUserSavedCoursesAggregateType<T extends UserSavedCoursesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSavedCourses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSavedCourses[P]>
      : GetScalarType<T[P], AggregateUserSavedCourses[P]>
  }




  export type UserSavedCoursesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSavedCoursesWhereInput
    orderBy?: UserSavedCoursesOrderByWithAggregationInput | UserSavedCoursesOrderByWithAggregationInput[]
    by: UserSavedCoursesScalarFieldEnum[] | UserSavedCoursesScalarFieldEnum
    having?: UserSavedCoursesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSavedCoursesCountAggregateInputType | true
    _avg?: UserSavedCoursesAvgAggregateInputType
    _sum?: UserSavedCoursesSumAggregateInputType
    _min?: UserSavedCoursesMinAggregateInputType
    _max?: UserSavedCoursesMaxAggregateInputType
  }

  export type UserSavedCoursesGroupByOutputType = {
    id: bigint
    user_id: bigint
    course_id: bigint
    _count: UserSavedCoursesCountAggregateOutputType | null
    _avg: UserSavedCoursesAvgAggregateOutputType | null
    _sum: UserSavedCoursesSumAggregateOutputType | null
    _min: UserSavedCoursesMinAggregateOutputType | null
    _max: UserSavedCoursesMaxAggregateOutputType | null
  }

  type GetUserSavedCoursesGroupByPayload<T extends UserSavedCoursesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSavedCoursesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSavedCoursesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSavedCoursesGroupByOutputType[P]>
            : GetScalarType<T[P], UserSavedCoursesGroupByOutputType[P]>
        }
      >
    >


  export type UserSavedCoursesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSavedCourses"]>


  export type UserSavedCoursesSelectScalar = {
    id?: boolean
    user_id?: boolean
    course_id?: boolean
  }

  export type UserSavedCoursesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UserSavedCoursesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSavedCourses"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      course_id: bigint
    }, ExtArgs["result"]["userSavedCourses"]>
    composites: {}
  }

  type UserSavedCoursesGetPayload<S extends boolean | null | undefined | UserSavedCoursesDefaultArgs> = $Result.GetResult<Prisma.$UserSavedCoursesPayload, S>

  type UserSavedCoursesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSavedCoursesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSavedCoursesCountAggregateInputType | true
    }

  export interface UserSavedCoursesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSavedCourses'], meta: { name: 'UserSavedCourses' } }
    /**
     * Find zero or one UserSavedCourses that matches the filter.
     * @param {UserSavedCoursesFindUniqueArgs} args - Arguments to find a UserSavedCourses
     * @example
     * // Get one UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserSavedCoursesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserSavedCoursesFindUniqueArgs<ExtArgs>>
    ): Prisma__UserSavedCoursesClient<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserSavedCourses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSavedCoursesFindUniqueOrThrowArgs} args - Arguments to find a UserSavedCourses
     * @example
     * // Get one UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserSavedCoursesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSavedCoursesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserSavedCoursesClient<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserSavedCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedCoursesFindFirstArgs} args - Arguments to find a UserSavedCourses
     * @example
     * // Get one UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserSavedCoursesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSavedCoursesFindFirstArgs<ExtArgs>>
    ): Prisma__UserSavedCoursesClient<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserSavedCourses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedCoursesFindFirstOrThrowArgs} args - Arguments to find a UserSavedCourses
     * @example
     * // Get one UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserSavedCoursesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSavedCoursesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserSavedCoursesClient<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserSavedCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedCoursesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.findMany()
     * 
     * // Get first 10 UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSavedCoursesWithIdOnly = await prisma.userSavedCourses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserSavedCoursesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSavedCoursesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserSavedCourses.
     * @param {UserSavedCoursesCreateArgs} args - Arguments to create a UserSavedCourses.
     * @example
     * // Create one UserSavedCourses
     * const UserSavedCourses = await prisma.userSavedCourses.create({
     *   data: {
     *     // ... data to create a UserSavedCourses
     *   }
     * })
     * 
    **/
    create<T extends UserSavedCoursesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserSavedCoursesCreateArgs<ExtArgs>>
    ): Prisma__UserSavedCoursesClient<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserSavedCourses.
     * @param {UserSavedCoursesCreateManyArgs} args - Arguments to create many UserSavedCourses.
     * @example
     * // Create many UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserSavedCoursesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSavedCoursesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSavedCourses.
     * @param {UserSavedCoursesDeleteArgs} args - Arguments to delete one UserSavedCourses.
     * @example
     * // Delete one UserSavedCourses
     * const UserSavedCourses = await prisma.userSavedCourses.delete({
     *   where: {
     *     // ... filter to delete one UserSavedCourses
     *   }
     * })
     * 
    **/
    delete<T extends UserSavedCoursesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserSavedCoursesDeleteArgs<ExtArgs>>
    ): Prisma__UserSavedCoursesClient<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserSavedCourses.
     * @param {UserSavedCoursesUpdateArgs} args - Arguments to update one UserSavedCourses.
     * @example
     * // Update one UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserSavedCoursesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserSavedCoursesUpdateArgs<ExtArgs>>
    ): Prisma__UserSavedCoursesClient<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserSavedCourses.
     * @param {UserSavedCoursesDeleteManyArgs} args - Arguments to filter UserSavedCourses to delete.
     * @example
     * // Delete a few UserSavedCourses
     * const { count } = await prisma.userSavedCourses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserSavedCoursesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSavedCoursesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSavedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedCoursesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserSavedCoursesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserSavedCoursesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSavedCourses.
     * @param {UserSavedCoursesUpsertArgs} args - Arguments to update or create a UserSavedCourses.
     * @example
     * // Update or create a UserSavedCourses
     * const userSavedCourses = await prisma.userSavedCourses.upsert({
     *   create: {
     *     // ... data to create a UserSavedCourses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSavedCourses we want to update
     *   }
     * })
    **/
    upsert<T extends UserSavedCoursesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserSavedCoursesUpsertArgs<ExtArgs>>
    ): Prisma__UserSavedCoursesClient<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserSavedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedCoursesCountArgs} args - Arguments to filter UserSavedCourses to count.
     * @example
     * // Count the number of UserSavedCourses
     * const count = await prisma.userSavedCourses.count({
     *   where: {
     *     // ... the filter for the UserSavedCourses we want to count
     *   }
     * })
    **/
    count<T extends UserSavedCoursesCountArgs>(
      args?: Subset<T, UserSavedCoursesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSavedCoursesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSavedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedCoursesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSavedCoursesAggregateArgs>(args: Subset<T, UserSavedCoursesAggregateArgs>): Prisma.PrismaPromise<GetUserSavedCoursesAggregateType<T>>

    /**
     * Group by UserSavedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedCoursesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSavedCoursesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSavedCoursesGroupByArgs['orderBy'] }
        : { orderBy?: UserSavedCoursesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSavedCoursesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSavedCoursesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSavedCourses model
   */
  readonly fields: UserSavedCoursesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSavedCourses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSavedCoursesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserSavedCourses model
   */ 
  interface UserSavedCoursesFieldRefs {
    readonly id: FieldRef<"UserSavedCourses", 'BigInt'>
    readonly user_id: FieldRef<"UserSavedCourses", 'BigInt'>
    readonly course_id: FieldRef<"UserSavedCourses", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * UserSavedCourses findUnique
   */
  export type UserSavedCoursesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedCourses to fetch.
     */
    where: UserSavedCoursesWhereUniqueInput
  }

  /**
   * UserSavedCourses findUniqueOrThrow
   */
  export type UserSavedCoursesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedCourses to fetch.
     */
    where: UserSavedCoursesWhereUniqueInput
  }

  /**
   * UserSavedCourses findFirst
   */
  export type UserSavedCoursesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedCourses to fetch.
     */
    where?: UserSavedCoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSavedCourses to fetch.
     */
    orderBy?: UserSavedCoursesOrderByWithRelationInput | UserSavedCoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSavedCourses.
     */
    cursor?: UserSavedCoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSavedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSavedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSavedCourses.
     */
    distinct?: UserSavedCoursesScalarFieldEnum | UserSavedCoursesScalarFieldEnum[]
  }

  /**
   * UserSavedCourses findFirstOrThrow
   */
  export type UserSavedCoursesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedCourses to fetch.
     */
    where?: UserSavedCoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSavedCourses to fetch.
     */
    orderBy?: UserSavedCoursesOrderByWithRelationInput | UserSavedCoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSavedCourses.
     */
    cursor?: UserSavedCoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSavedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSavedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSavedCourses.
     */
    distinct?: UserSavedCoursesScalarFieldEnum | UserSavedCoursesScalarFieldEnum[]
  }

  /**
   * UserSavedCourses findMany
   */
  export type UserSavedCoursesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedCourses to fetch.
     */
    where?: UserSavedCoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSavedCourses to fetch.
     */
    orderBy?: UserSavedCoursesOrderByWithRelationInput | UserSavedCoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSavedCourses.
     */
    cursor?: UserSavedCoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSavedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSavedCourses.
     */
    skip?: number
    distinct?: UserSavedCoursesScalarFieldEnum | UserSavedCoursesScalarFieldEnum[]
  }

  /**
   * UserSavedCourses create
   */
  export type UserSavedCoursesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSavedCourses.
     */
    data: XOR<UserSavedCoursesCreateInput, UserSavedCoursesUncheckedCreateInput>
  }

  /**
   * UserSavedCourses createMany
   */
  export type UserSavedCoursesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSavedCourses.
     */
    data: UserSavedCoursesCreateManyInput | UserSavedCoursesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSavedCourses update
   */
  export type UserSavedCoursesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSavedCourses.
     */
    data: XOR<UserSavedCoursesUpdateInput, UserSavedCoursesUncheckedUpdateInput>
    /**
     * Choose, which UserSavedCourses to update.
     */
    where: UserSavedCoursesWhereUniqueInput
  }

  /**
   * UserSavedCourses updateMany
   */
  export type UserSavedCoursesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSavedCourses.
     */
    data: XOR<UserSavedCoursesUpdateManyMutationInput, UserSavedCoursesUncheckedUpdateManyInput>
    /**
     * Filter which UserSavedCourses to update
     */
    where?: UserSavedCoursesWhereInput
  }

  /**
   * UserSavedCourses upsert
   */
  export type UserSavedCoursesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSavedCourses to update in case it exists.
     */
    where: UserSavedCoursesWhereUniqueInput
    /**
     * In case the UserSavedCourses found by the `where` argument doesn't exist, create a new UserSavedCourses with this data.
     */
    create: XOR<UserSavedCoursesCreateInput, UserSavedCoursesUncheckedCreateInput>
    /**
     * In case the UserSavedCourses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSavedCoursesUpdateInput, UserSavedCoursesUncheckedUpdateInput>
  }

  /**
   * UserSavedCourses delete
   */
  export type UserSavedCoursesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    /**
     * Filter which UserSavedCourses to delete.
     */
    where: UserSavedCoursesWhereUniqueInput
  }

  /**
   * UserSavedCourses deleteMany
   */
  export type UserSavedCoursesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSavedCourses to delete
     */
    where?: UserSavedCoursesWhereInput
  }

  /**
   * UserSavedCourses without action
   */
  export type UserSavedCoursesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: bigint | null
  }

  export type UsersMinAggregateOutputType = {
    id: bigint | null
    email: string | null
    password_hash: string | null
    role: $Enums.Users_role | null
    first_name: string | null
    last_name: string | null
    headline: string | null
    biography: string | null
    photo_url: string | null
    field_of_learning: string | null
    occupation: string | null
    resume_url: string | null
    instructor_application_status: $Enums.Users_instructor_application_status | null
    instructor_application_submitted_at: Date | null
    instructor_reviewed_at: Date | null
    instructor_admin_comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: bigint | null
    email: string | null
    password_hash: string | null
    role: $Enums.Users_role | null
    first_name: string | null
    last_name: string | null
    headline: string | null
    biography: string | null
    photo_url: string | null
    field_of_learning: string | null
    occupation: string | null
    resume_url: string | null
    instructor_application_status: $Enums.Users_instructor_application_status | null
    instructor_application_submitted_at: Date | null
    instructor_reviewed_at: Date | null
    instructor_admin_comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    role: number
    first_name: number
    last_name: number
    headline: number
    biography: number
    photo_url: number
    field_of_learning: number
    occupation: number
    skills: number
    interests: number
    resume_url: number
    instructor_application_status: number
    instructor_application_submitted_at: number
    instructor_reviewed_at: number
    instructor_admin_comment: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    first_name?: true
    last_name?: true
    headline?: true
    biography?: true
    photo_url?: true
    field_of_learning?: true
    occupation?: true
    resume_url?: true
    instructor_application_status?: true
    instructor_application_submitted_at?: true
    instructor_reviewed_at?: true
    instructor_admin_comment?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    first_name?: true
    last_name?: true
    headline?: true
    biography?: true
    photo_url?: true
    field_of_learning?: true
    occupation?: true
    resume_url?: true
    instructor_application_status?: true
    instructor_application_submitted_at?: true
    instructor_reviewed_at?: true
    instructor_admin_comment?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    first_name?: true
    last_name?: true
    headline?: true
    biography?: true
    photo_url?: true
    field_of_learning?: true
    occupation?: true
    skills?: true
    interests?: true
    resume_url?: true
    instructor_application_status?: true
    instructor_application_submitted_at?: true
    instructor_reviewed_at?: true
    instructor_admin_comment?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: bigint
    email: string
    password_hash: string
    role: $Enums.Users_role
    first_name: string | null
    last_name: string | null
    headline: string | null
    biography: string | null
    photo_url: string | null
    field_of_learning: string | null
    occupation: string | null
    skills: JsonValue | null
    interests: JsonValue | null
    resume_url: string | null
    instructor_application_status: $Enums.Users_instructor_application_status
    instructor_application_submitted_at: Date | null
    instructor_reviewed_at: Date | null
    instructor_admin_comment: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    first_name?: boolean
    last_name?: boolean
    headline?: boolean
    biography?: boolean
    photo_url?: boolean
    field_of_learning?: boolean
    occupation?: boolean
    skills?: boolean
    interests?: boolean
    resume_url?: boolean
    instructor_application_status?: boolean
    instructor_application_submitted_at?: boolean
    instructor_reviewed_at?: boolean
    instructor_admin_comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    Certificates?: boolean | Users$CertificatesArgs<ExtArgs>
    Courses?: boolean | Users$CoursesArgs<ExtArgs>
    Enrollments?: boolean | Users$EnrollmentsArgs<ExtArgs>
    LessonProgress?: boolean | Users$LessonProgressArgs<ExtArgs>
    Messages_Messages_receiver_idToUsers?: boolean | Users$Messages_Messages_receiver_idToUsersArgs<ExtArgs>
    Messages_Messages_sender_idToUsers?: boolean | Users$Messages_Messages_sender_idToUsersArgs<ExtArgs>
    MultiFactorAuth?: boolean | Users$MultiFactorAuthArgs<ExtArgs>
    Notifications?: boolean | Users$NotificationsArgs<ExtArgs>
    Payments?: boolean | Users$PaymentsArgs<ExtArgs>
    QuizAttempts?: boolean | Users$QuizAttemptsArgs<ExtArgs>
    Reviews_Reviews_instructor_idToUsers?: boolean | Users$Reviews_Reviews_instructor_idToUsersArgs<ExtArgs>
    Reviews_Reviews_user_idToUsers?: boolean | Users$Reviews_Reviews_user_idToUsersArgs<ExtArgs>
    ShoppingCart?: boolean | Users$ShoppingCartArgs<ExtArgs>
    Subscriptions?: boolean | Users$SubscriptionsArgs<ExtArgs>
    UserSavedCourses?: boolean | Users$UserSavedCoursesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type UsersSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    first_name?: boolean
    last_name?: boolean
    headline?: boolean
    biography?: boolean
    photo_url?: boolean
    field_of_learning?: boolean
    occupation?: boolean
    skills?: boolean
    interests?: boolean
    resume_url?: boolean
    instructor_application_status?: boolean
    instructor_application_submitted_at?: boolean
    instructor_reviewed_at?: boolean
    instructor_admin_comment?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Certificates?: boolean | Users$CertificatesArgs<ExtArgs>
    Courses?: boolean | Users$CoursesArgs<ExtArgs>
    Enrollments?: boolean | Users$EnrollmentsArgs<ExtArgs>
    LessonProgress?: boolean | Users$LessonProgressArgs<ExtArgs>
    Messages_Messages_receiver_idToUsers?: boolean | Users$Messages_Messages_receiver_idToUsersArgs<ExtArgs>
    Messages_Messages_sender_idToUsers?: boolean | Users$Messages_Messages_sender_idToUsersArgs<ExtArgs>
    MultiFactorAuth?: boolean | Users$MultiFactorAuthArgs<ExtArgs>
    Notifications?: boolean | Users$NotificationsArgs<ExtArgs>
    Payments?: boolean | Users$PaymentsArgs<ExtArgs>
    QuizAttempts?: boolean | Users$QuizAttemptsArgs<ExtArgs>
    Reviews_Reviews_instructor_idToUsers?: boolean | Users$Reviews_Reviews_instructor_idToUsersArgs<ExtArgs>
    Reviews_Reviews_user_idToUsers?: boolean | Users$Reviews_Reviews_user_idToUsersArgs<ExtArgs>
    ShoppingCart?: boolean | Users$ShoppingCartArgs<ExtArgs>
    Subscriptions?: boolean | Users$SubscriptionsArgs<ExtArgs>
    UserSavedCourses?: boolean | Users$UserSavedCoursesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      Certificates: Prisma.$CertificatesPayload<ExtArgs>[]
      Courses: Prisma.$CoursesPayload<ExtArgs>[]
      Enrollments: Prisma.$EnrollmentsPayload<ExtArgs>[]
      LessonProgress: Prisma.$LessonProgressPayload<ExtArgs>[]
      Messages_Messages_receiver_idToUsers: Prisma.$MessagesPayload<ExtArgs>[]
      Messages_Messages_sender_idToUsers: Prisma.$MessagesPayload<ExtArgs>[]
      MultiFactorAuth: Prisma.$MultiFactorAuthPayload<ExtArgs>[]
      Notifications: Prisma.$NotificationsPayload<ExtArgs>[]
      Payments: Prisma.$PaymentsPayload<ExtArgs>[]
      QuizAttempts: Prisma.$QuizAttemptsPayload<ExtArgs>[]
      Reviews_Reviews_instructor_idToUsers: Prisma.$ReviewsPayload<ExtArgs>[]
      Reviews_Reviews_user_idToUsers: Prisma.$ReviewsPayload<ExtArgs>[]
      ShoppingCart: Prisma.$ShoppingCartPayload<ExtArgs>[]
      Subscriptions: Prisma.$SubscriptionsPayload<ExtArgs>[]
      UserSavedCourses: Prisma.$UserSavedCoursesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      email: string
      password_hash: string
      role: $Enums.Users_role
      first_name: string | null
      last_name: string | null
      headline: string | null
      biography: string | null
      photo_url: string | null
      field_of_learning: string | null
      occupation: string | null
      skills: Prisma.JsonValue | null
      interests: Prisma.JsonValue | null
      resume_url: string | null
      instructor_application_status: $Enums.Users_instructor_application_status
      instructor_application_submitted_at: Date | null
      instructor_reviewed_at: Date | null
      instructor_admin_comment: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends UsersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersCreateArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UsersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends UsersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends UsersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>
    ): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Certificates<T extends Users$CertificatesArgs<ExtArgs> = {}>(args?: Subset<T, Users$CertificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Courses<T extends Users$CoursesArgs<ExtArgs> = {}>(args?: Subset<T, Users$CoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Enrollments<T extends Users$EnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$EnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    LessonProgress<T extends Users$LessonProgressArgs<ExtArgs> = {}>(args?: Subset<T, Users$LessonProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, 'findMany'> | Null>;

    Messages_Messages_receiver_idToUsers<T extends Users$Messages_Messages_receiver_idToUsersArgs<ExtArgs> = {}>(args?: Subset<T, Users$Messages_Messages_receiver_idToUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Messages_Messages_sender_idToUsers<T extends Users$Messages_Messages_sender_idToUsersArgs<ExtArgs> = {}>(args?: Subset<T, Users$Messages_Messages_sender_idToUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, 'findMany'> | Null>;

    MultiFactorAuth<T extends Users$MultiFactorAuthArgs<ExtArgs> = {}>(args?: Subset<T, Users$MultiFactorAuthArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiFactorAuthPayload<ExtArgs>, T, 'findMany'> | Null>;

    Notifications<T extends Users$NotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Users$NotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Payments<T extends Users$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    QuizAttempts<T extends Users$QuizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Users$QuizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Reviews_Reviews_instructor_idToUsers<T extends Users$Reviews_Reviews_instructor_idToUsersArgs<ExtArgs> = {}>(args?: Subset<T, Users$Reviews_Reviews_instructor_idToUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Reviews_Reviews_user_idToUsers<T extends Users$Reviews_Reviews_user_idToUsersArgs<ExtArgs> = {}>(args?: Subset<T, Users$Reviews_Reviews_user_idToUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, 'findMany'> | Null>;

    ShoppingCart<T extends Users$ShoppingCartArgs<ExtArgs> = {}>(args?: Subset<T, Users$ShoppingCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingCartPayload<ExtArgs>, T, 'findMany'> | Null>;

    Subscriptions<T extends Users$SubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Users$SubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    UserSavedCourses<T extends Users$UserSavedCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Users$UserSavedCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSavedCoursesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'BigInt'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password_hash: FieldRef<"Users", 'String'>
    readonly role: FieldRef<"Users", 'Users_role'>
    readonly first_name: FieldRef<"Users", 'String'>
    readonly last_name: FieldRef<"Users", 'String'>
    readonly headline: FieldRef<"Users", 'String'>
    readonly biography: FieldRef<"Users", 'String'>
    readonly photo_url: FieldRef<"Users", 'String'>
    readonly field_of_learning: FieldRef<"Users", 'String'>
    readonly occupation: FieldRef<"Users", 'String'>
    readonly skills: FieldRef<"Users", 'Json'>
    readonly interests: FieldRef<"Users", 'Json'>
    readonly resume_url: FieldRef<"Users", 'String'>
    readonly instructor_application_status: FieldRef<"Users", 'Users_instructor_application_status'>
    readonly instructor_application_submitted_at: FieldRef<"Users", 'DateTime'>
    readonly instructor_reviewed_at: FieldRef<"Users", 'DateTime'>
    readonly instructor_admin_comment: FieldRef<"Users", 'String'>
    readonly created_at: FieldRef<"Users", 'DateTime'>
    readonly updated_at: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
  }

  /**
   * Users.Certificates
   */
  export type Users$CertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificates
     */
    select?: CertificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificatesInclude<ExtArgs> | null
    where?: CertificatesWhereInput
    orderBy?: CertificatesOrderByWithRelationInput | CertificatesOrderByWithRelationInput[]
    cursor?: CertificatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * Users.Courses
   */
  export type Users$CoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursesInclude<ExtArgs> | null
    where?: CoursesWhereInput
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    cursor?: CoursesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * Users.Enrollments
   */
  export type Users$EnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollments
     */
    select?: EnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentsInclude<ExtArgs> | null
    where?: EnrollmentsWhereInput
    orderBy?: EnrollmentsOrderByWithRelationInput | EnrollmentsOrderByWithRelationInput[]
    cursor?: EnrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * Users.LessonProgress
   */
  export type Users$LessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    cursor?: LessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * Users.Messages_Messages_receiver_idToUsers
   */
  export type Users$Messages_Messages_receiver_idToUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    cursor?: MessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Users.Messages_Messages_sender_idToUsers
   */
  export type Users$Messages_Messages_sender_idToUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    cursor?: MessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Users.MultiFactorAuth
   */
  export type Users$MultiFactorAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuth
     */
    select?: MultiFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthInclude<ExtArgs> | null
    where?: MultiFactorAuthWhereInput
    orderBy?: MultiFactorAuthOrderByWithRelationInput | MultiFactorAuthOrderByWithRelationInput[]
    cursor?: MultiFactorAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultiFactorAuthScalarFieldEnum | MultiFactorAuthScalarFieldEnum[]
  }

  /**
   * Users.Notifications
   */
  export type Users$NotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Users.Payments
   */
  export type Users$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Users.QuizAttempts
   */
  export type Users$QuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempts
     */
    select?: QuizAttemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptsInclude<ExtArgs> | null
    where?: QuizAttemptsWhereInput
    orderBy?: QuizAttemptsOrderByWithRelationInput | QuizAttemptsOrderByWithRelationInput[]
    cursor?: QuizAttemptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptsScalarFieldEnum | QuizAttemptsScalarFieldEnum[]
  }

  /**
   * Users.Reviews_Reviews_instructor_idToUsers
   */
  export type Users$Reviews_Reviews_instructor_idToUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    where?: ReviewsWhereInput
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    cursor?: ReviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Users.Reviews_Reviews_user_idToUsers
   */
  export type Users$Reviews_Reviews_user_idToUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    where?: ReviewsWhereInput
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    cursor?: ReviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Users.ShoppingCart
   */
  export type Users$ShoppingCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingCartInclude<ExtArgs> | null
    where?: ShoppingCartWhereInput
    orderBy?: ShoppingCartOrderByWithRelationInput | ShoppingCartOrderByWithRelationInput[]
    cursor?: ShoppingCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShoppingCartScalarFieldEnum | ShoppingCartScalarFieldEnum[]
  }

  /**
   * Users.Subscriptions
   */
  export type Users$SubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    where?: SubscriptionsWhereInput
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    cursor?: SubscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Users.UserSavedCourses
   */
  export type Users$UserSavedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedCourses
     */
    select?: UserSavedCoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedCoursesInclude<ExtArgs> | null
    where?: UserSavedCoursesWhereInput
    orderBy?: UserSavedCoursesOrderByWithRelationInput | UserSavedCoursesOrderByWithRelationInput[]
    cursor?: UserSavedCoursesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSavedCoursesScalarFieldEnum | UserSavedCoursesScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AssessmentOptionsScalarFieldEnum: {
    id: 'id',
    question_id: 'question_id',
    option_text: 'option_text',
    is_correct: 'is_correct'
  };

  export type AssessmentOptionsScalarFieldEnum = (typeof AssessmentOptionsScalarFieldEnum)[keyof typeof AssessmentOptionsScalarFieldEnum]


  export const AssessmentQuestionsScalarFieldEnum: {
    id: 'id',
    assessment_id: 'assessment_id',
    question_text: 'question_text',
    question_type: 'question_type'
  };

  export type AssessmentQuestionsScalarFieldEnum = (typeof AssessmentQuestionsScalarFieldEnum)[keyof typeof AssessmentQuestionsScalarFieldEnum]


  export const AssessmentsScalarFieldEnum: {
    id: 'id',
    content_id: 'content_id',
    title: 'title',
    instructions: 'instructions'
  };

  export type AssessmentsScalarFieldEnum = (typeof AssessmentsScalarFieldEnum)[keyof typeof AssessmentsScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const CertificatesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    course_id: 'course_id',
    certificate_url: 'certificate_url',
    issued_at: 'issued_at'
  };

  export type CertificatesScalarFieldEnum = (typeof CertificatesScalarFieldEnum)[keyof typeof CertificatesScalarFieldEnum]


  export const CourseContentScalarFieldEnum: {
    id: 'id',
    course_id: 'course_id',
    parent_id: 'parent_id',
    title: 'title',
    type: 'type',
    video_url: 'video_url',
    note_content: 'note_content',
    duration_seconds: 'duration_seconds',
    order_index: 'order_index'
  };

  export type CourseContentScalarFieldEnum = (typeof CourseContentScalarFieldEnum)[keyof typeof CourseContentScalarFieldEnum]


  export const CourseTagsScalarFieldEnum: {
    id: 'id',
    course_id: 'course_id',
    tag_name: 'tag_name',
    tag_type: 'tag_type'
  };

  export type CourseTagsScalarFieldEnum = (typeof CourseTagsScalarFieldEnum)[keyof typeof CourseTagsScalarFieldEnum]


  export const CoursesScalarFieldEnum: {
    id: 'id',
    instructor_id: 'instructor_id',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    category_id: 'category_id',
    price: 'price',
    thumbnail_url: 'thumbnail_url',
    level: 'level',
    views: 'views',
    enrollments_count: 'enrollments_count',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CoursesScalarFieldEnum = (typeof CoursesScalarFieldEnum)[keyof typeof CoursesScalarFieldEnum]


  export const EnrollmentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    course_id: 'course_id',
    enrolled_at: 'enrolled_at'
  };

  export type EnrollmentsScalarFieldEnum = (typeof EnrollmentsScalarFieldEnum)[keyof typeof EnrollmentsScalarFieldEnum]


  export const LessonProgressScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    content_id: 'content_id',
    is_completed: 'is_completed',
    completed_at: 'completed_at'
  };

  export type LessonProgressScalarFieldEnum = (typeof LessonProgressScalarFieldEnum)[keyof typeof LessonProgressScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    sender_id: 'sender_id',
    receiver_id: 'receiver_id',
    content: 'content',
    created_at: 'created_at'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const MultiFactorAuthScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    mfa_type: 'mfa_type',
    secret_key: 'secret_key',
    is_enabled: 'is_enabled',
    created_at: 'created_at'
  };

  export type MultiFactorAuthScalarFieldEnum = (typeof MultiFactorAuthScalarFieldEnum)[keyof typeof MultiFactorAuthScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    message: 'message',
    type: 'type',
    is_read: 'is_read',
    created_at: 'created_at'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    course_id: 'course_id',
    subscription_plan_id: 'subscription_plan_id',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    status: 'status',
    transaction_id: 'transaction_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const QuizAttemptsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    assessment_id: 'assessment_id',
    score: 'score',
    started_at: 'started_at',
    completed_at: 'completed_at'
  };

  export type QuizAttemptsScalarFieldEnum = (typeof QuizAttemptsScalarFieldEnum)[keyof typeof QuizAttemptsScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    course_id: 'course_id',
    instructor_id: 'instructor_id',
    rating: 'rating',
    review_text: 'review_text',
    created_at: 'created_at'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const ShoppingCartScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    course_id: 'course_id',
    added_at: 'added_at'
  };

  export type ShoppingCartScalarFieldEnum = (typeof ShoppingCartScalarFieldEnum)[keyof typeof ShoppingCartScalarFieldEnum]


  export const SubscriptionPlansScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    duration_days: 'duration_days',
    description: 'description'
  };

  export type SubscriptionPlansScalarFieldEnum = (typeof SubscriptionPlansScalarFieldEnum)[keyof typeof SubscriptionPlansScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    plan_id: 'plan_id',
    status: 'status',
    start_date: 'start_date',
    end_date: 'end_date'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const UserAnswersScalarFieldEnum: {
    id: 'id',
    attempt_id: 'attempt_id',
    question_id: 'question_id',
    selected_option_id: 'selected_option_id',
    answer_text: 'answer_text'
  };

  export type UserAnswersScalarFieldEnum = (typeof UserAnswersScalarFieldEnum)[keyof typeof UserAnswersScalarFieldEnum]


  export const UserSavedCoursesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    course_id: 'course_id'
  };

  export type UserSavedCoursesScalarFieldEnum = (typeof UserSavedCoursesScalarFieldEnum)[keyof typeof UserSavedCoursesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    first_name: 'first_name',
    last_name: 'last_name',
    headline: 'headline',
    biography: 'biography',
    photo_url: 'photo_url',
    field_of_learning: 'field_of_learning',
    occupation: 'occupation',
    skills: 'skills',
    interests: 'interests',
    resume_url: 'resume_url',
    instructor_application_status: 'instructor_application_status',
    instructor_application_submitted_at: 'instructor_application_submitted_at',
    instructor_reviewed_at: 'instructor_reviewed_at',
    instructor_admin_comment: 'instructor_admin_comment',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AssessmentQuestions_question_type'
   */
  export type EnumAssessmentQuestions_question_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentQuestions_question_type'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'CourseContent_type'
   */
  export type EnumCourseContent_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseContent_type'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'CourseTags_tag_type'
   */
  export type EnumCourseTags_tag_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseTags_tag_type'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Courses_level'
   */
  export type EnumCourses_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Courses_level'>
    


  /**
   * Reference to a field of type 'MultiFactorAuth_mfa_type'
   */
  export type EnumMultiFactorAuth_mfa_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MultiFactorAuth_mfa_type'>
    


  /**
   * Reference to a field of type 'Notifications_type'
   */
  export type EnumNotifications_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Notifications_type'>
    


  /**
   * Reference to a field of type 'Payments_method'
   */
  export type EnumPayments_methodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Payments_method'>
    


  /**
   * Reference to a field of type 'Payments_status'
   */
  export type EnumPayments_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Payments_status'>
    


  /**
   * Reference to a field of type 'Subscriptions_status'
   */
  export type EnumSubscriptions_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Subscriptions_status'>
    


  /**
   * Reference to a field of type 'Users_role'
   */
  export type EnumUsers_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Users_role'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Users_instructor_application_status'
   */
  export type EnumUsers_instructor_application_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Users_instructor_application_status'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AssessmentOptionsWhereInput = {
    AND?: AssessmentOptionsWhereInput | AssessmentOptionsWhereInput[]
    OR?: AssessmentOptionsWhereInput[]
    NOT?: AssessmentOptionsWhereInput | AssessmentOptionsWhereInput[]
    id?: BigIntFilter<"AssessmentOptions"> | bigint | number
    question_id?: BigIntFilter<"AssessmentOptions"> | bigint | number
    option_text?: StringNullableFilter<"AssessmentOptions"> | string | null
    is_correct?: BoolNullableFilter<"AssessmentOptions"> | boolean | null
    AssessmentQuestions?: XOR<AssessmentQuestionsRelationFilter, AssessmentQuestionsWhereInput>
    UserAnswers?: UserAnswersListRelationFilter
  }

  export type AssessmentOptionsOrderByWithRelationInput = {
    id?: SortOrder
    question_id?: SortOrder
    option_text?: SortOrderInput | SortOrder
    is_correct?: SortOrderInput | SortOrder
    AssessmentQuestions?: AssessmentQuestionsOrderByWithRelationInput
    UserAnswers?: UserAnswersOrderByRelationAggregateInput
  }

  export type AssessmentOptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AssessmentOptionsWhereInput | AssessmentOptionsWhereInput[]
    OR?: AssessmentOptionsWhereInput[]
    NOT?: AssessmentOptionsWhereInput | AssessmentOptionsWhereInput[]
    question_id?: BigIntFilter<"AssessmentOptions"> | bigint | number
    option_text?: StringNullableFilter<"AssessmentOptions"> | string | null
    is_correct?: BoolNullableFilter<"AssessmentOptions"> | boolean | null
    AssessmentQuestions?: XOR<AssessmentQuestionsRelationFilter, AssessmentQuestionsWhereInput>
    UserAnswers?: UserAnswersListRelationFilter
  }, "id">

  export type AssessmentOptionsOrderByWithAggregationInput = {
    id?: SortOrder
    question_id?: SortOrder
    option_text?: SortOrderInput | SortOrder
    is_correct?: SortOrderInput | SortOrder
    _count?: AssessmentOptionsCountOrderByAggregateInput
    _avg?: AssessmentOptionsAvgOrderByAggregateInput
    _max?: AssessmentOptionsMaxOrderByAggregateInput
    _min?: AssessmentOptionsMinOrderByAggregateInput
    _sum?: AssessmentOptionsSumOrderByAggregateInput
  }

  export type AssessmentOptionsScalarWhereWithAggregatesInput = {
    AND?: AssessmentOptionsScalarWhereWithAggregatesInput | AssessmentOptionsScalarWhereWithAggregatesInput[]
    OR?: AssessmentOptionsScalarWhereWithAggregatesInput[]
    NOT?: AssessmentOptionsScalarWhereWithAggregatesInput | AssessmentOptionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"AssessmentOptions"> | bigint | number
    question_id?: BigIntWithAggregatesFilter<"AssessmentOptions"> | bigint | number
    option_text?: StringNullableWithAggregatesFilter<"AssessmentOptions"> | string | null
    is_correct?: BoolNullableWithAggregatesFilter<"AssessmentOptions"> | boolean | null
  }

  export type AssessmentQuestionsWhereInput = {
    AND?: AssessmentQuestionsWhereInput | AssessmentQuestionsWhereInput[]
    OR?: AssessmentQuestionsWhereInput[]
    NOT?: AssessmentQuestionsWhereInput | AssessmentQuestionsWhereInput[]
    id?: BigIntFilter<"AssessmentQuestions"> | bigint | number
    assessment_id?: BigIntFilter<"AssessmentQuestions"> | bigint | number
    question_text?: StringFilter<"AssessmentQuestions"> | string
    question_type?: EnumAssessmentQuestions_question_typeFilter<"AssessmentQuestions"> | $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsListRelationFilter
    Assessments?: XOR<AssessmentsRelationFilter, AssessmentsWhereInput>
    UserAnswers?: UserAnswersListRelationFilter
  }

  export type AssessmentQuestionsOrderByWithRelationInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    AssessmentOptions?: AssessmentOptionsOrderByRelationAggregateInput
    Assessments?: AssessmentsOrderByWithRelationInput
    UserAnswers?: UserAnswersOrderByRelationAggregateInput
  }

  export type AssessmentQuestionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AssessmentQuestionsWhereInput | AssessmentQuestionsWhereInput[]
    OR?: AssessmentQuestionsWhereInput[]
    NOT?: AssessmentQuestionsWhereInput | AssessmentQuestionsWhereInput[]
    assessment_id?: BigIntFilter<"AssessmentQuestions"> | bigint | number
    question_text?: StringFilter<"AssessmentQuestions"> | string
    question_type?: EnumAssessmentQuestions_question_typeFilter<"AssessmentQuestions"> | $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsListRelationFilter
    Assessments?: XOR<AssessmentsRelationFilter, AssessmentsWhereInput>
    UserAnswers?: UserAnswersListRelationFilter
  }, "id">

  export type AssessmentQuestionsOrderByWithAggregationInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    _count?: AssessmentQuestionsCountOrderByAggregateInput
    _avg?: AssessmentQuestionsAvgOrderByAggregateInput
    _max?: AssessmentQuestionsMaxOrderByAggregateInput
    _min?: AssessmentQuestionsMinOrderByAggregateInput
    _sum?: AssessmentQuestionsSumOrderByAggregateInput
  }

  export type AssessmentQuestionsScalarWhereWithAggregatesInput = {
    AND?: AssessmentQuestionsScalarWhereWithAggregatesInput | AssessmentQuestionsScalarWhereWithAggregatesInput[]
    OR?: AssessmentQuestionsScalarWhereWithAggregatesInput[]
    NOT?: AssessmentQuestionsScalarWhereWithAggregatesInput | AssessmentQuestionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"AssessmentQuestions"> | bigint | number
    assessment_id?: BigIntWithAggregatesFilter<"AssessmentQuestions"> | bigint | number
    question_text?: StringWithAggregatesFilter<"AssessmentQuestions"> | string
    question_type?: EnumAssessmentQuestions_question_typeWithAggregatesFilter<"AssessmentQuestions"> | $Enums.AssessmentQuestions_question_type
  }

  export type AssessmentsWhereInput = {
    AND?: AssessmentsWhereInput | AssessmentsWhereInput[]
    OR?: AssessmentsWhereInput[]
    NOT?: AssessmentsWhereInput | AssessmentsWhereInput[]
    id?: BigIntFilter<"Assessments"> | bigint | number
    content_id?: BigIntFilter<"Assessments"> | bigint | number
    title?: StringNullableFilter<"Assessments"> | string | null
    instructions?: StringNullableFilter<"Assessments"> | string | null
    AssessmentQuestions?: AssessmentQuestionsListRelationFilter
    CourseContent?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    QuizAttempts?: QuizAttemptsListRelationFilter
  }

  export type AssessmentsOrderByWithRelationInput = {
    id?: SortOrder
    content_id?: SortOrder
    title?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    AssessmentQuestions?: AssessmentQuestionsOrderByRelationAggregateInput
    CourseContent?: CourseContentOrderByWithRelationInput
    QuizAttempts?: QuizAttemptsOrderByRelationAggregateInput
  }

  export type AssessmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AssessmentsWhereInput | AssessmentsWhereInput[]
    OR?: AssessmentsWhereInput[]
    NOT?: AssessmentsWhereInput | AssessmentsWhereInput[]
    content_id?: BigIntFilter<"Assessments"> | bigint | number
    title?: StringNullableFilter<"Assessments"> | string | null
    instructions?: StringNullableFilter<"Assessments"> | string | null
    AssessmentQuestions?: AssessmentQuestionsListRelationFilter
    CourseContent?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    QuizAttempts?: QuizAttemptsListRelationFilter
  }, "id">

  export type AssessmentsOrderByWithAggregationInput = {
    id?: SortOrder
    content_id?: SortOrder
    title?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    _count?: AssessmentsCountOrderByAggregateInput
    _avg?: AssessmentsAvgOrderByAggregateInput
    _max?: AssessmentsMaxOrderByAggregateInput
    _min?: AssessmentsMinOrderByAggregateInput
    _sum?: AssessmentsSumOrderByAggregateInput
  }

  export type AssessmentsScalarWhereWithAggregatesInput = {
    AND?: AssessmentsScalarWhereWithAggregatesInput | AssessmentsScalarWhereWithAggregatesInput[]
    OR?: AssessmentsScalarWhereWithAggregatesInput[]
    NOT?: AssessmentsScalarWhereWithAggregatesInput | AssessmentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Assessments"> | bigint | number
    content_id?: BigIntWithAggregatesFilter<"Assessments"> | bigint | number
    title?: StringNullableWithAggregatesFilter<"Assessments"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"Assessments"> | string | null
  }

  export type CategoriesWhereInput = {
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    id?: BigIntFilter<"Categories"> | bigint | number
    name?: StringFilter<"Categories"> | string
    Courses?: CoursesListRelationFilter
  }

  export type CategoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    Courses?: CoursesOrderByRelationAggregateInput
  }

  export type CategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    name?: StringFilter<"Categories"> | string
    Courses?: CoursesListRelationFilter
  }, "id">

  export type CategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoriesCountOrderByAggregateInput
    _avg?: CategoriesAvgOrderByAggregateInput
    _max?: CategoriesMaxOrderByAggregateInput
    _min?: CategoriesMinOrderByAggregateInput
    _sum?: CategoriesSumOrderByAggregateInput
  }

  export type CategoriesScalarWhereWithAggregatesInput = {
    AND?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    OR?: CategoriesScalarWhereWithAggregatesInput[]
    NOT?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Categories"> | bigint | number
    name?: StringWithAggregatesFilter<"Categories"> | string
  }

  export type CertificatesWhereInput = {
    AND?: CertificatesWhereInput | CertificatesWhereInput[]
    OR?: CertificatesWhereInput[]
    NOT?: CertificatesWhereInput | CertificatesWhereInput[]
    id?: BigIntFilter<"Certificates"> | bigint | number
    user_id?: BigIntFilter<"Certificates"> | bigint | number
    course_id?: BigIntFilter<"Certificates"> | bigint | number
    certificate_url?: StringNullableFilter<"Certificates"> | string | null
    issued_at?: DateTimeNullableFilter<"Certificates"> | Date | string | null
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type CertificatesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    certificate_url?: SortOrderInput | SortOrder
    issued_at?: SortOrderInput | SortOrder
    Courses?: CoursesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type CertificatesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: CertificatesWhereInput | CertificatesWhereInput[]
    OR?: CertificatesWhereInput[]
    NOT?: CertificatesWhereInput | CertificatesWhereInput[]
    user_id?: BigIntFilter<"Certificates"> | bigint | number
    course_id?: BigIntFilter<"Certificates"> | bigint | number
    certificate_url?: StringNullableFilter<"Certificates"> | string | null
    issued_at?: DateTimeNullableFilter<"Certificates"> | Date | string | null
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type CertificatesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    certificate_url?: SortOrderInput | SortOrder
    issued_at?: SortOrderInput | SortOrder
    _count?: CertificatesCountOrderByAggregateInput
    _avg?: CertificatesAvgOrderByAggregateInput
    _max?: CertificatesMaxOrderByAggregateInput
    _min?: CertificatesMinOrderByAggregateInput
    _sum?: CertificatesSumOrderByAggregateInput
  }

  export type CertificatesScalarWhereWithAggregatesInput = {
    AND?: CertificatesScalarWhereWithAggregatesInput | CertificatesScalarWhereWithAggregatesInput[]
    OR?: CertificatesScalarWhereWithAggregatesInput[]
    NOT?: CertificatesScalarWhereWithAggregatesInput | CertificatesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Certificates"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"Certificates"> | bigint | number
    course_id?: BigIntWithAggregatesFilter<"Certificates"> | bigint | number
    certificate_url?: StringNullableWithAggregatesFilter<"Certificates"> | string | null
    issued_at?: DateTimeNullableWithAggregatesFilter<"Certificates"> | Date | string | null
  }

  export type CourseContentWhereInput = {
    AND?: CourseContentWhereInput | CourseContentWhereInput[]
    OR?: CourseContentWhereInput[]
    NOT?: CourseContentWhereInput | CourseContentWhereInput[]
    id?: BigIntFilter<"CourseContent"> | bigint | number
    course_id?: BigIntFilter<"CourseContent"> | bigint | number
    parent_id?: BigIntNullableFilter<"CourseContent"> | bigint | number | null
    title?: StringFilter<"CourseContent"> | string
    type?: EnumCourseContent_typeFilter<"CourseContent"> | $Enums.CourseContent_type
    video_url?: StringNullableFilter<"CourseContent"> | string | null
    note_content?: StringNullableFilter<"CourseContent"> | string | null
    duration_seconds?: IntNullableFilter<"CourseContent"> | number | null
    order_index?: IntFilter<"CourseContent"> | number
    Assessments?: AssessmentsListRelationFilter
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    CourseContent?: XOR<CourseContentNullableRelationFilter, CourseContentWhereInput> | null
    other_CourseContent?: CourseContentListRelationFilter
    LessonProgress?: LessonProgressListRelationFilter
  }

  export type CourseContentOrderByWithRelationInput = {
    id?: SortOrder
    course_id?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    title?: SortOrder
    type?: SortOrder
    video_url?: SortOrderInput | SortOrder
    note_content?: SortOrderInput | SortOrder
    duration_seconds?: SortOrderInput | SortOrder
    order_index?: SortOrder
    Assessments?: AssessmentsOrderByRelationAggregateInput
    Courses?: CoursesOrderByWithRelationInput
    CourseContent?: CourseContentOrderByWithRelationInput
    other_CourseContent?: CourseContentOrderByRelationAggregateInput
    LessonProgress?: LessonProgressOrderByRelationAggregateInput
  }

  export type CourseContentWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: CourseContentWhereInput | CourseContentWhereInput[]
    OR?: CourseContentWhereInput[]
    NOT?: CourseContentWhereInput | CourseContentWhereInput[]
    course_id?: BigIntFilter<"CourseContent"> | bigint | number
    parent_id?: BigIntNullableFilter<"CourseContent"> | bigint | number | null
    title?: StringFilter<"CourseContent"> | string
    type?: EnumCourseContent_typeFilter<"CourseContent"> | $Enums.CourseContent_type
    video_url?: StringNullableFilter<"CourseContent"> | string | null
    note_content?: StringNullableFilter<"CourseContent"> | string | null
    duration_seconds?: IntNullableFilter<"CourseContent"> | number | null
    order_index?: IntFilter<"CourseContent"> | number
    Assessments?: AssessmentsListRelationFilter
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    CourseContent?: XOR<CourseContentNullableRelationFilter, CourseContentWhereInput> | null
    other_CourseContent?: CourseContentListRelationFilter
    LessonProgress?: LessonProgressListRelationFilter
  }, "id">

  export type CourseContentOrderByWithAggregationInput = {
    id?: SortOrder
    course_id?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    title?: SortOrder
    type?: SortOrder
    video_url?: SortOrderInput | SortOrder
    note_content?: SortOrderInput | SortOrder
    duration_seconds?: SortOrderInput | SortOrder
    order_index?: SortOrder
    _count?: CourseContentCountOrderByAggregateInput
    _avg?: CourseContentAvgOrderByAggregateInput
    _max?: CourseContentMaxOrderByAggregateInput
    _min?: CourseContentMinOrderByAggregateInput
    _sum?: CourseContentSumOrderByAggregateInput
  }

  export type CourseContentScalarWhereWithAggregatesInput = {
    AND?: CourseContentScalarWhereWithAggregatesInput | CourseContentScalarWhereWithAggregatesInput[]
    OR?: CourseContentScalarWhereWithAggregatesInput[]
    NOT?: CourseContentScalarWhereWithAggregatesInput | CourseContentScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"CourseContent"> | bigint | number
    course_id?: BigIntWithAggregatesFilter<"CourseContent"> | bigint | number
    parent_id?: BigIntNullableWithAggregatesFilter<"CourseContent"> | bigint | number | null
    title?: StringWithAggregatesFilter<"CourseContent"> | string
    type?: EnumCourseContent_typeWithAggregatesFilter<"CourseContent"> | $Enums.CourseContent_type
    video_url?: StringNullableWithAggregatesFilter<"CourseContent"> | string | null
    note_content?: StringNullableWithAggregatesFilter<"CourseContent"> | string | null
    duration_seconds?: IntNullableWithAggregatesFilter<"CourseContent"> | number | null
    order_index?: IntWithAggregatesFilter<"CourseContent"> | number
  }

  export type CourseTagsWhereInput = {
    AND?: CourseTagsWhereInput | CourseTagsWhereInput[]
    OR?: CourseTagsWhereInput[]
    NOT?: CourseTagsWhereInput | CourseTagsWhereInput[]
    id?: BigIntFilter<"CourseTags"> | bigint | number
    course_id?: BigIntFilter<"CourseTags"> | bigint | number
    tag_name?: StringFilter<"CourseTags"> | string
    tag_type?: EnumCourseTags_tag_typeFilter<"CourseTags"> | $Enums.CourseTags_tag_type
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
  }

  export type CourseTagsOrderByWithRelationInput = {
    id?: SortOrder
    course_id?: SortOrder
    tag_name?: SortOrder
    tag_type?: SortOrder
    Courses?: CoursesOrderByWithRelationInput
  }

  export type CourseTagsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: CourseTagsWhereInput | CourseTagsWhereInput[]
    OR?: CourseTagsWhereInput[]
    NOT?: CourseTagsWhereInput | CourseTagsWhereInput[]
    course_id?: BigIntFilter<"CourseTags"> | bigint | number
    tag_name?: StringFilter<"CourseTags"> | string
    tag_type?: EnumCourseTags_tag_typeFilter<"CourseTags"> | $Enums.CourseTags_tag_type
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
  }, "id">

  export type CourseTagsOrderByWithAggregationInput = {
    id?: SortOrder
    course_id?: SortOrder
    tag_name?: SortOrder
    tag_type?: SortOrder
    _count?: CourseTagsCountOrderByAggregateInput
    _avg?: CourseTagsAvgOrderByAggregateInput
    _max?: CourseTagsMaxOrderByAggregateInput
    _min?: CourseTagsMinOrderByAggregateInput
    _sum?: CourseTagsSumOrderByAggregateInput
  }

  export type CourseTagsScalarWhereWithAggregatesInput = {
    AND?: CourseTagsScalarWhereWithAggregatesInput | CourseTagsScalarWhereWithAggregatesInput[]
    OR?: CourseTagsScalarWhereWithAggregatesInput[]
    NOT?: CourseTagsScalarWhereWithAggregatesInput | CourseTagsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"CourseTags"> | bigint | number
    course_id?: BigIntWithAggregatesFilter<"CourseTags"> | bigint | number
    tag_name?: StringWithAggregatesFilter<"CourseTags"> | string
    tag_type?: EnumCourseTags_tag_typeWithAggregatesFilter<"CourseTags"> | $Enums.CourseTags_tag_type
  }

  export type CoursesWhereInput = {
    AND?: CoursesWhereInput | CoursesWhereInput[]
    OR?: CoursesWhereInput[]
    NOT?: CoursesWhereInput | CoursesWhereInput[]
    id?: BigIntFilter<"Courses"> | bigint | number
    instructor_id?: BigIntFilter<"Courses"> | bigint | number
    title?: StringFilter<"Courses"> | string
    subtitle?: StringNullableFilter<"Courses"> | string | null
    description?: StringNullableFilter<"Courses"> | string | null
    category_id?: BigIntFilter<"Courses"> | bigint | number
    price?: DecimalNullableFilter<"Courses"> | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: StringNullableFilter<"Courses"> | string | null
    level?: EnumCourses_levelFilter<"Courses"> | $Enums.Courses_level
    views?: IntNullableFilter<"Courses"> | number | null
    enrollments_count?: IntNullableFilter<"Courses"> | number | null
    created_at?: DateTimeNullableFilter<"Courses"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"Courses"> | Date | string | null
    Certificates?: CertificatesListRelationFilter
    CourseContent?: CourseContentListRelationFilter
    CourseTags?: CourseTagsListRelationFilter
    Categories?: XOR<CategoriesRelationFilter, CategoriesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
    Enrollments?: EnrollmentsListRelationFilter
    Payments?: PaymentsListRelationFilter
    Reviews?: ReviewsListRelationFilter
    ShoppingCart?: ShoppingCartListRelationFilter
    UserSavedCourses?: UserSavedCoursesListRelationFilter
  }

  export type CoursesOrderByWithRelationInput = {
    id?: SortOrder
    instructor_id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category_id?: SortOrder
    price?: SortOrderInput | SortOrder
    thumbnail_url?: SortOrderInput | SortOrder
    level?: SortOrder
    views?: SortOrderInput | SortOrder
    enrollments_count?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    Certificates?: CertificatesOrderByRelationAggregateInput
    CourseContent?: CourseContentOrderByRelationAggregateInput
    CourseTags?: CourseTagsOrderByRelationAggregateInput
    Categories?: CategoriesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    Enrollments?: EnrollmentsOrderByRelationAggregateInput
    Payments?: PaymentsOrderByRelationAggregateInput
    Reviews?: ReviewsOrderByRelationAggregateInput
    ShoppingCart?: ShoppingCartOrderByRelationAggregateInput
    UserSavedCourses?: UserSavedCoursesOrderByRelationAggregateInput
  }

  export type CoursesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: CoursesWhereInput | CoursesWhereInput[]
    OR?: CoursesWhereInput[]
    NOT?: CoursesWhereInput | CoursesWhereInput[]
    instructor_id?: BigIntFilter<"Courses"> | bigint | number
    title?: StringFilter<"Courses"> | string
    subtitle?: StringNullableFilter<"Courses"> | string | null
    description?: StringNullableFilter<"Courses"> | string | null
    category_id?: BigIntFilter<"Courses"> | bigint | number
    price?: DecimalNullableFilter<"Courses"> | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: StringNullableFilter<"Courses"> | string | null
    level?: EnumCourses_levelFilter<"Courses"> | $Enums.Courses_level
    views?: IntNullableFilter<"Courses"> | number | null
    enrollments_count?: IntNullableFilter<"Courses"> | number | null
    created_at?: DateTimeNullableFilter<"Courses"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"Courses"> | Date | string | null
    Certificates?: CertificatesListRelationFilter
    CourseContent?: CourseContentListRelationFilter
    CourseTags?: CourseTagsListRelationFilter
    Categories?: XOR<CategoriesRelationFilter, CategoriesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
    Enrollments?: EnrollmentsListRelationFilter
    Payments?: PaymentsListRelationFilter
    Reviews?: ReviewsListRelationFilter
    ShoppingCart?: ShoppingCartListRelationFilter
    UserSavedCourses?: UserSavedCoursesListRelationFilter
  }, "id">

  export type CoursesOrderByWithAggregationInput = {
    id?: SortOrder
    instructor_id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category_id?: SortOrder
    price?: SortOrderInput | SortOrder
    thumbnail_url?: SortOrderInput | SortOrder
    level?: SortOrder
    views?: SortOrderInput | SortOrder
    enrollments_count?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: CoursesCountOrderByAggregateInput
    _avg?: CoursesAvgOrderByAggregateInput
    _max?: CoursesMaxOrderByAggregateInput
    _min?: CoursesMinOrderByAggregateInput
    _sum?: CoursesSumOrderByAggregateInput
  }

  export type CoursesScalarWhereWithAggregatesInput = {
    AND?: CoursesScalarWhereWithAggregatesInput | CoursesScalarWhereWithAggregatesInput[]
    OR?: CoursesScalarWhereWithAggregatesInput[]
    NOT?: CoursesScalarWhereWithAggregatesInput | CoursesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Courses"> | bigint | number
    instructor_id?: BigIntWithAggregatesFilter<"Courses"> | bigint | number
    title?: StringWithAggregatesFilter<"Courses"> | string
    subtitle?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    description?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    category_id?: BigIntWithAggregatesFilter<"Courses"> | bigint | number
    price?: DecimalNullableWithAggregatesFilter<"Courses"> | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    level?: EnumCourses_levelWithAggregatesFilter<"Courses"> | $Enums.Courses_level
    views?: IntNullableWithAggregatesFilter<"Courses"> | number | null
    enrollments_count?: IntNullableWithAggregatesFilter<"Courses"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"Courses"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"Courses"> | Date | string | null
  }

  export type EnrollmentsWhereInput = {
    AND?: EnrollmentsWhereInput | EnrollmentsWhereInput[]
    OR?: EnrollmentsWhereInput[]
    NOT?: EnrollmentsWhereInput | EnrollmentsWhereInput[]
    id?: BigIntFilter<"Enrollments"> | bigint | number
    user_id?: BigIntFilter<"Enrollments"> | bigint | number
    course_id?: BigIntFilter<"Enrollments"> | bigint | number
    enrolled_at?: DateTimeNullableFilter<"Enrollments"> | Date | string | null
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type EnrollmentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    enrolled_at?: SortOrderInput | SortOrder
    Courses?: CoursesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type EnrollmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: EnrollmentsWhereInput | EnrollmentsWhereInput[]
    OR?: EnrollmentsWhereInput[]
    NOT?: EnrollmentsWhereInput | EnrollmentsWhereInput[]
    user_id?: BigIntFilter<"Enrollments"> | bigint | number
    course_id?: BigIntFilter<"Enrollments"> | bigint | number
    enrolled_at?: DateTimeNullableFilter<"Enrollments"> | Date | string | null
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type EnrollmentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    enrolled_at?: SortOrderInput | SortOrder
    _count?: EnrollmentsCountOrderByAggregateInput
    _avg?: EnrollmentsAvgOrderByAggregateInput
    _max?: EnrollmentsMaxOrderByAggregateInput
    _min?: EnrollmentsMinOrderByAggregateInput
    _sum?: EnrollmentsSumOrderByAggregateInput
  }

  export type EnrollmentsScalarWhereWithAggregatesInput = {
    AND?: EnrollmentsScalarWhereWithAggregatesInput | EnrollmentsScalarWhereWithAggregatesInput[]
    OR?: EnrollmentsScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentsScalarWhereWithAggregatesInput | EnrollmentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Enrollments"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"Enrollments"> | bigint | number
    course_id?: BigIntWithAggregatesFilter<"Enrollments"> | bigint | number
    enrolled_at?: DateTimeNullableWithAggregatesFilter<"Enrollments"> | Date | string | null
  }

  export type LessonProgressWhereInput = {
    AND?: LessonProgressWhereInput | LessonProgressWhereInput[]
    OR?: LessonProgressWhereInput[]
    NOT?: LessonProgressWhereInput | LessonProgressWhereInput[]
    id?: BigIntFilter<"LessonProgress"> | bigint | number
    user_id?: BigIntFilter<"LessonProgress"> | bigint | number
    content_id?: BigIntFilter<"LessonProgress"> | bigint | number
    is_completed?: BoolNullableFilter<"LessonProgress"> | boolean | null
    completed_at?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    CourseContent?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type LessonProgressOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    content_id?: SortOrder
    is_completed?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    CourseContent?: CourseContentOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type LessonProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: LessonProgressWhereInput | LessonProgressWhereInput[]
    OR?: LessonProgressWhereInput[]
    NOT?: LessonProgressWhereInput | LessonProgressWhereInput[]
    user_id?: BigIntFilter<"LessonProgress"> | bigint | number
    content_id?: BigIntFilter<"LessonProgress"> | bigint | number
    is_completed?: BoolNullableFilter<"LessonProgress"> | boolean | null
    completed_at?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
    CourseContent?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type LessonProgressOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    content_id?: SortOrder
    is_completed?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    _count?: LessonProgressCountOrderByAggregateInput
    _avg?: LessonProgressAvgOrderByAggregateInput
    _max?: LessonProgressMaxOrderByAggregateInput
    _min?: LessonProgressMinOrderByAggregateInput
    _sum?: LessonProgressSumOrderByAggregateInput
  }

  export type LessonProgressScalarWhereWithAggregatesInput = {
    AND?: LessonProgressScalarWhereWithAggregatesInput | LessonProgressScalarWhereWithAggregatesInput[]
    OR?: LessonProgressScalarWhereWithAggregatesInput[]
    NOT?: LessonProgressScalarWhereWithAggregatesInput | LessonProgressScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"LessonProgress"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"LessonProgress"> | bigint | number
    content_id?: BigIntWithAggregatesFilter<"LessonProgress"> | bigint | number
    is_completed?: BoolNullableWithAggregatesFilter<"LessonProgress"> | boolean | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"LessonProgress"> | Date | string | null
  }

  export type MessagesWhereInput = {
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    id?: BigIntFilter<"Messages"> | bigint | number
    sender_id?: BigIntFilter<"Messages"> | bigint | number
    receiver_id?: BigIntFilter<"Messages"> | bigint | number
    content?: StringFilter<"Messages"> | string
    created_at?: DateTimeNullableFilter<"Messages"> | Date | string | null
    Users_Messages_receiver_idToUsers?: XOR<UsersRelationFilter, UsersWhereInput>
    Users_Messages_sender_idToUsers?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type MessagesOrderByWithRelationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrderInput | SortOrder
    Users_Messages_receiver_idToUsers?: UsersOrderByWithRelationInput
    Users_Messages_sender_idToUsers?: UsersOrderByWithRelationInput
  }

  export type MessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    sender_id?: BigIntFilter<"Messages"> | bigint | number
    receiver_id?: BigIntFilter<"Messages"> | bigint | number
    content?: StringFilter<"Messages"> | string
    created_at?: DateTimeNullableFilter<"Messages"> | Date | string | null
    Users_Messages_receiver_idToUsers?: XOR<UsersRelationFilter, UsersWhereInput>
    Users_Messages_sender_idToUsers?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type MessagesOrderByWithAggregationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: MessagesCountOrderByAggregateInput
    _avg?: MessagesAvgOrderByAggregateInput
    _max?: MessagesMaxOrderByAggregateInput
    _min?: MessagesMinOrderByAggregateInput
    _sum?: MessagesSumOrderByAggregateInput
  }

  export type MessagesScalarWhereWithAggregatesInput = {
    AND?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    OR?: MessagesScalarWhereWithAggregatesInput[]
    NOT?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Messages"> | bigint | number
    sender_id?: BigIntWithAggregatesFilter<"Messages"> | bigint | number
    receiver_id?: BigIntWithAggregatesFilter<"Messages"> | bigint | number
    content?: StringWithAggregatesFilter<"Messages"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"Messages"> | Date | string | null
  }

  export type MultiFactorAuthWhereInput = {
    AND?: MultiFactorAuthWhereInput | MultiFactorAuthWhereInput[]
    OR?: MultiFactorAuthWhereInput[]
    NOT?: MultiFactorAuthWhereInput | MultiFactorAuthWhereInput[]
    id?: BigIntFilter<"MultiFactorAuth"> | bigint | number
    user_id?: BigIntFilter<"MultiFactorAuth"> | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFilter<"MultiFactorAuth"> | $Enums.MultiFactorAuth_mfa_type
    secret_key?: StringNullableFilter<"MultiFactorAuth"> | string | null
    is_enabled?: BoolNullableFilter<"MultiFactorAuth"> | boolean | null
    created_at?: DateTimeNullableFilter<"MultiFactorAuth"> | Date | string | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type MultiFactorAuthOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    mfa_type?: SortOrder
    secret_key?: SortOrderInput | SortOrder
    is_enabled?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type MultiFactorAuthWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MultiFactorAuthWhereInput | MultiFactorAuthWhereInput[]
    OR?: MultiFactorAuthWhereInput[]
    NOT?: MultiFactorAuthWhereInput | MultiFactorAuthWhereInput[]
    user_id?: BigIntFilter<"MultiFactorAuth"> | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFilter<"MultiFactorAuth"> | $Enums.MultiFactorAuth_mfa_type
    secret_key?: StringNullableFilter<"MultiFactorAuth"> | string | null
    is_enabled?: BoolNullableFilter<"MultiFactorAuth"> | boolean | null
    created_at?: DateTimeNullableFilter<"MultiFactorAuth"> | Date | string | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type MultiFactorAuthOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    mfa_type?: SortOrder
    secret_key?: SortOrderInput | SortOrder
    is_enabled?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: MultiFactorAuthCountOrderByAggregateInput
    _avg?: MultiFactorAuthAvgOrderByAggregateInput
    _max?: MultiFactorAuthMaxOrderByAggregateInput
    _min?: MultiFactorAuthMinOrderByAggregateInput
    _sum?: MultiFactorAuthSumOrderByAggregateInput
  }

  export type MultiFactorAuthScalarWhereWithAggregatesInput = {
    AND?: MultiFactorAuthScalarWhereWithAggregatesInput | MultiFactorAuthScalarWhereWithAggregatesInput[]
    OR?: MultiFactorAuthScalarWhereWithAggregatesInput[]
    NOT?: MultiFactorAuthScalarWhereWithAggregatesInput | MultiFactorAuthScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"MultiFactorAuth"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"MultiFactorAuth"> | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeWithAggregatesFilter<"MultiFactorAuth"> | $Enums.MultiFactorAuth_mfa_type
    secret_key?: StringNullableWithAggregatesFilter<"MultiFactorAuth"> | string | null
    is_enabled?: BoolNullableWithAggregatesFilter<"MultiFactorAuth"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"MultiFactorAuth"> | Date | string | null
  }

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    id?: BigIntFilter<"Notifications"> | bigint | number
    user_id?: BigIntFilter<"Notifications"> | bigint | number
    message?: StringFilter<"Notifications"> | string
    type?: EnumNotifications_typeNullableFilter<"Notifications"> | $Enums.Notifications_type | null
    is_read?: BoolNullableFilter<"Notifications"> | boolean | null
    created_at?: DateTimeNullableFilter<"Notifications"> | Date | string | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    type?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    user_id?: BigIntFilter<"Notifications"> | bigint | number
    message?: StringFilter<"Notifications"> | string
    type?: EnumNotifications_typeNullableFilter<"Notifications"> | $Enums.Notifications_type | null
    is_read?: BoolNullableFilter<"Notifications"> | boolean | null
    created_at?: DateTimeNullableFilter<"Notifications"> | Date | string | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    type?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _avg?: NotificationsAvgOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
    _sum?: NotificationsSumOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    OR?: NotificationsScalarWhereWithAggregatesInput[]
    NOT?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Notifications"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"Notifications"> | bigint | number
    message?: StringWithAggregatesFilter<"Notifications"> | string
    type?: EnumNotifications_typeNullableWithAggregatesFilter<"Notifications"> | $Enums.Notifications_type | null
    is_read?: BoolNullableWithAggregatesFilter<"Notifications"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"Notifications"> | Date | string | null
  }

  export type PaymentsWhereInput = {
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    id?: BigIntFilter<"Payments"> | bigint | number
    user_id?: BigIntFilter<"Payments"> | bigint | number
    course_id?: BigIntNullableFilter<"Payments"> | bigint | number | null
    subscription_plan_id?: BigIntNullableFilter<"Payments"> | bigint | number | null
    amount?: DecimalFilter<"Payments"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payments"> | string
    method?: EnumPayments_methodFilter<"Payments"> | $Enums.Payments_method
    status?: EnumPayments_statusFilter<"Payments"> | $Enums.Payments_status
    transaction_id?: StringNullableFilter<"Payments"> | string | null
    created_at?: DateTimeNullableFilter<"Payments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"Payments"> | Date | string | null
    Courses?: XOR<CoursesNullableRelationFilter, CoursesWhereInput> | null
    SubscriptionPlans?: XOR<SubscriptionPlansNullableRelationFilter, SubscriptionPlansWhereInput> | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type PaymentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    subscription_plan_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    Courses?: CoursesOrderByWithRelationInput
    SubscriptionPlans?: SubscriptionPlansOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type PaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    user_id?: BigIntFilter<"Payments"> | bigint | number
    course_id?: BigIntNullableFilter<"Payments"> | bigint | number | null
    subscription_plan_id?: BigIntNullableFilter<"Payments"> | bigint | number | null
    amount?: DecimalFilter<"Payments"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payments"> | string
    method?: EnumPayments_methodFilter<"Payments"> | $Enums.Payments_method
    status?: EnumPayments_statusFilter<"Payments"> | $Enums.Payments_status
    transaction_id?: StringNullableFilter<"Payments"> | string | null
    created_at?: DateTimeNullableFilter<"Payments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"Payments"> | Date | string | null
    Courses?: XOR<CoursesNullableRelationFilter, CoursesWhereInput> | null
    SubscriptionPlans?: XOR<SubscriptionPlansNullableRelationFilter, SubscriptionPlansWhereInput> | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type PaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    subscription_plan_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: PaymentsCountOrderByAggregateInput
    _avg?: PaymentsAvgOrderByAggregateInput
    _max?: PaymentsMaxOrderByAggregateInput
    _min?: PaymentsMinOrderByAggregateInput
    _sum?: PaymentsSumOrderByAggregateInput
  }

  export type PaymentsScalarWhereWithAggregatesInput = {
    AND?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    OR?: PaymentsScalarWhereWithAggregatesInput[]
    NOT?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Payments"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"Payments"> | bigint | number
    course_id?: BigIntNullableWithAggregatesFilter<"Payments"> | bigint | number | null
    subscription_plan_id?: BigIntNullableWithAggregatesFilter<"Payments"> | bigint | number | null
    amount?: DecimalWithAggregatesFilter<"Payments"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payments"> | string
    method?: EnumPayments_methodWithAggregatesFilter<"Payments"> | $Enums.Payments_method
    status?: EnumPayments_statusWithAggregatesFilter<"Payments"> | $Enums.Payments_status
    transaction_id?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"Payments"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"Payments"> | Date | string | null
  }

  export type QuizAttemptsWhereInput = {
    AND?: QuizAttemptsWhereInput | QuizAttemptsWhereInput[]
    OR?: QuizAttemptsWhereInput[]
    NOT?: QuizAttemptsWhereInput | QuizAttemptsWhereInput[]
    id?: BigIntFilter<"QuizAttempts"> | bigint | number
    user_id?: BigIntFilter<"QuizAttempts"> | bigint | number
    assessment_id?: BigIntFilter<"QuizAttempts"> | bigint | number
    score?: IntNullableFilter<"QuizAttempts"> | number | null
    started_at?: DateTimeNullableFilter<"QuizAttempts"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"QuizAttempts"> | Date | string | null
    Assessments?: XOR<AssessmentsRelationFilter, AssessmentsWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
    UserAnswers?: UserAnswersListRelationFilter
  }

  export type QuizAttemptsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    assessment_id?: SortOrder
    score?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    Assessments?: AssessmentsOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    UserAnswers?: UserAnswersOrderByRelationAggregateInput
  }

  export type QuizAttemptsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: QuizAttemptsWhereInput | QuizAttemptsWhereInput[]
    OR?: QuizAttemptsWhereInput[]
    NOT?: QuizAttemptsWhereInput | QuizAttemptsWhereInput[]
    user_id?: BigIntFilter<"QuizAttempts"> | bigint | number
    assessment_id?: BigIntFilter<"QuizAttempts"> | bigint | number
    score?: IntNullableFilter<"QuizAttempts"> | number | null
    started_at?: DateTimeNullableFilter<"QuizAttempts"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"QuizAttempts"> | Date | string | null
    Assessments?: XOR<AssessmentsRelationFilter, AssessmentsWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
    UserAnswers?: UserAnswersListRelationFilter
  }, "id">

  export type QuizAttemptsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    assessment_id?: SortOrder
    score?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    _count?: QuizAttemptsCountOrderByAggregateInput
    _avg?: QuizAttemptsAvgOrderByAggregateInput
    _max?: QuizAttemptsMaxOrderByAggregateInput
    _min?: QuizAttemptsMinOrderByAggregateInput
    _sum?: QuizAttemptsSumOrderByAggregateInput
  }

  export type QuizAttemptsScalarWhereWithAggregatesInput = {
    AND?: QuizAttemptsScalarWhereWithAggregatesInput | QuizAttemptsScalarWhereWithAggregatesInput[]
    OR?: QuizAttemptsScalarWhereWithAggregatesInput[]
    NOT?: QuizAttemptsScalarWhereWithAggregatesInput | QuizAttemptsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"QuizAttempts"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"QuizAttempts"> | bigint | number
    assessment_id?: BigIntWithAggregatesFilter<"QuizAttempts"> | bigint | number
    score?: IntNullableWithAggregatesFilter<"QuizAttempts"> | number | null
    started_at?: DateTimeNullableWithAggregatesFilter<"QuizAttempts"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"QuizAttempts"> | Date | string | null
  }

  export type ReviewsWhereInput = {
    AND?: ReviewsWhereInput | ReviewsWhereInput[]
    OR?: ReviewsWhereInput[]
    NOT?: ReviewsWhereInput | ReviewsWhereInput[]
    id?: BigIntFilter<"Reviews"> | bigint | number
    user_id?: BigIntFilter<"Reviews"> | bigint | number
    course_id?: BigIntNullableFilter<"Reviews"> | bigint | number | null
    instructor_id?: BigIntNullableFilter<"Reviews"> | bigint | number | null
    rating?: IntFilter<"Reviews"> | number
    review_text?: StringNullableFilter<"Reviews"> | string | null
    created_at?: DateTimeNullableFilter<"Reviews"> | Date | string | null
    Courses?: XOR<CoursesNullableRelationFilter, CoursesWhereInput> | null
    Users_Reviews_instructor_idToUsers?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Users_Reviews_user_idToUsers?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type ReviewsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    instructor_id?: SortOrderInput | SortOrder
    rating?: SortOrder
    review_text?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    Courses?: CoursesOrderByWithRelationInput
    Users_Reviews_instructor_idToUsers?: UsersOrderByWithRelationInput
    Users_Reviews_user_idToUsers?: UsersOrderByWithRelationInput
  }

  export type ReviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ReviewsWhereInput | ReviewsWhereInput[]
    OR?: ReviewsWhereInput[]
    NOT?: ReviewsWhereInput | ReviewsWhereInput[]
    user_id?: BigIntFilter<"Reviews"> | bigint | number
    course_id?: BigIntNullableFilter<"Reviews"> | bigint | number | null
    instructor_id?: BigIntNullableFilter<"Reviews"> | bigint | number | null
    rating?: IntFilter<"Reviews"> | number
    review_text?: StringNullableFilter<"Reviews"> | string | null
    created_at?: DateTimeNullableFilter<"Reviews"> | Date | string | null
    Courses?: XOR<CoursesNullableRelationFilter, CoursesWhereInput> | null
    Users_Reviews_instructor_idToUsers?: XOR<UsersNullableRelationFilter, UsersWhereInput> | null
    Users_Reviews_user_idToUsers?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type ReviewsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    instructor_id?: SortOrderInput | SortOrder
    rating?: SortOrder
    review_text?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: ReviewsCountOrderByAggregateInput
    _avg?: ReviewsAvgOrderByAggregateInput
    _max?: ReviewsMaxOrderByAggregateInput
    _min?: ReviewsMinOrderByAggregateInput
    _sum?: ReviewsSumOrderByAggregateInput
  }

  export type ReviewsScalarWhereWithAggregatesInput = {
    AND?: ReviewsScalarWhereWithAggregatesInput | ReviewsScalarWhereWithAggregatesInput[]
    OR?: ReviewsScalarWhereWithAggregatesInput[]
    NOT?: ReviewsScalarWhereWithAggregatesInput | ReviewsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Reviews"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"Reviews"> | bigint | number
    course_id?: BigIntNullableWithAggregatesFilter<"Reviews"> | bigint | number | null
    instructor_id?: BigIntNullableWithAggregatesFilter<"Reviews"> | bigint | number | null
    rating?: IntWithAggregatesFilter<"Reviews"> | number
    review_text?: StringNullableWithAggregatesFilter<"Reviews"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"Reviews"> | Date | string | null
  }

  export type ShoppingCartWhereInput = {
    AND?: ShoppingCartWhereInput | ShoppingCartWhereInput[]
    OR?: ShoppingCartWhereInput[]
    NOT?: ShoppingCartWhereInput | ShoppingCartWhereInput[]
    id?: BigIntFilter<"ShoppingCart"> | bigint | number
    user_id?: BigIntFilter<"ShoppingCart"> | bigint | number
    course_id?: BigIntFilter<"ShoppingCart"> | bigint | number
    added_at?: DateTimeNullableFilter<"ShoppingCart"> | Date | string | null
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type ShoppingCartOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    added_at?: SortOrderInput | SortOrder
    Courses?: CoursesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type ShoppingCartWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ShoppingCartWhereInput | ShoppingCartWhereInput[]
    OR?: ShoppingCartWhereInput[]
    NOT?: ShoppingCartWhereInput | ShoppingCartWhereInput[]
    user_id?: BigIntFilter<"ShoppingCart"> | bigint | number
    course_id?: BigIntFilter<"ShoppingCart"> | bigint | number
    added_at?: DateTimeNullableFilter<"ShoppingCart"> | Date | string | null
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type ShoppingCartOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    added_at?: SortOrderInput | SortOrder
    _count?: ShoppingCartCountOrderByAggregateInput
    _avg?: ShoppingCartAvgOrderByAggregateInput
    _max?: ShoppingCartMaxOrderByAggregateInput
    _min?: ShoppingCartMinOrderByAggregateInput
    _sum?: ShoppingCartSumOrderByAggregateInput
  }

  export type ShoppingCartScalarWhereWithAggregatesInput = {
    AND?: ShoppingCartScalarWhereWithAggregatesInput | ShoppingCartScalarWhereWithAggregatesInput[]
    OR?: ShoppingCartScalarWhereWithAggregatesInput[]
    NOT?: ShoppingCartScalarWhereWithAggregatesInput | ShoppingCartScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ShoppingCart"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"ShoppingCart"> | bigint | number
    course_id?: BigIntWithAggregatesFilter<"ShoppingCart"> | bigint | number
    added_at?: DateTimeNullableWithAggregatesFilter<"ShoppingCart"> | Date | string | null
  }

  export type SubscriptionPlansWhereInput = {
    AND?: SubscriptionPlansWhereInput | SubscriptionPlansWhereInput[]
    OR?: SubscriptionPlansWhereInput[]
    NOT?: SubscriptionPlansWhereInput | SubscriptionPlansWhereInput[]
    id?: BigIntFilter<"SubscriptionPlans"> | bigint | number
    name?: StringFilter<"SubscriptionPlans"> | string
    price?: DecimalFilter<"SubscriptionPlans"> | Decimal | DecimalJsLike | number | string
    duration_days?: IntFilter<"SubscriptionPlans"> | number
    description?: StringNullableFilter<"SubscriptionPlans"> | string | null
    Payments?: PaymentsListRelationFilter
    Subscriptions?: SubscriptionsListRelationFilter
  }

  export type SubscriptionPlansOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    description?: SortOrderInput | SortOrder
    Payments?: PaymentsOrderByRelationAggregateInput
    Subscriptions?: SubscriptionsOrderByRelationAggregateInput
  }

  export type SubscriptionPlansWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: SubscriptionPlansWhereInput | SubscriptionPlansWhereInput[]
    OR?: SubscriptionPlansWhereInput[]
    NOT?: SubscriptionPlansWhereInput | SubscriptionPlansWhereInput[]
    name?: StringFilter<"SubscriptionPlans"> | string
    price?: DecimalFilter<"SubscriptionPlans"> | Decimal | DecimalJsLike | number | string
    duration_days?: IntFilter<"SubscriptionPlans"> | number
    description?: StringNullableFilter<"SubscriptionPlans"> | string | null
    Payments?: PaymentsListRelationFilter
    Subscriptions?: SubscriptionsListRelationFilter
  }, "id">

  export type SubscriptionPlansOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: SubscriptionPlansCountOrderByAggregateInput
    _avg?: SubscriptionPlansAvgOrderByAggregateInput
    _max?: SubscriptionPlansMaxOrderByAggregateInput
    _min?: SubscriptionPlansMinOrderByAggregateInput
    _sum?: SubscriptionPlansSumOrderByAggregateInput
  }

  export type SubscriptionPlansScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlansScalarWhereWithAggregatesInput | SubscriptionPlansScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlansScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlansScalarWhereWithAggregatesInput | SubscriptionPlansScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"SubscriptionPlans"> | bigint | number
    name?: StringWithAggregatesFilter<"SubscriptionPlans"> | string
    price?: DecimalWithAggregatesFilter<"SubscriptionPlans"> | Decimal | DecimalJsLike | number | string
    duration_days?: IntWithAggregatesFilter<"SubscriptionPlans"> | number
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlans"> | string | null
  }

  export type SubscriptionsWhereInput = {
    AND?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    OR?: SubscriptionsWhereInput[]
    NOT?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    id?: BigIntFilter<"Subscriptions"> | bigint | number
    user_id?: BigIntFilter<"Subscriptions"> | bigint | number
    plan_id?: BigIntFilter<"Subscriptions"> | bigint | number
    status?: EnumSubscriptions_statusFilter<"Subscriptions"> | $Enums.Subscriptions_status
    start_date?: DateTimeFilter<"Subscriptions"> | Date | string
    end_date?: DateTimeFilter<"Subscriptions"> | Date | string
    SubscriptionPlans?: XOR<SubscriptionPlansRelationFilter, SubscriptionPlansWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type SubscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    SubscriptionPlans?: SubscriptionPlansOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type SubscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    OR?: SubscriptionsWhereInput[]
    NOT?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    user_id?: BigIntFilter<"Subscriptions"> | bigint | number
    plan_id?: BigIntFilter<"Subscriptions"> | bigint | number
    status?: EnumSubscriptions_statusFilter<"Subscriptions"> | $Enums.Subscriptions_status
    start_date?: DateTimeFilter<"Subscriptions"> | Date | string
    end_date?: DateTimeFilter<"Subscriptions"> | Date | string
    SubscriptionPlans?: XOR<SubscriptionPlansRelationFilter, SubscriptionPlansWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type SubscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    _count?: SubscriptionsCountOrderByAggregateInput
    _avg?: SubscriptionsAvgOrderByAggregateInput
    _max?: SubscriptionsMaxOrderByAggregateInput
    _min?: SubscriptionsMinOrderByAggregateInput
    _sum?: SubscriptionsSumOrderByAggregateInput
  }

  export type SubscriptionsScalarWhereWithAggregatesInput = {
    AND?: SubscriptionsScalarWhereWithAggregatesInput | SubscriptionsScalarWhereWithAggregatesInput[]
    OR?: SubscriptionsScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionsScalarWhereWithAggregatesInput | SubscriptionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Subscriptions"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"Subscriptions"> | bigint | number
    plan_id?: BigIntWithAggregatesFilter<"Subscriptions"> | bigint | number
    status?: EnumSubscriptions_statusWithAggregatesFilter<"Subscriptions"> | $Enums.Subscriptions_status
    start_date?: DateTimeWithAggregatesFilter<"Subscriptions"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Subscriptions"> | Date | string
  }

  export type UserAnswersWhereInput = {
    AND?: UserAnswersWhereInput | UserAnswersWhereInput[]
    OR?: UserAnswersWhereInput[]
    NOT?: UserAnswersWhereInput | UserAnswersWhereInput[]
    id?: BigIntFilter<"UserAnswers"> | bigint | number
    attempt_id?: BigIntFilter<"UserAnswers"> | bigint | number
    question_id?: BigIntFilter<"UserAnswers"> | bigint | number
    selected_option_id?: BigIntNullableFilter<"UserAnswers"> | bigint | number | null
    answer_text?: StringNullableFilter<"UserAnswers"> | string | null
    QuizAttempts?: XOR<QuizAttemptsRelationFilter, QuizAttemptsWhereInput>
    AssessmentOptions?: XOR<AssessmentOptionsNullableRelationFilter, AssessmentOptionsWhereInput> | null
    AssessmentQuestions?: XOR<AssessmentQuestionsRelationFilter, AssessmentQuestionsWhereInput>
  }

  export type UserAnswersOrderByWithRelationInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    question_id?: SortOrder
    selected_option_id?: SortOrderInput | SortOrder
    answer_text?: SortOrderInput | SortOrder
    QuizAttempts?: QuizAttemptsOrderByWithRelationInput
    AssessmentOptions?: AssessmentOptionsOrderByWithRelationInput
    AssessmentQuestions?: AssessmentQuestionsOrderByWithRelationInput
  }

  export type UserAnswersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: UserAnswersWhereInput | UserAnswersWhereInput[]
    OR?: UserAnswersWhereInput[]
    NOT?: UserAnswersWhereInput | UserAnswersWhereInput[]
    attempt_id?: BigIntFilter<"UserAnswers"> | bigint | number
    question_id?: BigIntFilter<"UserAnswers"> | bigint | number
    selected_option_id?: BigIntNullableFilter<"UserAnswers"> | bigint | number | null
    answer_text?: StringNullableFilter<"UserAnswers"> | string | null
    QuizAttempts?: XOR<QuizAttemptsRelationFilter, QuizAttemptsWhereInput>
    AssessmentOptions?: XOR<AssessmentOptionsNullableRelationFilter, AssessmentOptionsWhereInput> | null
    AssessmentQuestions?: XOR<AssessmentQuestionsRelationFilter, AssessmentQuestionsWhereInput>
  }, "id">

  export type UserAnswersOrderByWithAggregationInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    question_id?: SortOrder
    selected_option_id?: SortOrderInput | SortOrder
    answer_text?: SortOrderInput | SortOrder
    _count?: UserAnswersCountOrderByAggregateInput
    _avg?: UserAnswersAvgOrderByAggregateInput
    _max?: UserAnswersMaxOrderByAggregateInput
    _min?: UserAnswersMinOrderByAggregateInput
    _sum?: UserAnswersSumOrderByAggregateInput
  }

  export type UserAnswersScalarWhereWithAggregatesInput = {
    AND?: UserAnswersScalarWhereWithAggregatesInput | UserAnswersScalarWhereWithAggregatesInput[]
    OR?: UserAnswersScalarWhereWithAggregatesInput[]
    NOT?: UserAnswersScalarWhereWithAggregatesInput | UserAnswersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserAnswers"> | bigint | number
    attempt_id?: BigIntWithAggregatesFilter<"UserAnswers"> | bigint | number
    question_id?: BigIntWithAggregatesFilter<"UserAnswers"> | bigint | number
    selected_option_id?: BigIntNullableWithAggregatesFilter<"UserAnswers"> | bigint | number | null
    answer_text?: StringNullableWithAggregatesFilter<"UserAnswers"> | string | null
  }

  export type UserSavedCoursesWhereInput = {
    AND?: UserSavedCoursesWhereInput | UserSavedCoursesWhereInput[]
    OR?: UserSavedCoursesWhereInput[]
    NOT?: UserSavedCoursesWhereInput | UserSavedCoursesWhereInput[]
    id?: BigIntFilter<"UserSavedCourses"> | bigint | number
    user_id?: BigIntFilter<"UserSavedCourses"> | bigint | number
    course_id?: BigIntFilter<"UserSavedCourses"> | bigint | number
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type UserSavedCoursesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    Courses?: CoursesOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type UserSavedCoursesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: UserSavedCoursesWhereInput | UserSavedCoursesWhereInput[]
    OR?: UserSavedCoursesWhereInput[]
    NOT?: UserSavedCoursesWhereInput | UserSavedCoursesWhereInput[]
    user_id?: BigIntFilter<"UserSavedCourses"> | bigint | number
    course_id?: BigIntFilter<"UserSavedCourses"> | bigint | number
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type UserSavedCoursesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    _count?: UserSavedCoursesCountOrderByAggregateInput
    _avg?: UserSavedCoursesAvgOrderByAggregateInput
    _max?: UserSavedCoursesMaxOrderByAggregateInput
    _min?: UserSavedCoursesMinOrderByAggregateInput
    _sum?: UserSavedCoursesSumOrderByAggregateInput
  }

  export type UserSavedCoursesScalarWhereWithAggregatesInput = {
    AND?: UserSavedCoursesScalarWhereWithAggregatesInput | UserSavedCoursesScalarWhereWithAggregatesInput[]
    OR?: UserSavedCoursesScalarWhereWithAggregatesInput[]
    NOT?: UserSavedCoursesScalarWhereWithAggregatesInput | UserSavedCoursesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserSavedCourses"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"UserSavedCourses"> | bigint | number
    course_id?: BigIntWithAggregatesFilter<"UserSavedCourses"> | bigint | number
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: BigIntFilter<"Users"> | bigint | number
    email?: StringFilter<"Users"> | string
    password_hash?: StringFilter<"Users"> | string
    role?: EnumUsers_roleFilter<"Users"> | $Enums.Users_role
    first_name?: StringNullableFilter<"Users"> | string | null
    last_name?: StringNullableFilter<"Users"> | string | null
    headline?: StringNullableFilter<"Users"> | string | null
    biography?: StringNullableFilter<"Users"> | string | null
    photo_url?: StringNullableFilter<"Users"> | string | null
    field_of_learning?: StringNullableFilter<"Users"> | string | null
    occupation?: StringNullableFilter<"Users"> | string | null
    skills?: JsonNullableFilter<"Users">
    interests?: JsonNullableFilter<"Users">
    resume_url?: StringNullableFilter<"Users"> | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFilter<"Users"> | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: DateTimeNullableFilter<"Users"> | Date | string | null
    instructor_reviewed_at?: DateTimeNullableFilter<"Users"> | Date | string | null
    instructor_admin_comment?: StringNullableFilter<"Users"> | string | null
    created_at?: DateTimeNullableFilter<"Users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"Users"> | Date | string | null
    Certificates?: CertificatesListRelationFilter
    Courses?: CoursesListRelationFilter
    Enrollments?: EnrollmentsListRelationFilter
    LessonProgress?: LessonProgressListRelationFilter
    Messages_Messages_receiver_idToUsers?: MessagesListRelationFilter
    Messages_Messages_sender_idToUsers?: MessagesListRelationFilter
    MultiFactorAuth?: MultiFactorAuthListRelationFilter
    Notifications?: NotificationsListRelationFilter
    Payments?: PaymentsListRelationFilter
    QuizAttempts?: QuizAttemptsListRelationFilter
    Reviews_Reviews_instructor_idToUsers?: ReviewsListRelationFilter
    Reviews_Reviews_user_idToUsers?: ReviewsListRelationFilter
    ShoppingCart?: ShoppingCartListRelationFilter
    Subscriptions?: SubscriptionsListRelationFilter
    UserSavedCourses?: UserSavedCoursesListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    photo_url?: SortOrderInput | SortOrder
    field_of_learning?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    resume_url?: SortOrderInput | SortOrder
    instructor_application_status?: SortOrder
    instructor_application_submitted_at?: SortOrderInput | SortOrder
    instructor_reviewed_at?: SortOrderInput | SortOrder
    instructor_admin_comment?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    Certificates?: CertificatesOrderByRelationAggregateInput
    Courses?: CoursesOrderByRelationAggregateInput
    Enrollments?: EnrollmentsOrderByRelationAggregateInput
    LessonProgress?: LessonProgressOrderByRelationAggregateInput
    Messages_Messages_receiver_idToUsers?: MessagesOrderByRelationAggregateInput
    Messages_Messages_sender_idToUsers?: MessagesOrderByRelationAggregateInput
    MultiFactorAuth?: MultiFactorAuthOrderByRelationAggregateInput
    Notifications?: NotificationsOrderByRelationAggregateInput
    Payments?: PaymentsOrderByRelationAggregateInput
    QuizAttempts?: QuizAttemptsOrderByRelationAggregateInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsOrderByRelationAggregateInput
    Reviews_Reviews_user_idToUsers?: ReviewsOrderByRelationAggregateInput
    ShoppingCart?: ShoppingCartOrderByRelationAggregateInput
    Subscriptions?: SubscriptionsOrderByRelationAggregateInput
    UserSavedCourses?: UserSavedCoursesOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    password_hash?: StringFilter<"Users"> | string
    role?: EnumUsers_roleFilter<"Users"> | $Enums.Users_role
    first_name?: StringNullableFilter<"Users"> | string | null
    last_name?: StringNullableFilter<"Users"> | string | null
    headline?: StringNullableFilter<"Users"> | string | null
    biography?: StringNullableFilter<"Users"> | string | null
    photo_url?: StringNullableFilter<"Users"> | string | null
    field_of_learning?: StringNullableFilter<"Users"> | string | null
    occupation?: StringNullableFilter<"Users"> | string | null
    skills?: JsonNullableFilter<"Users">
    interests?: JsonNullableFilter<"Users">
    resume_url?: StringNullableFilter<"Users"> | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFilter<"Users"> | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: DateTimeNullableFilter<"Users"> | Date | string | null
    instructor_reviewed_at?: DateTimeNullableFilter<"Users"> | Date | string | null
    instructor_admin_comment?: StringNullableFilter<"Users"> | string | null
    created_at?: DateTimeNullableFilter<"Users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"Users"> | Date | string | null
    Certificates?: CertificatesListRelationFilter
    Courses?: CoursesListRelationFilter
    Enrollments?: EnrollmentsListRelationFilter
    LessonProgress?: LessonProgressListRelationFilter
    Messages_Messages_receiver_idToUsers?: MessagesListRelationFilter
    Messages_Messages_sender_idToUsers?: MessagesListRelationFilter
    MultiFactorAuth?: MultiFactorAuthListRelationFilter
    Notifications?: NotificationsListRelationFilter
    Payments?: PaymentsListRelationFilter
    QuizAttempts?: QuizAttemptsListRelationFilter
    Reviews_Reviews_instructor_idToUsers?: ReviewsListRelationFilter
    Reviews_Reviews_user_idToUsers?: ReviewsListRelationFilter
    ShoppingCart?: ShoppingCartListRelationFilter
    Subscriptions?: SubscriptionsListRelationFilter
    UserSavedCourses?: UserSavedCoursesListRelationFilter
  }, "id" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    photo_url?: SortOrderInput | SortOrder
    field_of_learning?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    resume_url?: SortOrderInput | SortOrder
    instructor_application_status?: SortOrder
    instructor_application_submitted_at?: SortOrderInput | SortOrder
    instructor_reviewed_at?: SortOrderInput | SortOrder
    instructor_admin_comment?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Users"> | bigint | number
    email?: StringWithAggregatesFilter<"Users"> | string
    password_hash?: StringWithAggregatesFilter<"Users"> | string
    role?: EnumUsers_roleWithAggregatesFilter<"Users"> | $Enums.Users_role
    first_name?: StringNullableWithAggregatesFilter<"Users"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"Users"> | string | null
    headline?: StringNullableWithAggregatesFilter<"Users"> | string | null
    biography?: StringNullableWithAggregatesFilter<"Users"> | string | null
    photo_url?: StringNullableWithAggregatesFilter<"Users"> | string | null
    field_of_learning?: StringNullableWithAggregatesFilter<"Users"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"Users"> | string | null
    skills?: JsonNullableWithAggregatesFilter<"Users">
    interests?: JsonNullableWithAggregatesFilter<"Users">
    resume_url?: StringNullableWithAggregatesFilter<"Users"> | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusWithAggregatesFilter<"Users"> | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    instructor_reviewed_at?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    instructor_admin_comment?: StringNullableWithAggregatesFilter<"Users"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
  }

  export type AssessmentOptionsCreateInput = {
    id?: bigint | number
    option_text?: string | null
    is_correct?: boolean | null
    AssessmentQuestions: AssessmentQuestionsCreateNestedOneWithoutAssessmentOptionsInput
    UserAnswers?: UserAnswersCreateNestedManyWithoutAssessmentOptionsInput
  }

  export type AssessmentOptionsUncheckedCreateInput = {
    id?: bigint | number
    question_id: bigint | number
    option_text?: string | null
    is_correct?: boolean | null
    UserAnswers?: UserAnswersUncheckedCreateNestedManyWithoutAssessmentOptionsInput
  }

  export type AssessmentOptionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AssessmentQuestions?: AssessmentQuestionsUpdateOneRequiredWithoutAssessmentOptionsNestedInput
    UserAnswers?: UserAnswersUpdateManyWithoutAssessmentOptionsNestedInput
  }

  export type AssessmentOptionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserAnswers?: UserAnswersUncheckedUpdateManyWithoutAssessmentOptionsNestedInput
  }

  export type AssessmentOptionsCreateManyInput = {
    id?: bigint | number
    question_id: bigint | number
    option_text?: string | null
    is_correct?: boolean | null
  }

  export type AssessmentOptionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AssessmentOptionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AssessmentQuestionsCreateInput = {
    id?: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsCreateNestedManyWithoutAssessmentQuestionsInput
    Assessments: AssessmentsCreateNestedOneWithoutAssessmentQuestionsInput
    UserAnswers?: UserAnswersCreateNestedManyWithoutAssessmentQuestionsInput
  }

  export type AssessmentQuestionsUncheckedCreateInput = {
    id?: bigint | number
    assessment_id: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsUncheckedCreateNestedManyWithoutAssessmentQuestionsInput
    UserAnswers?: UserAnswersUncheckedCreateNestedManyWithoutAssessmentQuestionsInput
  }

  export type AssessmentQuestionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsUpdateManyWithoutAssessmentQuestionsNestedInput
    Assessments?: AssessmentsUpdateOneRequiredWithoutAssessmentQuestionsNestedInput
    UserAnswers?: UserAnswersUpdateManyWithoutAssessmentQuestionsNestedInput
  }

  export type AssessmentQuestionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assessment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsUncheckedUpdateManyWithoutAssessmentQuestionsNestedInput
    UserAnswers?: UserAnswersUncheckedUpdateManyWithoutAssessmentQuestionsNestedInput
  }

  export type AssessmentQuestionsCreateManyInput = {
    id?: bigint | number
    assessment_id: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
  }

  export type AssessmentQuestionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
  }

  export type AssessmentQuestionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assessment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
  }

  export type AssessmentsCreateInput = {
    id?: bigint | number
    title?: string | null
    instructions?: string | null
    AssessmentQuestions?: AssessmentQuestionsCreateNestedManyWithoutAssessmentsInput
    CourseContent: CourseContentCreateNestedOneWithoutAssessmentsInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutAssessmentsInput
  }

  export type AssessmentsUncheckedCreateInput = {
    id?: bigint | number
    content_id: bigint | number
    title?: string | null
    instructions?: string | null
    AssessmentQuestions?: AssessmentQuestionsUncheckedCreateNestedManyWithoutAssessmentsInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutAssessmentsInput
  }

  export type AssessmentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    AssessmentQuestions?: AssessmentQuestionsUpdateManyWithoutAssessmentsNestedInput
    CourseContent?: CourseContentUpdateOneRequiredWithoutAssessmentsNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutAssessmentsNestedInput
  }

  export type AssessmentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    AssessmentQuestions?: AssessmentQuestionsUncheckedUpdateManyWithoutAssessmentsNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutAssessmentsNestedInput
  }

  export type AssessmentsCreateManyInput = {
    id?: bigint | number
    content_id: bigint | number
    title?: string | null
    instructions?: string | null
  }

  export type AssessmentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoriesCreateInput = {
    id?: bigint | number
    name: string
    Courses?: CoursesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    Courses?: CoursesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    Courses?: CoursesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    Courses?: CoursesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesCreateManyInput = {
    id?: bigint | number
    name: string
  }

  export type CategoriesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CertificatesCreateInput = {
    id?: bigint | number
    certificate_url?: string | null
    issued_at?: Date | string | null
    Courses: CoursesCreateNestedOneWithoutCertificatesInput
    Users: UsersCreateNestedOneWithoutCertificatesInput
  }

  export type CertificatesUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id: bigint | number
    certificate_url?: string | null
    issued_at?: Date | string | null
  }

  export type CertificatesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneRequiredWithoutCertificatesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificatesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificatesCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id: bigint | number
    certificate_url?: string | null
    issued_at?: Date | string | null
  }

  export type CertificatesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificatesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseContentCreateInput = {
    id?: bigint | number
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsCreateNestedManyWithoutCourseContentInput
    Courses: CoursesCreateNestedOneWithoutCourseContentInput
    CourseContent?: CourseContentCreateNestedOneWithoutOther_CourseContentInput
    other_CourseContent?: CourseContentCreateNestedManyWithoutCourseContentInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentUncheckedCreateInput = {
    id?: bigint | number
    course_id: bigint | number
    parent_id?: bigint | number | null
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsUncheckedCreateNestedManyWithoutCourseContentInput
    other_CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCourseContentInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUpdateManyWithoutCourseContentNestedInput
    Courses?: CoursesUpdateOneRequiredWithoutCourseContentNestedInput
    CourseContent?: CourseContentUpdateOneWithoutOther_CourseContentNestedInput
    other_CourseContent?: CourseContentUpdateManyWithoutCourseContentNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUncheckedUpdateManyWithoutCourseContentNestedInput
    other_CourseContent?: CourseContentUncheckedUpdateManyWithoutCourseContentNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentCreateManyInput = {
    id?: bigint | number
    course_id: bigint | number
    parent_id?: bigint | number | null
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
  }

  export type CourseContentUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
  }

  export type CourseContentUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTagsCreateInput = {
    id?: bigint | number
    tag_name: string
    tag_type: $Enums.CourseTags_tag_type
    Courses: CoursesCreateNestedOneWithoutCourseTagsInput
  }

  export type CourseTagsUncheckedCreateInput = {
    id?: bigint | number
    course_id: bigint | number
    tag_name: string
    tag_type: $Enums.CourseTags_tag_type
  }

  export type CourseTagsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_type?: EnumCourseTags_tag_typeFieldUpdateOperationsInput | $Enums.CourseTags_tag_type
    Courses?: CoursesUpdateOneRequiredWithoutCourseTagsNestedInput
  }

  export type CourseTagsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_type?: EnumCourseTags_tag_typeFieldUpdateOperationsInput | $Enums.CourseTags_tag_type
  }

  export type CourseTagsCreateManyInput = {
    id?: bigint | number
    course_id: bigint | number
    tag_name: string
    tag_type: $Enums.CourseTags_tag_type
  }

  export type CourseTagsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_type?: EnumCourseTags_tag_typeFieldUpdateOperationsInput | $Enums.CourseTags_tag_type
  }

  export type CourseTagsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_type?: EnumCourseTags_tag_typeFieldUpdateOperationsInput | $Enums.CourseTags_tag_type
  }

  export type CoursesCreateInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesCreateManyInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type CoursesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoursesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentsCreateInput = {
    id?: bigint | number
    enrolled_at?: Date | string | null
    Courses: CoursesCreateNestedOneWithoutEnrollmentsInput
    Users: UsersCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id: bigint | number
    enrolled_at?: Date | string | null
  }

  export type EnrollmentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneRequiredWithoutEnrollmentsNestedInput
    Users?: UsersUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id: bigint | number
    enrolled_at?: Date | string | null
  }

  export type EnrollmentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonProgressCreateInput = {
    id?: bigint | number
    is_completed?: boolean | null
    completed_at?: Date | string | null
    CourseContent: CourseContentCreateNestedOneWithoutLessonProgressInput
    Users: UsersCreateNestedOneWithoutLessonProgressInput
  }

  export type LessonProgressUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    content_id: bigint | number
    is_completed?: boolean | null
    completed_at?: Date | string | null
  }

  export type LessonProgressUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CourseContent?: CourseContentUpdateOneRequiredWithoutLessonProgressNestedInput
    Users?: UsersUpdateOneRequiredWithoutLessonProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    content_id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonProgressCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    content_id: bigint | number
    is_completed?: boolean | null
    completed_at?: Date | string | null
  }

  export type LessonProgressUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonProgressUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    content_id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessagesCreateInput = {
    id?: bigint | number
    content: string
    created_at?: Date | string | null
    Users_Messages_receiver_idToUsers: UsersCreateNestedOneWithoutMessages_Messages_receiver_idToUsersInput
    Users_Messages_sender_idToUsers: UsersCreateNestedOneWithoutMessages_Messages_sender_idToUsersInput
  }

  export type MessagesUncheckedCreateInput = {
    id?: bigint | number
    sender_id: bigint | number
    receiver_id: bigint | number
    content: string
    created_at?: Date | string | null
  }

  export type MessagesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users_Messages_receiver_idToUsers?: UsersUpdateOneRequiredWithoutMessages_Messages_receiver_idToUsersNestedInput
    Users_Messages_sender_idToUsers?: UsersUpdateOneRequiredWithoutMessages_Messages_sender_idToUsersNestedInput
  }

  export type MessagesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sender_id?: BigIntFieldUpdateOperationsInput | bigint | number
    receiver_id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessagesCreateManyInput = {
    id?: bigint | number
    sender_id: bigint | number
    receiver_id: bigint | number
    content: string
    created_at?: Date | string | null
  }

  export type MessagesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessagesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sender_id?: BigIntFieldUpdateOperationsInput | bigint | number
    receiver_id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultiFactorAuthCreateInput = {
    id?: bigint | number
    mfa_type: $Enums.MultiFactorAuth_mfa_type
    secret_key?: string | null
    is_enabled?: boolean | null
    created_at?: Date | string | null
    Users: UsersCreateNestedOneWithoutMultiFactorAuthInput
  }

  export type MultiFactorAuthUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    mfa_type: $Enums.MultiFactorAuth_mfa_type
    secret_key?: string | null
    is_enabled?: boolean | null
    created_at?: Date | string | null
  }

  export type MultiFactorAuthUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFieldUpdateOperationsInput | $Enums.MultiFactorAuth_mfa_type
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutMultiFactorAuthNestedInput
  }

  export type MultiFactorAuthUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFieldUpdateOperationsInput | $Enums.MultiFactorAuth_mfa_type
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultiFactorAuthCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    mfa_type: $Enums.MultiFactorAuth_mfa_type
    secret_key?: string | null
    is_enabled?: boolean | null
    created_at?: Date | string | null
  }

  export type MultiFactorAuthUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFieldUpdateOperationsInput | $Enums.MultiFactorAuth_mfa_type
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultiFactorAuthUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFieldUpdateOperationsInput | $Enums.MultiFactorAuth_mfa_type
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationsCreateInput = {
    id?: bigint | number
    message: string
    type?: $Enums.Notifications_type | null
    is_read?: boolean | null
    created_at?: Date | string | null
    Users: UsersCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    message: string
    type?: $Enums.Notifications_type | null
    is_read?: boolean | null
    created_at?: Date | string | null
  }

  export type NotificationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotifications_typeFieldUpdateOperationsInput | $Enums.Notifications_type | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotifications_typeFieldUpdateOperationsInput | $Enums.Notifications_type | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    message: string
    type?: $Enums.Notifications_type | null
    is_read?: boolean | null
    created_at?: Date | string | null
  }

  export type NotificationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotifications_typeFieldUpdateOperationsInput | $Enums.Notifications_type | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotifications_typeFieldUpdateOperationsInput | $Enums.Notifications_type | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentsCreateInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Courses?: CoursesCreateNestedOneWithoutPaymentsInput
    SubscriptionPlans?: SubscriptionPlansCreateNestedOneWithoutPaymentsInput
    Users: UsersCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id?: bigint | number | null
    subscription_plan_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type PaymentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneWithoutPaymentsNestedInput
    SubscriptionPlans?: SubscriptionPlansUpdateOneWithoutPaymentsNestedInput
    Users?: UsersUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subscription_plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id?: bigint | number | null
    subscription_plan_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type PaymentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subscription_plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAttemptsCreateInput = {
    id?: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    Assessments: AssessmentsCreateNestedOneWithoutQuizAttemptsInput
    Users: UsersCreateNestedOneWithoutQuizAttemptsInput
    UserAnswers?: UserAnswersCreateNestedManyWithoutQuizAttemptsInput
  }

  export type QuizAttemptsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    assessment_id: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    UserAnswers?: UserAnswersUncheckedCreateNestedManyWithoutQuizAttemptsInput
  }

  export type QuizAttemptsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Assessments?: AssessmentsUpdateOneRequiredWithoutQuizAttemptsNestedInput
    Users?: UsersUpdateOneRequiredWithoutQuizAttemptsNestedInput
    UserAnswers?: UserAnswersUpdateManyWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assessment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAnswers?: UserAnswersUncheckedUpdateManyWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    assessment_id: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type QuizAttemptsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAttemptsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assessment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewsCreateInput = {
    id?: bigint | number
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
    Courses?: CoursesCreateNestedOneWithoutReviewsInput
    Users_Reviews_instructor_idToUsers?: UsersCreateNestedOneWithoutReviews_Reviews_instructor_idToUsersInput
    Users_Reviews_user_idToUsers: UsersCreateNestedOneWithoutReviews_Reviews_user_idToUsersInput
  }

  export type ReviewsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id?: bigint | number | null
    instructor_id?: bigint | number | null
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
  }

  export type ReviewsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneWithoutReviewsNestedInput
    Users_Reviews_instructor_idToUsers?: UsersUpdateOneWithoutReviews_Reviews_instructor_idToUsersNestedInput
    Users_Reviews_user_idToUsers?: UsersUpdateOneRequiredWithoutReviews_Reviews_user_idToUsersNestedInput
  }

  export type ReviewsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    instructor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id?: bigint | number | null
    instructor_id?: bigint | number | null
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
  }

  export type ReviewsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    instructor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartCreateInput = {
    id?: bigint | number
    added_at?: Date | string | null
    Courses: CoursesCreateNestedOneWithoutShoppingCartInput
    Users: UsersCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id: bigint | number
    added_at?: Date | string | null
  }

  export type ShoppingCartUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneRequiredWithoutShoppingCartNestedInput
    Users?: UsersUpdateOneRequiredWithoutShoppingCartNestedInput
  }

  export type ShoppingCartUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id: bigint | number
    added_at?: Date | string | null
  }

  export type ShoppingCartUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionPlansCreateInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    description?: string | null
    Payments?: PaymentsCreateNestedManyWithoutSubscriptionPlansInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutSubscriptionPlansInput
  }

  export type SubscriptionPlansUncheckedCreateInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    description?: string | null
    Payments?: PaymentsUncheckedCreateNestedManyWithoutSubscriptionPlansInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutSubscriptionPlansInput
  }

  export type SubscriptionPlansUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Payments?: PaymentsUpdateManyWithoutSubscriptionPlansNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutSubscriptionPlansNestedInput
  }

  export type SubscriptionPlansUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Payments?: PaymentsUncheckedUpdateManyWithoutSubscriptionPlansNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutSubscriptionPlansNestedInput
  }

  export type SubscriptionPlansCreateManyInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    description?: string | null
  }

  export type SubscriptionPlansUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionPlansUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionsCreateInput = {
    id?: bigint | number
    status: $Enums.Subscriptions_status
    start_date: Date | string
    end_date: Date | string
    SubscriptionPlans: SubscriptionPlansCreateNestedOneWithoutSubscriptionsInput
    Users: UsersCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    plan_id: bigint | number
    status: $Enums.Subscriptions_status
    start_date: Date | string
    end_date: Date | string
  }

  export type SubscriptionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionPlans?: SubscriptionPlansUpdateOneRequiredWithoutSubscriptionsNestedInput
    Users?: UsersUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    plan_id: bigint | number
    status: $Enums.Subscriptions_status
    start_date: Date | string
    end_date: Date | string
  }

  export type SubscriptionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswersCreateInput = {
    id?: bigint | number
    answer_text?: string | null
    QuizAttempts: QuizAttemptsCreateNestedOneWithoutUserAnswersInput
    AssessmentOptions?: AssessmentOptionsCreateNestedOneWithoutUserAnswersInput
    AssessmentQuestions: AssessmentQuestionsCreateNestedOneWithoutUserAnswersInput
  }

  export type UserAnswersUncheckedCreateInput = {
    id?: bigint | number
    attempt_id: bigint | number
    question_id: bigint | number
    selected_option_id?: bigint | number | null
    answer_text?: string | null
  }

  export type UserAnswersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
    QuizAttempts?: QuizAttemptsUpdateOneRequiredWithoutUserAnswersNestedInput
    AssessmentOptions?: AssessmentOptionsUpdateOneWithoutUserAnswersNestedInput
    AssessmentQuestions?: AssessmentQuestionsUpdateOneRequiredWithoutUserAnswersNestedInput
  }

  export type UserAnswersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    selected_option_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAnswersCreateManyInput = {
    id?: bigint | number
    attempt_id: bigint | number
    question_id: bigint | number
    selected_option_id?: bigint | number | null
    answer_text?: string | null
  }

  export type UserAnswersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAnswersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    selected_option_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSavedCoursesCreateInput = {
    id?: bigint | number
    Courses: CoursesCreateNestedOneWithoutUserSavedCoursesInput
    Users: UsersCreateNestedOneWithoutUserSavedCoursesInput
  }

  export type UserSavedCoursesUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id: bigint | number
  }

  export type UserSavedCoursesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    Courses?: CoursesUpdateOneRequiredWithoutUserSavedCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutUserSavedCoursesNestedInput
  }

  export type UserSavedCoursesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserSavedCoursesCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id: bigint | number
  }

  export type UserSavedCoursesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserSavedCoursesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UsersCreateInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type UsersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AssessmentQuestionsRelationFilter = {
    is?: AssessmentQuestionsWhereInput
    isNot?: AssessmentQuestionsWhereInput
  }

  export type UserAnswersListRelationFilter = {
    every?: UserAnswersWhereInput
    some?: UserAnswersWhereInput
    none?: UserAnswersWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserAnswersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentOptionsCountOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
    option_text?: SortOrder
    is_correct?: SortOrder
  }

  export type AssessmentOptionsAvgOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
  }

  export type AssessmentOptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
    option_text?: SortOrder
    is_correct?: SortOrder
  }

  export type AssessmentOptionsMinOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
    option_text?: SortOrder
    is_correct?: SortOrder
  }

  export type AssessmentOptionsSumOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAssessmentQuestions_question_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentQuestions_question_type | EnumAssessmentQuestions_question_typeFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentQuestions_question_type[]
    notIn?: $Enums.AssessmentQuestions_question_type[]
    not?: NestedEnumAssessmentQuestions_question_typeFilter<$PrismaModel> | $Enums.AssessmentQuestions_question_type
  }

  export type AssessmentOptionsListRelationFilter = {
    every?: AssessmentOptionsWhereInput
    some?: AssessmentOptionsWhereInput
    none?: AssessmentOptionsWhereInput
  }

  export type AssessmentsRelationFilter = {
    is?: AssessmentsWhereInput
    isNot?: AssessmentsWhereInput
  }

  export type AssessmentOptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentQuestionsCountOrderByAggregateInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
  }

  export type AssessmentQuestionsAvgOrderByAggregateInput = {
    id?: SortOrder
    assessment_id?: SortOrder
  }

  export type AssessmentQuestionsMaxOrderByAggregateInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
  }

  export type AssessmentQuestionsMinOrderByAggregateInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
  }

  export type AssessmentQuestionsSumOrderByAggregateInput = {
    id?: SortOrder
    assessment_id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAssessmentQuestions_question_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentQuestions_question_type | EnumAssessmentQuestions_question_typeFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentQuestions_question_type[]
    notIn?: $Enums.AssessmentQuestions_question_type[]
    not?: NestedEnumAssessmentQuestions_question_typeWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentQuestions_question_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssessmentQuestions_question_typeFilter<$PrismaModel>
    _max?: NestedEnumAssessmentQuestions_question_typeFilter<$PrismaModel>
  }

  export type AssessmentQuestionsListRelationFilter = {
    every?: AssessmentQuestionsWhereInput
    some?: AssessmentQuestionsWhereInput
    none?: AssessmentQuestionsWhereInput
  }

  export type CourseContentRelationFilter = {
    is?: CourseContentWhereInput
    isNot?: CourseContentWhereInput
  }

  export type QuizAttemptsListRelationFilter = {
    every?: QuizAttemptsWhereInput
    some?: QuizAttemptsWhereInput
    none?: QuizAttemptsWhereInput
  }

  export type AssessmentQuestionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizAttemptsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentsCountOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
  }

  export type AssessmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
  }

  export type AssessmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
  }

  export type AssessmentsMinOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
  }

  export type AssessmentsSumOrderByAggregateInput = {
    id?: SortOrder
    content_id?: SortOrder
  }

  export type CoursesListRelationFilter = {
    every?: CoursesWhereInput
    some?: CoursesWhereInput
    none?: CoursesWhereInput
  }

  export type CoursesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CoursesRelationFilter = {
    is?: CoursesWhereInput
    isNot?: CoursesWhereInput
  }

  export type UsersRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type CertificatesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    certificate_url?: SortOrder
    issued_at?: SortOrder
  }

  export type CertificatesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type CertificatesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    certificate_url?: SortOrder
    issued_at?: SortOrder
  }

  export type CertificatesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    certificate_url?: SortOrder
    issued_at?: SortOrder
  }

  export type CertificatesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EnumCourseContent_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseContent_type | EnumCourseContent_typeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseContent_type[]
    notIn?: $Enums.CourseContent_type[]
    not?: NestedEnumCourseContent_typeFilter<$PrismaModel> | $Enums.CourseContent_type
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AssessmentsListRelationFilter = {
    every?: AssessmentsWhereInput
    some?: AssessmentsWhereInput
    none?: AssessmentsWhereInput
  }

  export type CourseContentNullableRelationFilter = {
    is?: CourseContentWhereInput | null
    isNot?: CourseContentWhereInput | null
  }

  export type CourseContentListRelationFilter = {
    every?: CourseContentWhereInput
    some?: CourseContentWhereInput
    none?: CourseContentWhereInput
  }

  export type LessonProgressListRelationFilter = {
    every?: LessonProgressWhereInput
    some?: LessonProgressWhereInput
    none?: LessonProgressWhereInput
  }

  export type AssessmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseContentCountOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    video_url?: SortOrder
    note_content?: SortOrder
    duration_seconds?: SortOrder
    order_index?: SortOrder
  }

  export type CourseContentAvgOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    parent_id?: SortOrder
    duration_seconds?: SortOrder
    order_index?: SortOrder
  }

  export type CourseContentMaxOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    video_url?: SortOrder
    note_content?: SortOrder
    duration_seconds?: SortOrder
    order_index?: SortOrder
  }

  export type CourseContentMinOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    video_url?: SortOrder
    note_content?: SortOrder
    duration_seconds?: SortOrder
    order_index?: SortOrder
  }

  export type CourseContentSumOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    parent_id?: SortOrder
    duration_seconds?: SortOrder
    order_index?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumCourseContent_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseContent_type | EnumCourseContent_typeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseContent_type[]
    notIn?: $Enums.CourseContent_type[]
    not?: NestedEnumCourseContent_typeWithAggregatesFilter<$PrismaModel> | $Enums.CourseContent_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseContent_typeFilter<$PrismaModel>
    _max?: NestedEnumCourseContent_typeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCourseTags_tag_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseTags_tag_type | EnumCourseTags_tag_typeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseTags_tag_type[]
    notIn?: $Enums.CourseTags_tag_type[]
    not?: NestedEnumCourseTags_tag_typeFilter<$PrismaModel> | $Enums.CourseTags_tag_type
  }

  export type CourseTagsCountOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    tag_name?: SortOrder
    tag_type?: SortOrder
  }

  export type CourseTagsAvgOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
  }

  export type CourseTagsMaxOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    tag_name?: SortOrder
    tag_type?: SortOrder
  }

  export type CourseTagsMinOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    tag_name?: SortOrder
    tag_type?: SortOrder
  }

  export type CourseTagsSumOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
  }

  export type EnumCourseTags_tag_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseTags_tag_type | EnumCourseTags_tag_typeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseTags_tag_type[]
    notIn?: $Enums.CourseTags_tag_type[]
    not?: NestedEnumCourseTags_tag_typeWithAggregatesFilter<$PrismaModel> | $Enums.CourseTags_tag_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTags_tag_typeFilter<$PrismaModel>
    _max?: NestedEnumCourseTags_tag_typeFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumCourses_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.Courses_level | EnumCourses_levelFieldRefInput<$PrismaModel>
    in?: $Enums.Courses_level[]
    notIn?: $Enums.Courses_level[]
    not?: NestedEnumCourses_levelFilter<$PrismaModel> | $Enums.Courses_level
  }

  export type CertificatesListRelationFilter = {
    every?: CertificatesWhereInput
    some?: CertificatesWhereInput
    none?: CertificatesWhereInput
  }

  export type CourseTagsListRelationFilter = {
    every?: CourseTagsWhereInput
    some?: CourseTagsWhereInput
    none?: CourseTagsWhereInput
  }

  export type CategoriesRelationFilter = {
    is?: CategoriesWhereInput
    isNot?: CategoriesWhereInput
  }

  export type EnrollmentsListRelationFilter = {
    every?: EnrollmentsWhereInput
    some?: EnrollmentsWhereInput
    none?: EnrollmentsWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: PaymentsWhereInput
    some?: PaymentsWhereInput
    none?: PaymentsWhereInput
  }

  export type ReviewsListRelationFilter = {
    every?: ReviewsWhereInput
    some?: ReviewsWhereInput
    none?: ReviewsWhereInput
  }

  export type ShoppingCartListRelationFilter = {
    every?: ShoppingCartWhereInput
    some?: ShoppingCartWhereInput
    none?: ShoppingCartWhereInput
  }

  export type UserSavedCoursesListRelationFilter = {
    every?: UserSavedCoursesWhereInput
    some?: UserSavedCoursesWhereInput
    none?: UserSavedCoursesWhereInput
  }

  export type CertificatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseTagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShoppingCartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSavedCoursesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoursesCountOrderByAggregateInput = {
    id?: SortOrder
    instructor_id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    price?: SortOrder
    thumbnail_url?: SortOrder
    level?: SortOrder
    views?: SortOrder
    enrollments_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CoursesAvgOrderByAggregateInput = {
    id?: SortOrder
    instructor_id?: SortOrder
    category_id?: SortOrder
    price?: SortOrder
    views?: SortOrder
    enrollments_count?: SortOrder
  }

  export type CoursesMaxOrderByAggregateInput = {
    id?: SortOrder
    instructor_id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    price?: SortOrder
    thumbnail_url?: SortOrder
    level?: SortOrder
    views?: SortOrder
    enrollments_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CoursesMinOrderByAggregateInput = {
    id?: SortOrder
    instructor_id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    price?: SortOrder
    thumbnail_url?: SortOrder
    level?: SortOrder
    views?: SortOrder
    enrollments_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CoursesSumOrderByAggregateInput = {
    id?: SortOrder
    instructor_id?: SortOrder
    category_id?: SortOrder
    price?: SortOrder
    views?: SortOrder
    enrollments_count?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumCourses_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Courses_level | EnumCourses_levelFieldRefInput<$PrismaModel>
    in?: $Enums.Courses_level[]
    notIn?: $Enums.Courses_level[]
    not?: NestedEnumCourses_levelWithAggregatesFilter<$PrismaModel> | $Enums.Courses_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourses_levelFilter<$PrismaModel>
    _max?: NestedEnumCourses_levelFilter<$PrismaModel>
  }

  export type EnrollmentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    enrolled_at?: SortOrder
  }

  export type EnrollmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type EnrollmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    enrolled_at?: SortOrder
  }

  export type EnrollmentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    enrolled_at?: SortOrder
  }

  export type EnrollmentsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type LessonProgressCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content_id?: SortOrder
    is_completed?: SortOrder
    completed_at?: SortOrder
  }

  export type LessonProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content_id?: SortOrder
  }

  export type LessonProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content_id?: SortOrder
    is_completed?: SortOrder
    completed_at?: SortOrder
  }

  export type LessonProgressMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content_id?: SortOrder
    is_completed?: SortOrder
    completed_at?: SortOrder
  }

  export type LessonProgressSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    content_id?: SortOrder
  }

  export type MessagesCountOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type MessagesAvgOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type MessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type MessagesMinOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type MessagesSumOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type EnumMultiFactorAuth_mfa_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.MultiFactorAuth_mfa_type | EnumMultiFactorAuth_mfa_typeFieldRefInput<$PrismaModel>
    in?: $Enums.MultiFactorAuth_mfa_type[]
    notIn?: $Enums.MultiFactorAuth_mfa_type[]
    not?: NestedEnumMultiFactorAuth_mfa_typeFilter<$PrismaModel> | $Enums.MultiFactorAuth_mfa_type
  }

  export type MultiFactorAuthCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    mfa_type?: SortOrder
    secret_key?: SortOrder
    is_enabled?: SortOrder
    created_at?: SortOrder
  }

  export type MultiFactorAuthAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type MultiFactorAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    mfa_type?: SortOrder
    secret_key?: SortOrder
    is_enabled?: SortOrder
    created_at?: SortOrder
  }

  export type MultiFactorAuthMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    mfa_type?: SortOrder
    secret_key?: SortOrder
    is_enabled?: SortOrder
    created_at?: SortOrder
  }

  export type MultiFactorAuthSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumMultiFactorAuth_mfa_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MultiFactorAuth_mfa_type | EnumMultiFactorAuth_mfa_typeFieldRefInput<$PrismaModel>
    in?: $Enums.MultiFactorAuth_mfa_type[]
    notIn?: $Enums.MultiFactorAuth_mfa_type[]
    not?: NestedEnumMultiFactorAuth_mfa_typeWithAggregatesFilter<$PrismaModel> | $Enums.MultiFactorAuth_mfa_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMultiFactorAuth_mfa_typeFilter<$PrismaModel>
    _max?: NestedEnumMultiFactorAuth_mfa_typeFilter<$PrismaModel>
  }

  export type EnumNotifications_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Notifications_type | EnumNotifications_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Notifications_type[] | null
    notIn?: $Enums.Notifications_type[] | null
    not?: NestedEnumNotifications_typeNullableFilter<$PrismaModel> | $Enums.Notifications_type | null
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumNotifications_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Notifications_type | EnumNotifications_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Notifications_type[] | null
    notIn?: $Enums.Notifications_type[] | null
    not?: NestedEnumNotifications_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Notifications_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotifications_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotifications_typeNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumPayments_methodFilter<$PrismaModel = never> = {
    equals?: $Enums.Payments_method | EnumPayments_methodFieldRefInput<$PrismaModel>
    in?: $Enums.Payments_method[]
    notIn?: $Enums.Payments_method[]
    not?: NestedEnumPayments_methodFilter<$PrismaModel> | $Enums.Payments_method
  }

  export type EnumPayments_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.Payments_status | EnumPayments_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Payments_status[]
    notIn?: $Enums.Payments_status[]
    not?: NestedEnumPayments_statusFilter<$PrismaModel> | $Enums.Payments_status
  }

  export type CoursesNullableRelationFilter = {
    is?: CoursesWhereInput | null
    isNot?: CoursesWhereInput | null
  }

  export type SubscriptionPlansNullableRelationFilter = {
    is?: SubscriptionPlansWhereInput | null
    isNot?: SubscriptionPlansWhereInput | null
  }

  export type PaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    subscription_plan_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    subscription_plan_id?: SortOrder
    amount?: SortOrder
  }

  export type PaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    subscription_plan_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    subscription_plan_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    subscription_plan_id?: SortOrder
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPayments_methodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Payments_method | EnumPayments_methodFieldRefInput<$PrismaModel>
    in?: $Enums.Payments_method[]
    notIn?: $Enums.Payments_method[]
    not?: NestedEnumPayments_methodWithAggregatesFilter<$PrismaModel> | $Enums.Payments_method
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayments_methodFilter<$PrismaModel>
    _max?: NestedEnumPayments_methodFilter<$PrismaModel>
  }

  export type EnumPayments_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Payments_status | EnumPayments_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Payments_status[]
    notIn?: $Enums.Payments_status[]
    not?: NestedEnumPayments_statusWithAggregatesFilter<$PrismaModel> | $Enums.Payments_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayments_statusFilter<$PrismaModel>
    _max?: NestedEnumPayments_statusFilter<$PrismaModel>
  }

  export type QuizAttemptsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    assessment_id?: SortOrder
    score?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
  }

  export type QuizAttemptsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    assessment_id?: SortOrder
    score?: SortOrder
  }

  export type QuizAttemptsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    assessment_id?: SortOrder
    score?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
  }

  export type QuizAttemptsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    assessment_id?: SortOrder
    score?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
  }

  export type QuizAttemptsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    assessment_id?: SortOrder
    score?: SortOrder
  }

  export type UsersNullableRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type ReviewsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    instructor_id?: SortOrder
    rating?: SortOrder
    review_text?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    instructor_id?: SortOrder
    rating?: SortOrder
  }

  export type ReviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    instructor_id?: SortOrder
    rating?: SortOrder
    review_text?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    instructor_id?: SortOrder
    rating?: SortOrder
    review_text?: SortOrder
    created_at?: SortOrder
  }

  export type ReviewsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    instructor_id?: SortOrder
    rating?: SortOrder
  }

  export type ShoppingCartCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    added_at?: SortOrder
  }

  export type ShoppingCartAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type ShoppingCartMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    added_at?: SortOrder
  }

  export type ShoppingCartMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    added_at?: SortOrder
  }

  export type ShoppingCartSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type SubscriptionsListRelationFilter = {
    every?: SubscriptionsWhereInput
    some?: SubscriptionsWhereInput
    none?: SubscriptionsWhereInput
  }

  export type SubscriptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionPlansCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    description?: SortOrder
  }

  export type SubscriptionPlansAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
  }

  export type SubscriptionPlansMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    description?: SortOrder
  }

  export type SubscriptionPlansMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    description?: SortOrder
  }

  export type SubscriptionPlansSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
  }

  export type EnumSubscriptions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.Subscriptions_status | EnumSubscriptions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Subscriptions_status[]
    notIn?: $Enums.Subscriptions_status[]
    not?: NestedEnumSubscriptions_statusFilter<$PrismaModel> | $Enums.Subscriptions_status
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SubscriptionPlansRelationFilter = {
    is?: SubscriptionPlansWhereInput
    isNot?: SubscriptionPlansWhereInput
  }

  export type SubscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type SubscriptionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type SubscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type SubscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type SubscriptionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type EnumSubscriptions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Subscriptions_status | EnumSubscriptions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Subscriptions_status[]
    notIn?: $Enums.Subscriptions_status[]
    not?: NestedEnumSubscriptions_statusWithAggregatesFilter<$PrismaModel> | $Enums.Subscriptions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptions_statusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptions_statusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type QuizAttemptsRelationFilter = {
    is?: QuizAttemptsWhereInput
    isNot?: QuizAttemptsWhereInput
  }

  export type AssessmentOptionsNullableRelationFilter = {
    is?: AssessmentOptionsWhereInput | null
    isNot?: AssessmentOptionsWhereInput | null
  }

  export type UserAnswersCountOrderByAggregateInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    question_id?: SortOrder
    selected_option_id?: SortOrder
    answer_text?: SortOrder
  }

  export type UserAnswersAvgOrderByAggregateInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    question_id?: SortOrder
    selected_option_id?: SortOrder
  }

  export type UserAnswersMaxOrderByAggregateInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    question_id?: SortOrder
    selected_option_id?: SortOrder
    answer_text?: SortOrder
  }

  export type UserAnswersMinOrderByAggregateInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    question_id?: SortOrder
    selected_option_id?: SortOrder
    answer_text?: SortOrder
  }

  export type UserAnswersSumOrderByAggregateInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    question_id?: SortOrder
    selected_option_id?: SortOrder
  }

  export type UserSavedCoursesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type UserSavedCoursesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type UserSavedCoursesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type UserSavedCoursesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type UserSavedCoursesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type EnumUsers_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.Users_role | EnumUsers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.Users_role[]
    notIn?: $Enums.Users_role[]
    not?: NestedEnumUsers_roleFilter<$PrismaModel> | $Enums.Users_role
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumUsers_instructor_application_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.Users_instructor_application_status | EnumUsers_instructor_application_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Users_instructor_application_status[]
    notIn?: $Enums.Users_instructor_application_status[]
    not?: NestedEnumUsers_instructor_application_statusFilter<$PrismaModel> | $Enums.Users_instructor_application_status
  }

  export type MessagesListRelationFilter = {
    every?: MessagesWhereInput
    some?: MessagesWhereInput
    none?: MessagesWhereInput
  }

  export type MultiFactorAuthListRelationFilter = {
    every?: MultiFactorAuthWhereInput
    some?: MultiFactorAuthWhereInput
    none?: MultiFactorAuthWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: NotificationsWhereInput
    some?: NotificationsWhereInput
    none?: NotificationsWhereInput
  }

  export type MessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MultiFactorAuthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    headline?: SortOrder
    biography?: SortOrder
    photo_url?: SortOrder
    field_of_learning?: SortOrder
    occupation?: SortOrder
    skills?: SortOrder
    interests?: SortOrder
    resume_url?: SortOrder
    instructor_application_status?: SortOrder
    instructor_application_submitted_at?: SortOrder
    instructor_reviewed_at?: SortOrder
    instructor_admin_comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    headline?: SortOrder
    biography?: SortOrder
    photo_url?: SortOrder
    field_of_learning?: SortOrder
    occupation?: SortOrder
    resume_url?: SortOrder
    instructor_application_status?: SortOrder
    instructor_application_submitted_at?: SortOrder
    instructor_reviewed_at?: SortOrder
    instructor_admin_comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    headline?: SortOrder
    biography?: SortOrder
    photo_url?: SortOrder
    field_of_learning?: SortOrder
    occupation?: SortOrder
    resume_url?: SortOrder
    instructor_application_status?: SortOrder
    instructor_application_submitted_at?: SortOrder
    instructor_reviewed_at?: SortOrder
    instructor_admin_comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumUsers_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Users_role | EnumUsers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.Users_role[]
    notIn?: $Enums.Users_role[]
    not?: NestedEnumUsers_roleWithAggregatesFilter<$PrismaModel> | $Enums.Users_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsers_roleFilter<$PrismaModel>
    _max?: NestedEnumUsers_roleFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumUsers_instructor_application_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Users_instructor_application_status | EnumUsers_instructor_application_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Users_instructor_application_status[]
    notIn?: $Enums.Users_instructor_application_status[]
    not?: NestedEnumUsers_instructor_application_statusWithAggregatesFilter<$PrismaModel> | $Enums.Users_instructor_application_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsers_instructor_application_statusFilter<$PrismaModel>
    _max?: NestedEnumUsers_instructor_application_statusFilter<$PrismaModel>
  }

  export type AssessmentQuestionsCreateNestedOneWithoutAssessmentOptionsInput = {
    create?: XOR<AssessmentQuestionsCreateWithoutAssessmentOptionsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentOptionsInput>
    connectOrCreate?: AssessmentQuestionsCreateOrConnectWithoutAssessmentOptionsInput
    connect?: AssessmentQuestionsWhereUniqueInput
  }

  export type UserAnswersCreateNestedManyWithoutAssessmentOptionsInput = {
    create?: XOR<UserAnswersCreateWithoutAssessmentOptionsInput, UserAnswersUncheckedCreateWithoutAssessmentOptionsInput> | UserAnswersCreateWithoutAssessmentOptionsInput[] | UserAnswersUncheckedCreateWithoutAssessmentOptionsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutAssessmentOptionsInput | UserAnswersCreateOrConnectWithoutAssessmentOptionsInput[]
    createMany?: UserAnswersCreateManyAssessmentOptionsInputEnvelope
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
  }

  export type UserAnswersUncheckedCreateNestedManyWithoutAssessmentOptionsInput = {
    create?: XOR<UserAnswersCreateWithoutAssessmentOptionsInput, UserAnswersUncheckedCreateWithoutAssessmentOptionsInput> | UserAnswersCreateWithoutAssessmentOptionsInput[] | UserAnswersUncheckedCreateWithoutAssessmentOptionsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutAssessmentOptionsInput | UserAnswersCreateOrConnectWithoutAssessmentOptionsInput[]
    createMany?: UserAnswersCreateManyAssessmentOptionsInputEnvelope
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type AssessmentQuestionsUpdateOneRequiredWithoutAssessmentOptionsNestedInput = {
    create?: XOR<AssessmentQuestionsCreateWithoutAssessmentOptionsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentOptionsInput>
    connectOrCreate?: AssessmentQuestionsCreateOrConnectWithoutAssessmentOptionsInput
    upsert?: AssessmentQuestionsUpsertWithoutAssessmentOptionsInput
    connect?: AssessmentQuestionsWhereUniqueInput
    update?: XOR<XOR<AssessmentQuestionsUpdateToOneWithWhereWithoutAssessmentOptionsInput, AssessmentQuestionsUpdateWithoutAssessmentOptionsInput>, AssessmentQuestionsUncheckedUpdateWithoutAssessmentOptionsInput>
  }

  export type UserAnswersUpdateManyWithoutAssessmentOptionsNestedInput = {
    create?: XOR<UserAnswersCreateWithoutAssessmentOptionsInput, UserAnswersUncheckedCreateWithoutAssessmentOptionsInput> | UserAnswersCreateWithoutAssessmentOptionsInput[] | UserAnswersUncheckedCreateWithoutAssessmentOptionsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutAssessmentOptionsInput | UserAnswersCreateOrConnectWithoutAssessmentOptionsInput[]
    upsert?: UserAnswersUpsertWithWhereUniqueWithoutAssessmentOptionsInput | UserAnswersUpsertWithWhereUniqueWithoutAssessmentOptionsInput[]
    createMany?: UserAnswersCreateManyAssessmentOptionsInputEnvelope
    set?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    disconnect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    delete?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    update?: UserAnswersUpdateWithWhereUniqueWithoutAssessmentOptionsInput | UserAnswersUpdateWithWhereUniqueWithoutAssessmentOptionsInput[]
    updateMany?: UserAnswersUpdateManyWithWhereWithoutAssessmentOptionsInput | UserAnswersUpdateManyWithWhereWithoutAssessmentOptionsInput[]
    deleteMany?: UserAnswersScalarWhereInput | UserAnswersScalarWhereInput[]
  }

  export type UserAnswersUncheckedUpdateManyWithoutAssessmentOptionsNestedInput = {
    create?: XOR<UserAnswersCreateWithoutAssessmentOptionsInput, UserAnswersUncheckedCreateWithoutAssessmentOptionsInput> | UserAnswersCreateWithoutAssessmentOptionsInput[] | UserAnswersUncheckedCreateWithoutAssessmentOptionsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutAssessmentOptionsInput | UserAnswersCreateOrConnectWithoutAssessmentOptionsInput[]
    upsert?: UserAnswersUpsertWithWhereUniqueWithoutAssessmentOptionsInput | UserAnswersUpsertWithWhereUniqueWithoutAssessmentOptionsInput[]
    createMany?: UserAnswersCreateManyAssessmentOptionsInputEnvelope
    set?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    disconnect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    delete?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    update?: UserAnswersUpdateWithWhereUniqueWithoutAssessmentOptionsInput | UserAnswersUpdateWithWhereUniqueWithoutAssessmentOptionsInput[]
    updateMany?: UserAnswersUpdateManyWithWhereWithoutAssessmentOptionsInput | UserAnswersUpdateManyWithWhereWithoutAssessmentOptionsInput[]
    deleteMany?: UserAnswersScalarWhereInput | UserAnswersScalarWhereInput[]
  }

  export type AssessmentOptionsCreateNestedManyWithoutAssessmentQuestionsInput = {
    create?: XOR<AssessmentOptionsCreateWithoutAssessmentQuestionsInput, AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput> | AssessmentOptionsCreateWithoutAssessmentQuestionsInput[] | AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput[]
    connectOrCreate?: AssessmentOptionsCreateOrConnectWithoutAssessmentQuestionsInput | AssessmentOptionsCreateOrConnectWithoutAssessmentQuestionsInput[]
    createMany?: AssessmentOptionsCreateManyAssessmentQuestionsInputEnvelope
    connect?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
  }

  export type AssessmentsCreateNestedOneWithoutAssessmentQuestionsInput = {
    create?: XOR<AssessmentsCreateWithoutAssessmentQuestionsInput, AssessmentsUncheckedCreateWithoutAssessmentQuestionsInput>
    connectOrCreate?: AssessmentsCreateOrConnectWithoutAssessmentQuestionsInput
    connect?: AssessmentsWhereUniqueInput
  }

  export type UserAnswersCreateNestedManyWithoutAssessmentQuestionsInput = {
    create?: XOR<UserAnswersCreateWithoutAssessmentQuestionsInput, UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput> | UserAnswersCreateWithoutAssessmentQuestionsInput[] | UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutAssessmentQuestionsInput | UserAnswersCreateOrConnectWithoutAssessmentQuestionsInput[]
    createMany?: UserAnswersCreateManyAssessmentQuestionsInputEnvelope
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
  }

  export type AssessmentOptionsUncheckedCreateNestedManyWithoutAssessmentQuestionsInput = {
    create?: XOR<AssessmentOptionsCreateWithoutAssessmentQuestionsInput, AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput> | AssessmentOptionsCreateWithoutAssessmentQuestionsInput[] | AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput[]
    connectOrCreate?: AssessmentOptionsCreateOrConnectWithoutAssessmentQuestionsInput | AssessmentOptionsCreateOrConnectWithoutAssessmentQuestionsInput[]
    createMany?: AssessmentOptionsCreateManyAssessmentQuestionsInputEnvelope
    connect?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
  }

  export type UserAnswersUncheckedCreateNestedManyWithoutAssessmentQuestionsInput = {
    create?: XOR<UserAnswersCreateWithoutAssessmentQuestionsInput, UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput> | UserAnswersCreateWithoutAssessmentQuestionsInput[] | UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutAssessmentQuestionsInput | UserAnswersCreateOrConnectWithoutAssessmentQuestionsInput[]
    createMany?: UserAnswersCreateManyAssessmentQuestionsInputEnvelope
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput = {
    set?: $Enums.AssessmentQuestions_question_type
  }

  export type AssessmentOptionsUpdateManyWithoutAssessmentQuestionsNestedInput = {
    create?: XOR<AssessmentOptionsCreateWithoutAssessmentQuestionsInput, AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput> | AssessmentOptionsCreateWithoutAssessmentQuestionsInput[] | AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput[]
    connectOrCreate?: AssessmentOptionsCreateOrConnectWithoutAssessmentQuestionsInput | AssessmentOptionsCreateOrConnectWithoutAssessmentQuestionsInput[]
    upsert?: AssessmentOptionsUpsertWithWhereUniqueWithoutAssessmentQuestionsInput | AssessmentOptionsUpsertWithWhereUniqueWithoutAssessmentQuestionsInput[]
    createMany?: AssessmentOptionsCreateManyAssessmentQuestionsInputEnvelope
    set?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
    disconnect?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
    delete?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
    connect?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
    update?: AssessmentOptionsUpdateWithWhereUniqueWithoutAssessmentQuestionsInput | AssessmentOptionsUpdateWithWhereUniqueWithoutAssessmentQuestionsInput[]
    updateMany?: AssessmentOptionsUpdateManyWithWhereWithoutAssessmentQuestionsInput | AssessmentOptionsUpdateManyWithWhereWithoutAssessmentQuestionsInput[]
    deleteMany?: AssessmentOptionsScalarWhereInput | AssessmentOptionsScalarWhereInput[]
  }

  export type AssessmentsUpdateOneRequiredWithoutAssessmentQuestionsNestedInput = {
    create?: XOR<AssessmentsCreateWithoutAssessmentQuestionsInput, AssessmentsUncheckedCreateWithoutAssessmentQuestionsInput>
    connectOrCreate?: AssessmentsCreateOrConnectWithoutAssessmentQuestionsInput
    upsert?: AssessmentsUpsertWithoutAssessmentQuestionsInput
    connect?: AssessmentsWhereUniqueInput
    update?: XOR<XOR<AssessmentsUpdateToOneWithWhereWithoutAssessmentQuestionsInput, AssessmentsUpdateWithoutAssessmentQuestionsInput>, AssessmentsUncheckedUpdateWithoutAssessmentQuestionsInput>
  }

  export type UserAnswersUpdateManyWithoutAssessmentQuestionsNestedInput = {
    create?: XOR<UserAnswersCreateWithoutAssessmentQuestionsInput, UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput> | UserAnswersCreateWithoutAssessmentQuestionsInput[] | UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutAssessmentQuestionsInput | UserAnswersCreateOrConnectWithoutAssessmentQuestionsInput[]
    upsert?: UserAnswersUpsertWithWhereUniqueWithoutAssessmentQuestionsInput | UserAnswersUpsertWithWhereUniqueWithoutAssessmentQuestionsInput[]
    createMany?: UserAnswersCreateManyAssessmentQuestionsInputEnvelope
    set?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    disconnect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    delete?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    update?: UserAnswersUpdateWithWhereUniqueWithoutAssessmentQuestionsInput | UserAnswersUpdateWithWhereUniqueWithoutAssessmentQuestionsInput[]
    updateMany?: UserAnswersUpdateManyWithWhereWithoutAssessmentQuestionsInput | UserAnswersUpdateManyWithWhereWithoutAssessmentQuestionsInput[]
    deleteMany?: UserAnswersScalarWhereInput | UserAnswersScalarWhereInput[]
  }

  export type AssessmentOptionsUncheckedUpdateManyWithoutAssessmentQuestionsNestedInput = {
    create?: XOR<AssessmentOptionsCreateWithoutAssessmentQuestionsInput, AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput> | AssessmentOptionsCreateWithoutAssessmentQuestionsInput[] | AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput[]
    connectOrCreate?: AssessmentOptionsCreateOrConnectWithoutAssessmentQuestionsInput | AssessmentOptionsCreateOrConnectWithoutAssessmentQuestionsInput[]
    upsert?: AssessmentOptionsUpsertWithWhereUniqueWithoutAssessmentQuestionsInput | AssessmentOptionsUpsertWithWhereUniqueWithoutAssessmentQuestionsInput[]
    createMany?: AssessmentOptionsCreateManyAssessmentQuestionsInputEnvelope
    set?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
    disconnect?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
    delete?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
    connect?: AssessmentOptionsWhereUniqueInput | AssessmentOptionsWhereUniqueInput[]
    update?: AssessmentOptionsUpdateWithWhereUniqueWithoutAssessmentQuestionsInput | AssessmentOptionsUpdateWithWhereUniqueWithoutAssessmentQuestionsInput[]
    updateMany?: AssessmentOptionsUpdateManyWithWhereWithoutAssessmentQuestionsInput | AssessmentOptionsUpdateManyWithWhereWithoutAssessmentQuestionsInput[]
    deleteMany?: AssessmentOptionsScalarWhereInput | AssessmentOptionsScalarWhereInput[]
  }

  export type UserAnswersUncheckedUpdateManyWithoutAssessmentQuestionsNestedInput = {
    create?: XOR<UserAnswersCreateWithoutAssessmentQuestionsInput, UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput> | UserAnswersCreateWithoutAssessmentQuestionsInput[] | UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutAssessmentQuestionsInput | UserAnswersCreateOrConnectWithoutAssessmentQuestionsInput[]
    upsert?: UserAnswersUpsertWithWhereUniqueWithoutAssessmentQuestionsInput | UserAnswersUpsertWithWhereUniqueWithoutAssessmentQuestionsInput[]
    createMany?: UserAnswersCreateManyAssessmentQuestionsInputEnvelope
    set?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    disconnect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    delete?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    update?: UserAnswersUpdateWithWhereUniqueWithoutAssessmentQuestionsInput | UserAnswersUpdateWithWhereUniqueWithoutAssessmentQuestionsInput[]
    updateMany?: UserAnswersUpdateManyWithWhereWithoutAssessmentQuestionsInput | UserAnswersUpdateManyWithWhereWithoutAssessmentQuestionsInput[]
    deleteMany?: UserAnswersScalarWhereInput | UserAnswersScalarWhereInput[]
  }

  export type AssessmentQuestionsCreateNestedManyWithoutAssessmentsInput = {
    create?: XOR<AssessmentQuestionsCreateWithoutAssessmentsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput> | AssessmentQuestionsCreateWithoutAssessmentsInput[] | AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput[]
    connectOrCreate?: AssessmentQuestionsCreateOrConnectWithoutAssessmentsInput | AssessmentQuestionsCreateOrConnectWithoutAssessmentsInput[]
    createMany?: AssessmentQuestionsCreateManyAssessmentsInputEnvelope
    connect?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
  }

  export type CourseContentCreateNestedOneWithoutAssessmentsInput = {
    create?: XOR<CourseContentCreateWithoutAssessmentsInput, CourseContentUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutAssessmentsInput
    connect?: CourseContentWhereUniqueInput
  }

  export type QuizAttemptsCreateNestedManyWithoutAssessmentsInput = {
    create?: XOR<QuizAttemptsCreateWithoutAssessmentsInput, QuizAttemptsUncheckedCreateWithoutAssessmentsInput> | QuizAttemptsCreateWithoutAssessmentsInput[] | QuizAttemptsUncheckedCreateWithoutAssessmentsInput[]
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutAssessmentsInput | QuizAttemptsCreateOrConnectWithoutAssessmentsInput[]
    createMany?: QuizAttemptsCreateManyAssessmentsInputEnvelope
    connect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
  }

  export type AssessmentQuestionsUncheckedCreateNestedManyWithoutAssessmentsInput = {
    create?: XOR<AssessmentQuestionsCreateWithoutAssessmentsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput> | AssessmentQuestionsCreateWithoutAssessmentsInput[] | AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput[]
    connectOrCreate?: AssessmentQuestionsCreateOrConnectWithoutAssessmentsInput | AssessmentQuestionsCreateOrConnectWithoutAssessmentsInput[]
    createMany?: AssessmentQuestionsCreateManyAssessmentsInputEnvelope
    connect?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
  }

  export type QuizAttemptsUncheckedCreateNestedManyWithoutAssessmentsInput = {
    create?: XOR<QuizAttemptsCreateWithoutAssessmentsInput, QuizAttemptsUncheckedCreateWithoutAssessmentsInput> | QuizAttemptsCreateWithoutAssessmentsInput[] | QuizAttemptsUncheckedCreateWithoutAssessmentsInput[]
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutAssessmentsInput | QuizAttemptsCreateOrConnectWithoutAssessmentsInput[]
    createMany?: QuizAttemptsCreateManyAssessmentsInputEnvelope
    connect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
  }

  export type AssessmentQuestionsUpdateManyWithoutAssessmentsNestedInput = {
    create?: XOR<AssessmentQuestionsCreateWithoutAssessmentsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput> | AssessmentQuestionsCreateWithoutAssessmentsInput[] | AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput[]
    connectOrCreate?: AssessmentQuestionsCreateOrConnectWithoutAssessmentsInput | AssessmentQuestionsCreateOrConnectWithoutAssessmentsInput[]
    upsert?: AssessmentQuestionsUpsertWithWhereUniqueWithoutAssessmentsInput | AssessmentQuestionsUpsertWithWhereUniqueWithoutAssessmentsInput[]
    createMany?: AssessmentQuestionsCreateManyAssessmentsInputEnvelope
    set?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
    disconnect?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
    delete?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
    connect?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
    update?: AssessmentQuestionsUpdateWithWhereUniqueWithoutAssessmentsInput | AssessmentQuestionsUpdateWithWhereUniqueWithoutAssessmentsInput[]
    updateMany?: AssessmentQuestionsUpdateManyWithWhereWithoutAssessmentsInput | AssessmentQuestionsUpdateManyWithWhereWithoutAssessmentsInput[]
    deleteMany?: AssessmentQuestionsScalarWhereInput | AssessmentQuestionsScalarWhereInput[]
  }

  export type CourseContentUpdateOneRequiredWithoutAssessmentsNestedInput = {
    create?: XOR<CourseContentCreateWithoutAssessmentsInput, CourseContentUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutAssessmentsInput
    upsert?: CourseContentUpsertWithoutAssessmentsInput
    connect?: CourseContentWhereUniqueInput
    update?: XOR<XOR<CourseContentUpdateToOneWithWhereWithoutAssessmentsInput, CourseContentUpdateWithoutAssessmentsInput>, CourseContentUncheckedUpdateWithoutAssessmentsInput>
  }

  export type QuizAttemptsUpdateManyWithoutAssessmentsNestedInput = {
    create?: XOR<QuizAttemptsCreateWithoutAssessmentsInput, QuizAttemptsUncheckedCreateWithoutAssessmentsInput> | QuizAttemptsCreateWithoutAssessmentsInput[] | QuizAttemptsUncheckedCreateWithoutAssessmentsInput[]
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutAssessmentsInput | QuizAttemptsCreateOrConnectWithoutAssessmentsInput[]
    upsert?: QuizAttemptsUpsertWithWhereUniqueWithoutAssessmentsInput | QuizAttemptsUpsertWithWhereUniqueWithoutAssessmentsInput[]
    createMany?: QuizAttemptsCreateManyAssessmentsInputEnvelope
    set?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    disconnect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    delete?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    connect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    update?: QuizAttemptsUpdateWithWhereUniqueWithoutAssessmentsInput | QuizAttemptsUpdateWithWhereUniqueWithoutAssessmentsInput[]
    updateMany?: QuizAttemptsUpdateManyWithWhereWithoutAssessmentsInput | QuizAttemptsUpdateManyWithWhereWithoutAssessmentsInput[]
    deleteMany?: QuizAttemptsScalarWhereInput | QuizAttemptsScalarWhereInput[]
  }

  export type AssessmentQuestionsUncheckedUpdateManyWithoutAssessmentsNestedInput = {
    create?: XOR<AssessmentQuestionsCreateWithoutAssessmentsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput> | AssessmentQuestionsCreateWithoutAssessmentsInput[] | AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput[]
    connectOrCreate?: AssessmentQuestionsCreateOrConnectWithoutAssessmentsInput | AssessmentQuestionsCreateOrConnectWithoutAssessmentsInput[]
    upsert?: AssessmentQuestionsUpsertWithWhereUniqueWithoutAssessmentsInput | AssessmentQuestionsUpsertWithWhereUniqueWithoutAssessmentsInput[]
    createMany?: AssessmentQuestionsCreateManyAssessmentsInputEnvelope
    set?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
    disconnect?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
    delete?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
    connect?: AssessmentQuestionsWhereUniqueInput | AssessmentQuestionsWhereUniqueInput[]
    update?: AssessmentQuestionsUpdateWithWhereUniqueWithoutAssessmentsInput | AssessmentQuestionsUpdateWithWhereUniqueWithoutAssessmentsInput[]
    updateMany?: AssessmentQuestionsUpdateManyWithWhereWithoutAssessmentsInput | AssessmentQuestionsUpdateManyWithWhereWithoutAssessmentsInput[]
    deleteMany?: AssessmentQuestionsScalarWhereInput | AssessmentQuestionsScalarWhereInput[]
  }

  export type QuizAttemptsUncheckedUpdateManyWithoutAssessmentsNestedInput = {
    create?: XOR<QuizAttemptsCreateWithoutAssessmentsInput, QuizAttemptsUncheckedCreateWithoutAssessmentsInput> | QuizAttemptsCreateWithoutAssessmentsInput[] | QuizAttemptsUncheckedCreateWithoutAssessmentsInput[]
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutAssessmentsInput | QuizAttemptsCreateOrConnectWithoutAssessmentsInput[]
    upsert?: QuizAttemptsUpsertWithWhereUniqueWithoutAssessmentsInput | QuizAttemptsUpsertWithWhereUniqueWithoutAssessmentsInput[]
    createMany?: QuizAttemptsCreateManyAssessmentsInputEnvelope
    set?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    disconnect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    delete?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    connect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    update?: QuizAttemptsUpdateWithWhereUniqueWithoutAssessmentsInput | QuizAttemptsUpdateWithWhereUniqueWithoutAssessmentsInput[]
    updateMany?: QuizAttemptsUpdateManyWithWhereWithoutAssessmentsInput | QuizAttemptsUpdateManyWithWhereWithoutAssessmentsInput[]
    deleteMany?: QuizAttemptsScalarWhereInput | QuizAttemptsScalarWhereInput[]
  }

  export type CoursesCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<CoursesCreateWithoutCategoriesInput, CoursesUncheckedCreateWithoutCategoriesInput> | CoursesCreateWithoutCategoriesInput[] | CoursesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutCategoriesInput | CoursesCreateOrConnectWithoutCategoriesInput[]
    createMany?: CoursesCreateManyCategoriesInputEnvelope
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
  }

  export type CoursesUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<CoursesCreateWithoutCategoriesInput, CoursesUncheckedCreateWithoutCategoriesInput> | CoursesCreateWithoutCategoriesInput[] | CoursesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutCategoriesInput | CoursesCreateOrConnectWithoutCategoriesInput[]
    createMany?: CoursesCreateManyCategoriesInputEnvelope
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
  }

  export type CoursesUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<CoursesCreateWithoutCategoriesInput, CoursesUncheckedCreateWithoutCategoriesInput> | CoursesCreateWithoutCategoriesInput[] | CoursesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutCategoriesInput | CoursesCreateOrConnectWithoutCategoriesInput[]
    upsert?: CoursesUpsertWithWhereUniqueWithoutCategoriesInput | CoursesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: CoursesCreateManyCategoriesInputEnvelope
    set?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    disconnect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    delete?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    update?: CoursesUpdateWithWhereUniqueWithoutCategoriesInput | CoursesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: CoursesUpdateManyWithWhereWithoutCategoriesInput | CoursesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
  }

  export type CoursesUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<CoursesCreateWithoutCategoriesInput, CoursesUncheckedCreateWithoutCategoriesInput> | CoursesCreateWithoutCategoriesInput[] | CoursesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutCategoriesInput | CoursesCreateOrConnectWithoutCategoriesInput[]
    upsert?: CoursesUpsertWithWhereUniqueWithoutCategoriesInput | CoursesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: CoursesCreateManyCategoriesInputEnvelope
    set?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    disconnect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    delete?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    update?: CoursesUpdateWithWhereUniqueWithoutCategoriesInput | CoursesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: CoursesUpdateManyWithWhereWithoutCategoriesInput | CoursesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
  }

  export type CoursesCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<CoursesCreateWithoutCertificatesInput, CoursesUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCertificatesInput
    connect?: CoursesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<UsersCreateWithoutCertificatesInput, UsersUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCertificatesInput
    connect?: UsersWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CoursesUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<CoursesCreateWithoutCertificatesInput, CoursesUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCertificatesInput
    upsert?: CoursesUpsertWithoutCertificatesInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutCertificatesInput, CoursesUpdateWithoutCertificatesInput>, CoursesUncheckedUpdateWithoutCertificatesInput>
  }

  export type UsersUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<UsersCreateWithoutCertificatesInput, UsersUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCertificatesInput
    upsert?: UsersUpsertWithoutCertificatesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCertificatesInput, UsersUpdateWithoutCertificatesInput>, UsersUncheckedUpdateWithoutCertificatesInput>
  }

  export type AssessmentsCreateNestedManyWithoutCourseContentInput = {
    create?: XOR<AssessmentsCreateWithoutCourseContentInput, AssessmentsUncheckedCreateWithoutCourseContentInput> | AssessmentsCreateWithoutCourseContentInput[] | AssessmentsUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: AssessmentsCreateOrConnectWithoutCourseContentInput | AssessmentsCreateOrConnectWithoutCourseContentInput[]
    createMany?: AssessmentsCreateManyCourseContentInputEnvelope
    connect?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
  }

  export type CoursesCreateNestedOneWithoutCourseContentInput = {
    create?: XOR<CoursesCreateWithoutCourseContentInput, CoursesUncheckedCreateWithoutCourseContentInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCourseContentInput
    connect?: CoursesWhereUniqueInput
  }

  export type CourseContentCreateNestedOneWithoutOther_CourseContentInput = {
    create?: XOR<CourseContentCreateWithoutOther_CourseContentInput, CourseContentUncheckedCreateWithoutOther_CourseContentInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutOther_CourseContentInput
    connect?: CourseContentWhereUniqueInput
  }

  export type CourseContentCreateNestedManyWithoutCourseContentInput = {
    create?: XOR<CourseContentCreateWithoutCourseContentInput, CourseContentUncheckedCreateWithoutCourseContentInput> | CourseContentCreateWithoutCourseContentInput[] | CourseContentUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCourseContentInput | CourseContentCreateOrConnectWithoutCourseContentInput[]
    createMany?: CourseContentCreateManyCourseContentInputEnvelope
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
  }

  export type LessonProgressCreateNestedManyWithoutCourseContentInput = {
    create?: XOR<LessonProgressCreateWithoutCourseContentInput, LessonProgressUncheckedCreateWithoutCourseContentInput> | LessonProgressCreateWithoutCourseContentInput[] | LessonProgressUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutCourseContentInput | LessonProgressCreateOrConnectWithoutCourseContentInput[]
    createMany?: LessonProgressCreateManyCourseContentInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type AssessmentsUncheckedCreateNestedManyWithoutCourseContentInput = {
    create?: XOR<AssessmentsCreateWithoutCourseContentInput, AssessmentsUncheckedCreateWithoutCourseContentInput> | AssessmentsCreateWithoutCourseContentInput[] | AssessmentsUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: AssessmentsCreateOrConnectWithoutCourseContentInput | AssessmentsCreateOrConnectWithoutCourseContentInput[]
    createMany?: AssessmentsCreateManyCourseContentInputEnvelope
    connect?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
  }

  export type CourseContentUncheckedCreateNestedManyWithoutCourseContentInput = {
    create?: XOR<CourseContentCreateWithoutCourseContentInput, CourseContentUncheckedCreateWithoutCourseContentInput> | CourseContentCreateWithoutCourseContentInput[] | CourseContentUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCourseContentInput | CourseContentCreateOrConnectWithoutCourseContentInput[]
    createMany?: CourseContentCreateManyCourseContentInputEnvelope
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
  }

  export type LessonProgressUncheckedCreateNestedManyWithoutCourseContentInput = {
    create?: XOR<LessonProgressCreateWithoutCourseContentInput, LessonProgressUncheckedCreateWithoutCourseContentInput> | LessonProgressCreateWithoutCourseContentInput[] | LessonProgressUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutCourseContentInput | LessonProgressCreateOrConnectWithoutCourseContentInput[]
    createMany?: LessonProgressCreateManyCourseContentInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type EnumCourseContent_typeFieldUpdateOperationsInput = {
    set?: $Enums.CourseContent_type
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AssessmentsUpdateManyWithoutCourseContentNestedInput = {
    create?: XOR<AssessmentsCreateWithoutCourseContentInput, AssessmentsUncheckedCreateWithoutCourseContentInput> | AssessmentsCreateWithoutCourseContentInput[] | AssessmentsUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: AssessmentsCreateOrConnectWithoutCourseContentInput | AssessmentsCreateOrConnectWithoutCourseContentInput[]
    upsert?: AssessmentsUpsertWithWhereUniqueWithoutCourseContentInput | AssessmentsUpsertWithWhereUniqueWithoutCourseContentInput[]
    createMany?: AssessmentsCreateManyCourseContentInputEnvelope
    set?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
    disconnect?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
    delete?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
    connect?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
    update?: AssessmentsUpdateWithWhereUniqueWithoutCourseContentInput | AssessmentsUpdateWithWhereUniqueWithoutCourseContentInput[]
    updateMany?: AssessmentsUpdateManyWithWhereWithoutCourseContentInput | AssessmentsUpdateManyWithWhereWithoutCourseContentInput[]
    deleteMany?: AssessmentsScalarWhereInput | AssessmentsScalarWhereInput[]
  }

  export type CoursesUpdateOneRequiredWithoutCourseContentNestedInput = {
    create?: XOR<CoursesCreateWithoutCourseContentInput, CoursesUncheckedCreateWithoutCourseContentInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCourseContentInput
    upsert?: CoursesUpsertWithoutCourseContentInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutCourseContentInput, CoursesUpdateWithoutCourseContentInput>, CoursesUncheckedUpdateWithoutCourseContentInput>
  }

  export type CourseContentUpdateOneWithoutOther_CourseContentNestedInput = {
    create?: XOR<CourseContentCreateWithoutOther_CourseContentInput, CourseContentUncheckedCreateWithoutOther_CourseContentInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutOther_CourseContentInput
    upsert?: CourseContentUpsertWithoutOther_CourseContentInput
    disconnect?: CourseContentWhereInput | boolean
    delete?: CourseContentWhereInput | boolean
    connect?: CourseContentWhereUniqueInput
    update?: XOR<XOR<CourseContentUpdateToOneWithWhereWithoutOther_CourseContentInput, CourseContentUpdateWithoutOther_CourseContentInput>, CourseContentUncheckedUpdateWithoutOther_CourseContentInput>
  }

  export type CourseContentUpdateManyWithoutCourseContentNestedInput = {
    create?: XOR<CourseContentCreateWithoutCourseContentInput, CourseContentUncheckedCreateWithoutCourseContentInput> | CourseContentCreateWithoutCourseContentInput[] | CourseContentUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCourseContentInput | CourseContentCreateOrConnectWithoutCourseContentInput[]
    upsert?: CourseContentUpsertWithWhereUniqueWithoutCourseContentInput | CourseContentUpsertWithWhereUniqueWithoutCourseContentInput[]
    createMany?: CourseContentCreateManyCourseContentInputEnvelope
    set?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    disconnect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    delete?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    update?: CourseContentUpdateWithWhereUniqueWithoutCourseContentInput | CourseContentUpdateWithWhereUniqueWithoutCourseContentInput[]
    updateMany?: CourseContentUpdateManyWithWhereWithoutCourseContentInput | CourseContentUpdateManyWithWhereWithoutCourseContentInput[]
    deleteMany?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
  }

  export type LessonProgressUpdateManyWithoutCourseContentNestedInput = {
    create?: XOR<LessonProgressCreateWithoutCourseContentInput, LessonProgressUncheckedCreateWithoutCourseContentInput> | LessonProgressCreateWithoutCourseContentInput[] | LessonProgressUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutCourseContentInput | LessonProgressCreateOrConnectWithoutCourseContentInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutCourseContentInput | LessonProgressUpsertWithWhereUniqueWithoutCourseContentInput[]
    createMany?: LessonProgressCreateManyCourseContentInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutCourseContentInput | LessonProgressUpdateWithWhereUniqueWithoutCourseContentInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutCourseContentInput | LessonProgressUpdateManyWithWhereWithoutCourseContentInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type AssessmentsUncheckedUpdateManyWithoutCourseContentNestedInput = {
    create?: XOR<AssessmentsCreateWithoutCourseContentInput, AssessmentsUncheckedCreateWithoutCourseContentInput> | AssessmentsCreateWithoutCourseContentInput[] | AssessmentsUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: AssessmentsCreateOrConnectWithoutCourseContentInput | AssessmentsCreateOrConnectWithoutCourseContentInput[]
    upsert?: AssessmentsUpsertWithWhereUniqueWithoutCourseContentInput | AssessmentsUpsertWithWhereUniqueWithoutCourseContentInput[]
    createMany?: AssessmentsCreateManyCourseContentInputEnvelope
    set?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
    disconnect?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
    delete?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
    connect?: AssessmentsWhereUniqueInput | AssessmentsWhereUniqueInput[]
    update?: AssessmentsUpdateWithWhereUniqueWithoutCourseContentInput | AssessmentsUpdateWithWhereUniqueWithoutCourseContentInput[]
    updateMany?: AssessmentsUpdateManyWithWhereWithoutCourseContentInput | AssessmentsUpdateManyWithWhereWithoutCourseContentInput[]
    deleteMany?: AssessmentsScalarWhereInput | AssessmentsScalarWhereInput[]
  }

  export type CourseContentUncheckedUpdateManyWithoutCourseContentNestedInput = {
    create?: XOR<CourseContentCreateWithoutCourseContentInput, CourseContentUncheckedCreateWithoutCourseContentInput> | CourseContentCreateWithoutCourseContentInput[] | CourseContentUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCourseContentInput | CourseContentCreateOrConnectWithoutCourseContentInput[]
    upsert?: CourseContentUpsertWithWhereUniqueWithoutCourseContentInput | CourseContentUpsertWithWhereUniqueWithoutCourseContentInput[]
    createMany?: CourseContentCreateManyCourseContentInputEnvelope
    set?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    disconnect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    delete?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    update?: CourseContentUpdateWithWhereUniqueWithoutCourseContentInput | CourseContentUpdateWithWhereUniqueWithoutCourseContentInput[]
    updateMany?: CourseContentUpdateManyWithWhereWithoutCourseContentInput | CourseContentUpdateManyWithWhereWithoutCourseContentInput[]
    deleteMany?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
  }

  export type LessonProgressUncheckedUpdateManyWithoutCourseContentNestedInput = {
    create?: XOR<LessonProgressCreateWithoutCourseContentInput, LessonProgressUncheckedCreateWithoutCourseContentInput> | LessonProgressCreateWithoutCourseContentInput[] | LessonProgressUncheckedCreateWithoutCourseContentInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutCourseContentInput | LessonProgressCreateOrConnectWithoutCourseContentInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutCourseContentInput | LessonProgressUpsertWithWhereUniqueWithoutCourseContentInput[]
    createMany?: LessonProgressCreateManyCourseContentInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutCourseContentInput | LessonProgressUpdateWithWhereUniqueWithoutCourseContentInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutCourseContentInput | LessonProgressUpdateManyWithWhereWithoutCourseContentInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type CoursesCreateNestedOneWithoutCourseTagsInput = {
    create?: XOR<CoursesCreateWithoutCourseTagsInput, CoursesUncheckedCreateWithoutCourseTagsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCourseTagsInput
    connect?: CoursesWhereUniqueInput
  }

  export type EnumCourseTags_tag_typeFieldUpdateOperationsInput = {
    set?: $Enums.CourseTags_tag_type
  }

  export type CoursesUpdateOneRequiredWithoutCourseTagsNestedInput = {
    create?: XOR<CoursesCreateWithoutCourseTagsInput, CoursesUncheckedCreateWithoutCourseTagsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCourseTagsInput
    upsert?: CoursesUpsertWithoutCourseTagsInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutCourseTagsInput, CoursesUpdateWithoutCourseTagsInput>, CoursesUncheckedUpdateWithoutCourseTagsInput>
  }

  export type CertificatesCreateNestedManyWithoutCoursesInput = {
    create?: XOR<CertificatesCreateWithoutCoursesInput, CertificatesUncheckedCreateWithoutCoursesInput> | CertificatesCreateWithoutCoursesInput[] | CertificatesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CertificatesCreateOrConnectWithoutCoursesInput | CertificatesCreateOrConnectWithoutCoursesInput[]
    createMany?: CertificatesCreateManyCoursesInputEnvelope
    connect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
  }

  export type CourseContentCreateNestedManyWithoutCoursesInput = {
    create?: XOR<CourseContentCreateWithoutCoursesInput, CourseContentUncheckedCreateWithoutCoursesInput> | CourseContentCreateWithoutCoursesInput[] | CourseContentUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCoursesInput | CourseContentCreateOrConnectWithoutCoursesInput[]
    createMany?: CourseContentCreateManyCoursesInputEnvelope
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
  }

  export type CourseTagsCreateNestedManyWithoutCoursesInput = {
    create?: XOR<CourseTagsCreateWithoutCoursesInput, CourseTagsUncheckedCreateWithoutCoursesInput> | CourseTagsCreateWithoutCoursesInput[] | CourseTagsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CourseTagsCreateOrConnectWithoutCoursesInput | CourseTagsCreateOrConnectWithoutCoursesInput[]
    createMany?: CourseTagsCreateManyCoursesInputEnvelope
    connect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
  }

  export type CategoriesCreateNestedOneWithoutCoursesInput = {
    create?: XOR<CategoriesCreateWithoutCoursesInput, CategoriesUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutCoursesInput
    connect?: CategoriesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UsersCreateWithoutCoursesInput, UsersUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCoursesInput
    connect?: UsersWhereUniqueInput
  }

  export type EnrollmentsCreateNestedManyWithoutCoursesInput = {
    create?: XOR<EnrollmentsCreateWithoutCoursesInput, EnrollmentsUncheckedCreateWithoutCoursesInput> | EnrollmentsCreateWithoutCoursesInput[] | EnrollmentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: EnrollmentsCreateOrConnectWithoutCoursesInput | EnrollmentsCreateOrConnectWithoutCoursesInput[]
    createMany?: EnrollmentsCreateManyCoursesInputEnvelope
    connect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
  }

  export type PaymentsCreateNestedManyWithoutCoursesInput = {
    create?: XOR<PaymentsCreateWithoutCoursesInput, PaymentsUncheckedCreateWithoutCoursesInput> | PaymentsCreateWithoutCoursesInput[] | PaymentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutCoursesInput | PaymentsCreateOrConnectWithoutCoursesInput[]
    createMany?: PaymentsCreateManyCoursesInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type ReviewsCreateNestedManyWithoutCoursesInput = {
    create?: XOR<ReviewsCreateWithoutCoursesInput, ReviewsUncheckedCreateWithoutCoursesInput> | ReviewsCreateWithoutCoursesInput[] | ReviewsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutCoursesInput | ReviewsCreateOrConnectWithoutCoursesInput[]
    createMany?: ReviewsCreateManyCoursesInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type ShoppingCartCreateNestedManyWithoutCoursesInput = {
    create?: XOR<ShoppingCartCreateWithoutCoursesInput, ShoppingCartUncheckedCreateWithoutCoursesInput> | ShoppingCartCreateWithoutCoursesInput[] | ShoppingCartUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutCoursesInput | ShoppingCartCreateOrConnectWithoutCoursesInput[]
    createMany?: ShoppingCartCreateManyCoursesInputEnvelope
    connect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
  }

  export type UserSavedCoursesCreateNestedManyWithoutCoursesInput = {
    create?: XOR<UserSavedCoursesCreateWithoutCoursesInput, UserSavedCoursesUncheckedCreateWithoutCoursesInput> | UserSavedCoursesCreateWithoutCoursesInput[] | UserSavedCoursesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: UserSavedCoursesCreateOrConnectWithoutCoursesInput | UserSavedCoursesCreateOrConnectWithoutCoursesInput[]
    createMany?: UserSavedCoursesCreateManyCoursesInputEnvelope
    connect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
  }

  export type CertificatesUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<CertificatesCreateWithoutCoursesInput, CertificatesUncheckedCreateWithoutCoursesInput> | CertificatesCreateWithoutCoursesInput[] | CertificatesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CertificatesCreateOrConnectWithoutCoursesInput | CertificatesCreateOrConnectWithoutCoursesInput[]
    createMany?: CertificatesCreateManyCoursesInputEnvelope
    connect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
  }

  export type CourseContentUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<CourseContentCreateWithoutCoursesInput, CourseContentUncheckedCreateWithoutCoursesInput> | CourseContentCreateWithoutCoursesInput[] | CourseContentUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCoursesInput | CourseContentCreateOrConnectWithoutCoursesInput[]
    createMany?: CourseContentCreateManyCoursesInputEnvelope
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
  }

  export type CourseTagsUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<CourseTagsCreateWithoutCoursesInput, CourseTagsUncheckedCreateWithoutCoursesInput> | CourseTagsCreateWithoutCoursesInput[] | CourseTagsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CourseTagsCreateOrConnectWithoutCoursesInput | CourseTagsCreateOrConnectWithoutCoursesInput[]
    createMany?: CourseTagsCreateManyCoursesInputEnvelope
    connect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
  }

  export type EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<EnrollmentsCreateWithoutCoursesInput, EnrollmentsUncheckedCreateWithoutCoursesInput> | EnrollmentsCreateWithoutCoursesInput[] | EnrollmentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: EnrollmentsCreateOrConnectWithoutCoursesInput | EnrollmentsCreateOrConnectWithoutCoursesInput[]
    createMany?: EnrollmentsCreateManyCoursesInputEnvelope
    connect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<PaymentsCreateWithoutCoursesInput, PaymentsUncheckedCreateWithoutCoursesInput> | PaymentsCreateWithoutCoursesInput[] | PaymentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutCoursesInput | PaymentsCreateOrConnectWithoutCoursesInput[]
    createMany?: PaymentsCreateManyCoursesInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type ReviewsUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<ReviewsCreateWithoutCoursesInput, ReviewsUncheckedCreateWithoutCoursesInput> | ReviewsCreateWithoutCoursesInput[] | ReviewsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutCoursesInput | ReviewsCreateOrConnectWithoutCoursesInput[]
    createMany?: ReviewsCreateManyCoursesInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<ShoppingCartCreateWithoutCoursesInput, ShoppingCartUncheckedCreateWithoutCoursesInput> | ShoppingCartCreateWithoutCoursesInput[] | ShoppingCartUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutCoursesInput | ShoppingCartCreateOrConnectWithoutCoursesInput[]
    createMany?: ShoppingCartCreateManyCoursesInputEnvelope
    connect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
  }

  export type UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<UserSavedCoursesCreateWithoutCoursesInput, UserSavedCoursesUncheckedCreateWithoutCoursesInput> | UserSavedCoursesCreateWithoutCoursesInput[] | UserSavedCoursesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: UserSavedCoursesCreateOrConnectWithoutCoursesInput | UserSavedCoursesCreateOrConnectWithoutCoursesInput[]
    createMany?: UserSavedCoursesCreateManyCoursesInputEnvelope
    connect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumCourses_levelFieldUpdateOperationsInput = {
    set?: $Enums.Courses_level
  }

  export type CertificatesUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<CertificatesCreateWithoutCoursesInput, CertificatesUncheckedCreateWithoutCoursesInput> | CertificatesCreateWithoutCoursesInput[] | CertificatesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CertificatesCreateOrConnectWithoutCoursesInput | CertificatesCreateOrConnectWithoutCoursesInput[]
    upsert?: CertificatesUpsertWithWhereUniqueWithoutCoursesInput | CertificatesUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: CertificatesCreateManyCoursesInputEnvelope
    set?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    disconnect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    delete?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    connect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    update?: CertificatesUpdateWithWhereUniqueWithoutCoursesInput | CertificatesUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: CertificatesUpdateManyWithWhereWithoutCoursesInput | CertificatesUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: CertificatesScalarWhereInput | CertificatesScalarWhereInput[]
  }

  export type CourseContentUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<CourseContentCreateWithoutCoursesInput, CourseContentUncheckedCreateWithoutCoursesInput> | CourseContentCreateWithoutCoursesInput[] | CourseContentUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCoursesInput | CourseContentCreateOrConnectWithoutCoursesInput[]
    upsert?: CourseContentUpsertWithWhereUniqueWithoutCoursesInput | CourseContentUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: CourseContentCreateManyCoursesInputEnvelope
    set?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    disconnect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    delete?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    update?: CourseContentUpdateWithWhereUniqueWithoutCoursesInput | CourseContentUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: CourseContentUpdateManyWithWhereWithoutCoursesInput | CourseContentUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
  }

  export type CourseTagsUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<CourseTagsCreateWithoutCoursesInput, CourseTagsUncheckedCreateWithoutCoursesInput> | CourseTagsCreateWithoutCoursesInput[] | CourseTagsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CourseTagsCreateOrConnectWithoutCoursesInput | CourseTagsCreateOrConnectWithoutCoursesInput[]
    upsert?: CourseTagsUpsertWithWhereUniqueWithoutCoursesInput | CourseTagsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: CourseTagsCreateManyCoursesInputEnvelope
    set?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    disconnect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    delete?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    connect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    update?: CourseTagsUpdateWithWhereUniqueWithoutCoursesInput | CourseTagsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: CourseTagsUpdateManyWithWhereWithoutCoursesInput | CourseTagsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: CourseTagsScalarWhereInput | CourseTagsScalarWhereInput[]
  }

  export type CategoriesUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<CategoriesCreateWithoutCoursesInput, CategoriesUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutCoursesInput
    upsert?: CategoriesUpsertWithoutCoursesInput
    connect?: CategoriesWhereUniqueInput
    update?: XOR<XOR<CategoriesUpdateToOneWithWhereWithoutCoursesInput, CategoriesUpdateWithoutCoursesInput>, CategoriesUncheckedUpdateWithoutCoursesInput>
  }

  export type UsersUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<UsersCreateWithoutCoursesInput, UsersUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCoursesInput
    upsert?: UsersUpsertWithoutCoursesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCoursesInput, UsersUpdateWithoutCoursesInput>, UsersUncheckedUpdateWithoutCoursesInput>
  }

  export type EnrollmentsUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<EnrollmentsCreateWithoutCoursesInput, EnrollmentsUncheckedCreateWithoutCoursesInput> | EnrollmentsCreateWithoutCoursesInput[] | EnrollmentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: EnrollmentsCreateOrConnectWithoutCoursesInput | EnrollmentsCreateOrConnectWithoutCoursesInput[]
    upsert?: EnrollmentsUpsertWithWhereUniqueWithoutCoursesInput | EnrollmentsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: EnrollmentsCreateManyCoursesInputEnvelope
    set?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    disconnect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    delete?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    connect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    update?: EnrollmentsUpdateWithWhereUniqueWithoutCoursesInput | EnrollmentsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: EnrollmentsUpdateManyWithWhereWithoutCoursesInput | EnrollmentsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: EnrollmentsScalarWhereInput | EnrollmentsScalarWhereInput[]
  }

  export type PaymentsUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<PaymentsCreateWithoutCoursesInput, PaymentsUncheckedCreateWithoutCoursesInput> | PaymentsCreateWithoutCoursesInput[] | PaymentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutCoursesInput | PaymentsCreateOrConnectWithoutCoursesInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutCoursesInput | PaymentsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: PaymentsCreateManyCoursesInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutCoursesInput | PaymentsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutCoursesInput | PaymentsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type ReviewsUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<ReviewsCreateWithoutCoursesInput, ReviewsUncheckedCreateWithoutCoursesInput> | ReviewsCreateWithoutCoursesInput[] | ReviewsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutCoursesInput | ReviewsCreateOrConnectWithoutCoursesInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutCoursesInput | ReviewsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: ReviewsCreateManyCoursesInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutCoursesInput | ReviewsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutCoursesInput | ReviewsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type ShoppingCartUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<ShoppingCartCreateWithoutCoursesInput, ShoppingCartUncheckedCreateWithoutCoursesInput> | ShoppingCartCreateWithoutCoursesInput[] | ShoppingCartUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutCoursesInput | ShoppingCartCreateOrConnectWithoutCoursesInput[]
    upsert?: ShoppingCartUpsertWithWhereUniqueWithoutCoursesInput | ShoppingCartUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: ShoppingCartCreateManyCoursesInputEnvelope
    set?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    disconnect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    delete?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    connect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    update?: ShoppingCartUpdateWithWhereUniqueWithoutCoursesInput | ShoppingCartUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: ShoppingCartUpdateManyWithWhereWithoutCoursesInput | ShoppingCartUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: ShoppingCartScalarWhereInput | ShoppingCartScalarWhereInput[]
  }

  export type UserSavedCoursesUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<UserSavedCoursesCreateWithoutCoursesInput, UserSavedCoursesUncheckedCreateWithoutCoursesInput> | UserSavedCoursesCreateWithoutCoursesInput[] | UserSavedCoursesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: UserSavedCoursesCreateOrConnectWithoutCoursesInput | UserSavedCoursesCreateOrConnectWithoutCoursesInput[]
    upsert?: UserSavedCoursesUpsertWithWhereUniqueWithoutCoursesInput | UserSavedCoursesUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: UserSavedCoursesCreateManyCoursesInputEnvelope
    set?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    disconnect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    delete?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    connect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    update?: UserSavedCoursesUpdateWithWhereUniqueWithoutCoursesInput | UserSavedCoursesUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: UserSavedCoursesUpdateManyWithWhereWithoutCoursesInput | UserSavedCoursesUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: UserSavedCoursesScalarWhereInput | UserSavedCoursesScalarWhereInput[]
  }

  export type CertificatesUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<CertificatesCreateWithoutCoursesInput, CertificatesUncheckedCreateWithoutCoursesInput> | CertificatesCreateWithoutCoursesInput[] | CertificatesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CertificatesCreateOrConnectWithoutCoursesInput | CertificatesCreateOrConnectWithoutCoursesInput[]
    upsert?: CertificatesUpsertWithWhereUniqueWithoutCoursesInput | CertificatesUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: CertificatesCreateManyCoursesInputEnvelope
    set?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    disconnect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    delete?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    connect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    update?: CertificatesUpdateWithWhereUniqueWithoutCoursesInput | CertificatesUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: CertificatesUpdateManyWithWhereWithoutCoursesInput | CertificatesUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: CertificatesScalarWhereInput | CertificatesScalarWhereInput[]
  }

  export type CourseContentUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<CourseContentCreateWithoutCoursesInput, CourseContentUncheckedCreateWithoutCoursesInput> | CourseContentCreateWithoutCoursesInput[] | CourseContentUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCoursesInput | CourseContentCreateOrConnectWithoutCoursesInput[]
    upsert?: CourseContentUpsertWithWhereUniqueWithoutCoursesInput | CourseContentUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: CourseContentCreateManyCoursesInputEnvelope
    set?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    disconnect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    delete?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    update?: CourseContentUpdateWithWhereUniqueWithoutCoursesInput | CourseContentUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: CourseContentUpdateManyWithWhereWithoutCoursesInput | CourseContentUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
  }

  export type CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<CourseTagsCreateWithoutCoursesInput, CourseTagsUncheckedCreateWithoutCoursesInput> | CourseTagsCreateWithoutCoursesInput[] | CourseTagsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: CourseTagsCreateOrConnectWithoutCoursesInput | CourseTagsCreateOrConnectWithoutCoursesInput[]
    upsert?: CourseTagsUpsertWithWhereUniqueWithoutCoursesInput | CourseTagsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: CourseTagsCreateManyCoursesInputEnvelope
    set?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    disconnect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    delete?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    connect?: CourseTagsWhereUniqueInput | CourseTagsWhereUniqueInput[]
    update?: CourseTagsUpdateWithWhereUniqueWithoutCoursesInput | CourseTagsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: CourseTagsUpdateManyWithWhereWithoutCoursesInput | CourseTagsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: CourseTagsScalarWhereInput | CourseTagsScalarWhereInput[]
  }

  export type EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<EnrollmentsCreateWithoutCoursesInput, EnrollmentsUncheckedCreateWithoutCoursesInput> | EnrollmentsCreateWithoutCoursesInput[] | EnrollmentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: EnrollmentsCreateOrConnectWithoutCoursesInput | EnrollmentsCreateOrConnectWithoutCoursesInput[]
    upsert?: EnrollmentsUpsertWithWhereUniqueWithoutCoursesInput | EnrollmentsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: EnrollmentsCreateManyCoursesInputEnvelope
    set?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    disconnect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    delete?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    connect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    update?: EnrollmentsUpdateWithWhereUniqueWithoutCoursesInput | EnrollmentsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: EnrollmentsUpdateManyWithWhereWithoutCoursesInput | EnrollmentsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: EnrollmentsScalarWhereInput | EnrollmentsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<PaymentsCreateWithoutCoursesInput, PaymentsUncheckedCreateWithoutCoursesInput> | PaymentsCreateWithoutCoursesInput[] | PaymentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutCoursesInput | PaymentsCreateOrConnectWithoutCoursesInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutCoursesInput | PaymentsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: PaymentsCreateManyCoursesInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutCoursesInput | PaymentsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutCoursesInput | PaymentsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type ReviewsUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<ReviewsCreateWithoutCoursesInput, ReviewsUncheckedCreateWithoutCoursesInput> | ReviewsCreateWithoutCoursesInput[] | ReviewsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutCoursesInput | ReviewsCreateOrConnectWithoutCoursesInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutCoursesInput | ReviewsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: ReviewsCreateManyCoursesInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutCoursesInput | ReviewsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutCoursesInput | ReviewsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<ShoppingCartCreateWithoutCoursesInput, ShoppingCartUncheckedCreateWithoutCoursesInput> | ShoppingCartCreateWithoutCoursesInput[] | ShoppingCartUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutCoursesInput | ShoppingCartCreateOrConnectWithoutCoursesInput[]
    upsert?: ShoppingCartUpsertWithWhereUniqueWithoutCoursesInput | ShoppingCartUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: ShoppingCartCreateManyCoursesInputEnvelope
    set?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    disconnect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    delete?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    connect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    update?: ShoppingCartUpdateWithWhereUniqueWithoutCoursesInput | ShoppingCartUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: ShoppingCartUpdateManyWithWhereWithoutCoursesInput | ShoppingCartUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: ShoppingCartScalarWhereInput | ShoppingCartScalarWhereInput[]
  }

  export type UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<UserSavedCoursesCreateWithoutCoursesInput, UserSavedCoursesUncheckedCreateWithoutCoursesInput> | UserSavedCoursesCreateWithoutCoursesInput[] | UserSavedCoursesUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: UserSavedCoursesCreateOrConnectWithoutCoursesInput | UserSavedCoursesCreateOrConnectWithoutCoursesInput[]
    upsert?: UserSavedCoursesUpsertWithWhereUniqueWithoutCoursesInput | UserSavedCoursesUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: UserSavedCoursesCreateManyCoursesInputEnvelope
    set?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    disconnect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    delete?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    connect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    update?: UserSavedCoursesUpdateWithWhereUniqueWithoutCoursesInput | UserSavedCoursesUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: UserSavedCoursesUpdateManyWithWhereWithoutCoursesInput | UserSavedCoursesUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: UserSavedCoursesScalarWhereInput | UserSavedCoursesScalarWhereInput[]
  }

  export type CoursesCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CoursesCreateWithoutEnrollmentsInput, CoursesUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutEnrollmentsInput
    connect?: CoursesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<UsersCreateWithoutEnrollmentsInput, UsersUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutEnrollmentsInput
    connect?: UsersWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CoursesCreateWithoutEnrollmentsInput, CoursesUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutEnrollmentsInput
    upsert?: CoursesUpsertWithoutEnrollmentsInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutEnrollmentsInput, CoursesUpdateWithoutEnrollmentsInput>, CoursesUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UsersUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<UsersCreateWithoutEnrollmentsInput, UsersUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutEnrollmentsInput
    upsert?: UsersUpsertWithoutEnrollmentsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutEnrollmentsInput, UsersUpdateWithoutEnrollmentsInput>, UsersUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseContentCreateNestedOneWithoutLessonProgressInput = {
    create?: XOR<CourseContentCreateWithoutLessonProgressInput, CourseContentUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutLessonProgressInput
    connect?: CourseContentWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutLessonProgressInput = {
    create?: XOR<UsersCreateWithoutLessonProgressInput, UsersUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLessonProgressInput
    connect?: UsersWhereUniqueInput
  }

  export type CourseContentUpdateOneRequiredWithoutLessonProgressNestedInput = {
    create?: XOR<CourseContentCreateWithoutLessonProgressInput, CourseContentUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutLessonProgressInput
    upsert?: CourseContentUpsertWithoutLessonProgressInput
    connect?: CourseContentWhereUniqueInput
    update?: XOR<XOR<CourseContentUpdateToOneWithWhereWithoutLessonProgressInput, CourseContentUpdateWithoutLessonProgressInput>, CourseContentUncheckedUpdateWithoutLessonProgressInput>
  }

  export type UsersUpdateOneRequiredWithoutLessonProgressNestedInput = {
    create?: XOR<UsersCreateWithoutLessonProgressInput, UsersUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLessonProgressInput
    upsert?: UsersUpsertWithoutLessonProgressInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutLessonProgressInput, UsersUpdateWithoutLessonProgressInput>, UsersUncheckedUpdateWithoutLessonProgressInput>
  }

  export type UsersCreateNestedOneWithoutMessages_Messages_receiver_idToUsersInput = {
    create?: XOR<UsersCreateWithoutMessages_Messages_receiver_idToUsersInput, UsersUncheckedCreateWithoutMessages_Messages_receiver_idToUsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessages_Messages_receiver_idToUsersInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutMessages_Messages_sender_idToUsersInput = {
    create?: XOR<UsersCreateWithoutMessages_Messages_sender_idToUsersInput, UsersUncheckedCreateWithoutMessages_Messages_sender_idToUsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessages_Messages_sender_idToUsersInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutMessages_Messages_receiver_idToUsersNestedInput = {
    create?: XOR<UsersCreateWithoutMessages_Messages_receiver_idToUsersInput, UsersUncheckedCreateWithoutMessages_Messages_receiver_idToUsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessages_Messages_receiver_idToUsersInput
    upsert?: UsersUpsertWithoutMessages_Messages_receiver_idToUsersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMessages_Messages_receiver_idToUsersInput, UsersUpdateWithoutMessages_Messages_receiver_idToUsersInput>, UsersUncheckedUpdateWithoutMessages_Messages_receiver_idToUsersInput>
  }

  export type UsersUpdateOneRequiredWithoutMessages_Messages_sender_idToUsersNestedInput = {
    create?: XOR<UsersCreateWithoutMessages_Messages_sender_idToUsersInput, UsersUncheckedCreateWithoutMessages_Messages_sender_idToUsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessages_Messages_sender_idToUsersInput
    upsert?: UsersUpsertWithoutMessages_Messages_sender_idToUsersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMessages_Messages_sender_idToUsersInput, UsersUpdateWithoutMessages_Messages_sender_idToUsersInput>, UsersUncheckedUpdateWithoutMessages_Messages_sender_idToUsersInput>
  }

  export type UsersCreateNestedOneWithoutMultiFactorAuthInput = {
    create?: XOR<UsersCreateWithoutMultiFactorAuthInput, UsersUncheckedCreateWithoutMultiFactorAuthInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMultiFactorAuthInput
    connect?: UsersWhereUniqueInput
  }

  export type EnumMultiFactorAuth_mfa_typeFieldUpdateOperationsInput = {
    set?: $Enums.MultiFactorAuth_mfa_type
  }

  export type UsersUpdateOneRequiredWithoutMultiFactorAuthNestedInput = {
    create?: XOR<UsersCreateWithoutMultiFactorAuthInput, UsersUncheckedCreateWithoutMultiFactorAuthInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMultiFactorAuthInput
    upsert?: UsersUpsertWithoutMultiFactorAuthInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMultiFactorAuthInput, UsersUpdateWithoutMultiFactorAuthInput>, UsersUncheckedUpdateWithoutMultiFactorAuthInput>
  }

  export type UsersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationsInput
    connect?: UsersWhereUniqueInput
  }

  export type NullableEnumNotifications_typeFieldUpdateOperationsInput = {
    set?: $Enums.Notifications_type | null
  }

  export type UsersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationsInput
    upsert?: UsersUpsertWithoutNotificationsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutNotificationsInput, UsersUpdateWithoutNotificationsInput>, UsersUncheckedUpdateWithoutNotificationsInput>
  }

  export type CoursesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CoursesCreateWithoutPaymentsInput, CoursesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutPaymentsInput
    connect?: CoursesWhereUniqueInput
  }

  export type SubscriptionPlansCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionPlansCreateWithoutPaymentsInput, SubscriptionPlansUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionPlansCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionPlansWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UsersCreateWithoutPaymentsInput, UsersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPaymentsInput
    connect?: UsersWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumPayments_methodFieldUpdateOperationsInput = {
    set?: $Enums.Payments_method
  }

  export type EnumPayments_statusFieldUpdateOperationsInput = {
    set?: $Enums.Payments_status
  }

  export type CoursesUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<CoursesCreateWithoutPaymentsInput, CoursesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutPaymentsInput
    upsert?: CoursesUpsertWithoutPaymentsInput
    disconnect?: CoursesWhereInput | boolean
    delete?: CoursesWhereInput | boolean
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutPaymentsInput, CoursesUpdateWithoutPaymentsInput>, CoursesUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionPlansUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionPlansCreateWithoutPaymentsInput, SubscriptionPlansUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionPlansCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionPlansUpsertWithoutPaymentsInput
    disconnect?: SubscriptionPlansWhereInput | boolean
    delete?: SubscriptionPlansWhereInput | boolean
    connect?: SubscriptionPlansWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlansUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionPlansUpdateWithoutPaymentsInput>, SubscriptionPlansUncheckedUpdateWithoutPaymentsInput>
  }

  export type UsersUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UsersCreateWithoutPaymentsInput, UsersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPaymentsInput
    upsert?: UsersUpsertWithoutPaymentsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPaymentsInput, UsersUpdateWithoutPaymentsInput>, UsersUncheckedUpdateWithoutPaymentsInput>
  }

  export type AssessmentsCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<AssessmentsCreateWithoutQuizAttemptsInput, AssessmentsUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: AssessmentsCreateOrConnectWithoutQuizAttemptsInput
    connect?: AssessmentsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<UsersCreateWithoutQuizAttemptsInput, UsersUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutQuizAttemptsInput
    connect?: UsersWhereUniqueInput
  }

  export type UserAnswersCreateNestedManyWithoutQuizAttemptsInput = {
    create?: XOR<UserAnswersCreateWithoutQuizAttemptsInput, UserAnswersUncheckedCreateWithoutQuizAttemptsInput> | UserAnswersCreateWithoutQuizAttemptsInput[] | UserAnswersUncheckedCreateWithoutQuizAttemptsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutQuizAttemptsInput | UserAnswersCreateOrConnectWithoutQuizAttemptsInput[]
    createMany?: UserAnswersCreateManyQuizAttemptsInputEnvelope
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
  }

  export type UserAnswersUncheckedCreateNestedManyWithoutQuizAttemptsInput = {
    create?: XOR<UserAnswersCreateWithoutQuizAttemptsInput, UserAnswersUncheckedCreateWithoutQuizAttemptsInput> | UserAnswersCreateWithoutQuizAttemptsInput[] | UserAnswersUncheckedCreateWithoutQuizAttemptsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutQuizAttemptsInput | UserAnswersCreateOrConnectWithoutQuizAttemptsInput[]
    createMany?: UserAnswersCreateManyQuizAttemptsInputEnvelope
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
  }

  export type AssessmentsUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<AssessmentsCreateWithoutQuizAttemptsInput, AssessmentsUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: AssessmentsCreateOrConnectWithoutQuizAttemptsInput
    upsert?: AssessmentsUpsertWithoutQuizAttemptsInput
    connect?: AssessmentsWhereUniqueInput
    update?: XOR<XOR<AssessmentsUpdateToOneWithWhereWithoutQuizAttemptsInput, AssessmentsUpdateWithoutQuizAttemptsInput>, AssessmentsUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UsersUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<UsersCreateWithoutQuizAttemptsInput, UsersUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutQuizAttemptsInput
    upsert?: UsersUpsertWithoutQuizAttemptsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutQuizAttemptsInput, UsersUpdateWithoutQuizAttemptsInput>, UsersUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UserAnswersUpdateManyWithoutQuizAttemptsNestedInput = {
    create?: XOR<UserAnswersCreateWithoutQuizAttemptsInput, UserAnswersUncheckedCreateWithoutQuizAttemptsInput> | UserAnswersCreateWithoutQuizAttemptsInput[] | UserAnswersUncheckedCreateWithoutQuizAttemptsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutQuizAttemptsInput | UserAnswersCreateOrConnectWithoutQuizAttemptsInput[]
    upsert?: UserAnswersUpsertWithWhereUniqueWithoutQuizAttemptsInput | UserAnswersUpsertWithWhereUniqueWithoutQuizAttemptsInput[]
    createMany?: UserAnswersCreateManyQuizAttemptsInputEnvelope
    set?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    disconnect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    delete?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    update?: UserAnswersUpdateWithWhereUniqueWithoutQuizAttemptsInput | UserAnswersUpdateWithWhereUniqueWithoutQuizAttemptsInput[]
    updateMany?: UserAnswersUpdateManyWithWhereWithoutQuizAttemptsInput | UserAnswersUpdateManyWithWhereWithoutQuizAttemptsInput[]
    deleteMany?: UserAnswersScalarWhereInput | UserAnswersScalarWhereInput[]
  }

  export type UserAnswersUncheckedUpdateManyWithoutQuizAttemptsNestedInput = {
    create?: XOR<UserAnswersCreateWithoutQuizAttemptsInput, UserAnswersUncheckedCreateWithoutQuizAttemptsInput> | UserAnswersCreateWithoutQuizAttemptsInput[] | UserAnswersUncheckedCreateWithoutQuizAttemptsInput[]
    connectOrCreate?: UserAnswersCreateOrConnectWithoutQuizAttemptsInput | UserAnswersCreateOrConnectWithoutQuizAttemptsInput[]
    upsert?: UserAnswersUpsertWithWhereUniqueWithoutQuizAttemptsInput | UserAnswersUpsertWithWhereUniqueWithoutQuizAttemptsInput[]
    createMany?: UserAnswersCreateManyQuizAttemptsInputEnvelope
    set?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    disconnect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    delete?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    connect?: UserAnswersWhereUniqueInput | UserAnswersWhereUniqueInput[]
    update?: UserAnswersUpdateWithWhereUniqueWithoutQuizAttemptsInput | UserAnswersUpdateWithWhereUniqueWithoutQuizAttemptsInput[]
    updateMany?: UserAnswersUpdateManyWithWhereWithoutQuizAttemptsInput | UserAnswersUpdateManyWithWhereWithoutQuizAttemptsInput[]
    deleteMany?: UserAnswersScalarWhereInput | UserAnswersScalarWhereInput[]
  }

  export type CoursesCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CoursesCreateWithoutReviewsInput, CoursesUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutReviewsInput
    connect?: CoursesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutReviews_Reviews_instructor_idToUsersInput = {
    create?: XOR<UsersCreateWithoutReviews_Reviews_instructor_idToUsersInput, UsersUncheckedCreateWithoutReviews_Reviews_instructor_idToUsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReviews_Reviews_instructor_idToUsersInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutReviews_Reviews_user_idToUsersInput = {
    create?: XOR<UsersCreateWithoutReviews_Reviews_user_idToUsersInput, UsersUncheckedCreateWithoutReviews_Reviews_user_idToUsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReviews_Reviews_user_idToUsersInput
    connect?: UsersWhereUniqueInput
  }

  export type CoursesUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<CoursesCreateWithoutReviewsInput, CoursesUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutReviewsInput
    upsert?: CoursesUpsertWithoutReviewsInput
    disconnect?: CoursesWhereInput | boolean
    delete?: CoursesWhereInput | boolean
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutReviewsInput, CoursesUpdateWithoutReviewsInput>, CoursesUncheckedUpdateWithoutReviewsInput>
  }

  export type UsersUpdateOneWithoutReviews_Reviews_instructor_idToUsersNestedInput = {
    create?: XOR<UsersCreateWithoutReviews_Reviews_instructor_idToUsersInput, UsersUncheckedCreateWithoutReviews_Reviews_instructor_idToUsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReviews_Reviews_instructor_idToUsersInput
    upsert?: UsersUpsertWithoutReviews_Reviews_instructor_idToUsersInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutReviews_Reviews_instructor_idToUsersInput, UsersUpdateWithoutReviews_Reviews_instructor_idToUsersInput>, UsersUncheckedUpdateWithoutReviews_Reviews_instructor_idToUsersInput>
  }

  export type UsersUpdateOneRequiredWithoutReviews_Reviews_user_idToUsersNestedInput = {
    create?: XOR<UsersCreateWithoutReviews_Reviews_user_idToUsersInput, UsersUncheckedCreateWithoutReviews_Reviews_user_idToUsersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReviews_Reviews_user_idToUsersInput
    upsert?: UsersUpsertWithoutReviews_Reviews_user_idToUsersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutReviews_Reviews_user_idToUsersInput, UsersUpdateWithoutReviews_Reviews_user_idToUsersInput>, UsersUncheckedUpdateWithoutReviews_Reviews_user_idToUsersInput>
  }

  export type CoursesCreateNestedOneWithoutShoppingCartInput = {
    create?: XOR<CoursesCreateWithoutShoppingCartInput, CoursesUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutShoppingCartInput
    connect?: CoursesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutShoppingCartInput = {
    create?: XOR<UsersCreateWithoutShoppingCartInput, UsersUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: UsersCreateOrConnectWithoutShoppingCartInput
    connect?: UsersWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutShoppingCartNestedInput = {
    create?: XOR<CoursesCreateWithoutShoppingCartInput, CoursesUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutShoppingCartInput
    upsert?: CoursesUpsertWithoutShoppingCartInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutShoppingCartInput, CoursesUpdateWithoutShoppingCartInput>, CoursesUncheckedUpdateWithoutShoppingCartInput>
  }

  export type UsersUpdateOneRequiredWithoutShoppingCartNestedInput = {
    create?: XOR<UsersCreateWithoutShoppingCartInput, UsersUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: UsersCreateOrConnectWithoutShoppingCartInput
    upsert?: UsersUpsertWithoutShoppingCartInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutShoppingCartInput, UsersUpdateWithoutShoppingCartInput>, UsersUncheckedUpdateWithoutShoppingCartInput>
  }

  export type PaymentsCreateNestedManyWithoutSubscriptionPlansInput = {
    create?: XOR<PaymentsCreateWithoutSubscriptionPlansInput, PaymentsUncheckedCreateWithoutSubscriptionPlansInput> | PaymentsCreateWithoutSubscriptionPlansInput[] | PaymentsUncheckedCreateWithoutSubscriptionPlansInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSubscriptionPlansInput | PaymentsCreateOrConnectWithoutSubscriptionPlansInput[]
    createMany?: PaymentsCreateManySubscriptionPlansInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type SubscriptionsCreateNestedManyWithoutSubscriptionPlansInput = {
    create?: XOR<SubscriptionsCreateWithoutSubscriptionPlansInput, SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput> | SubscriptionsCreateWithoutSubscriptionPlansInput[] | SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutSubscriptionPlansInput | SubscriptionsCreateOrConnectWithoutSubscriptionPlansInput[]
    createMany?: SubscriptionsCreateManySubscriptionPlansInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutSubscriptionPlansInput = {
    create?: XOR<PaymentsCreateWithoutSubscriptionPlansInput, PaymentsUncheckedCreateWithoutSubscriptionPlansInput> | PaymentsCreateWithoutSubscriptionPlansInput[] | PaymentsUncheckedCreateWithoutSubscriptionPlansInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSubscriptionPlansInput | PaymentsCreateOrConnectWithoutSubscriptionPlansInput[]
    createMany?: PaymentsCreateManySubscriptionPlansInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type SubscriptionsUncheckedCreateNestedManyWithoutSubscriptionPlansInput = {
    create?: XOR<SubscriptionsCreateWithoutSubscriptionPlansInput, SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput> | SubscriptionsCreateWithoutSubscriptionPlansInput[] | SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutSubscriptionPlansInput | SubscriptionsCreateOrConnectWithoutSubscriptionPlansInput[]
    createMany?: SubscriptionsCreateManySubscriptionPlansInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type PaymentsUpdateManyWithoutSubscriptionPlansNestedInput = {
    create?: XOR<PaymentsCreateWithoutSubscriptionPlansInput, PaymentsUncheckedCreateWithoutSubscriptionPlansInput> | PaymentsCreateWithoutSubscriptionPlansInput[] | PaymentsUncheckedCreateWithoutSubscriptionPlansInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSubscriptionPlansInput | PaymentsCreateOrConnectWithoutSubscriptionPlansInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutSubscriptionPlansInput | PaymentsUpsertWithWhereUniqueWithoutSubscriptionPlansInput[]
    createMany?: PaymentsCreateManySubscriptionPlansInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutSubscriptionPlansInput | PaymentsUpdateWithWhereUniqueWithoutSubscriptionPlansInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutSubscriptionPlansInput | PaymentsUpdateManyWithWhereWithoutSubscriptionPlansInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type SubscriptionsUpdateManyWithoutSubscriptionPlansNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutSubscriptionPlansInput, SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput> | SubscriptionsCreateWithoutSubscriptionPlansInput[] | SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutSubscriptionPlansInput | SubscriptionsCreateOrConnectWithoutSubscriptionPlansInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutSubscriptionPlansInput | SubscriptionsUpsertWithWhereUniqueWithoutSubscriptionPlansInput[]
    createMany?: SubscriptionsCreateManySubscriptionPlansInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutSubscriptionPlansInput | SubscriptionsUpdateWithWhereUniqueWithoutSubscriptionPlansInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutSubscriptionPlansInput | SubscriptionsUpdateManyWithWhereWithoutSubscriptionPlansInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutSubscriptionPlansNestedInput = {
    create?: XOR<PaymentsCreateWithoutSubscriptionPlansInput, PaymentsUncheckedCreateWithoutSubscriptionPlansInput> | PaymentsCreateWithoutSubscriptionPlansInput[] | PaymentsUncheckedCreateWithoutSubscriptionPlansInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutSubscriptionPlansInput | PaymentsCreateOrConnectWithoutSubscriptionPlansInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutSubscriptionPlansInput | PaymentsUpsertWithWhereUniqueWithoutSubscriptionPlansInput[]
    createMany?: PaymentsCreateManySubscriptionPlansInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutSubscriptionPlansInput | PaymentsUpdateWithWhereUniqueWithoutSubscriptionPlansInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutSubscriptionPlansInput | PaymentsUpdateManyWithWhereWithoutSubscriptionPlansInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type SubscriptionsUncheckedUpdateManyWithoutSubscriptionPlansNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutSubscriptionPlansInput, SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput> | SubscriptionsCreateWithoutSubscriptionPlansInput[] | SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutSubscriptionPlansInput | SubscriptionsCreateOrConnectWithoutSubscriptionPlansInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutSubscriptionPlansInput | SubscriptionsUpsertWithWhereUniqueWithoutSubscriptionPlansInput[]
    createMany?: SubscriptionsCreateManySubscriptionPlansInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutSubscriptionPlansInput | SubscriptionsUpdateWithWhereUniqueWithoutSubscriptionPlansInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutSubscriptionPlansInput | SubscriptionsUpdateManyWithWhereWithoutSubscriptionPlansInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type SubscriptionPlansCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlansCreateWithoutSubscriptionsInput, SubscriptionPlansUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlansCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlansWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UsersCreateWithoutSubscriptionsInput, UsersUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSubscriptionsInput
    connect?: UsersWhereUniqueInput
  }

  export type EnumSubscriptions_statusFieldUpdateOperationsInput = {
    set?: $Enums.Subscriptions_status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SubscriptionPlansUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlansCreateWithoutSubscriptionsInput, SubscriptionPlansUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlansCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlansUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlansWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlansUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlansUpdateWithoutSubscriptionsInput>, SubscriptionPlansUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UsersUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UsersCreateWithoutSubscriptionsInput, UsersUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSubscriptionsInput
    upsert?: UsersUpsertWithoutSubscriptionsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutSubscriptionsInput, UsersUpdateWithoutSubscriptionsInput>, UsersUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type QuizAttemptsCreateNestedOneWithoutUserAnswersInput = {
    create?: XOR<QuizAttemptsCreateWithoutUserAnswersInput, QuizAttemptsUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutUserAnswersInput
    connect?: QuizAttemptsWhereUniqueInput
  }

  export type AssessmentOptionsCreateNestedOneWithoutUserAnswersInput = {
    create?: XOR<AssessmentOptionsCreateWithoutUserAnswersInput, AssessmentOptionsUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: AssessmentOptionsCreateOrConnectWithoutUserAnswersInput
    connect?: AssessmentOptionsWhereUniqueInput
  }

  export type AssessmentQuestionsCreateNestedOneWithoutUserAnswersInput = {
    create?: XOR<AssessmentQuestionsCreateWithoutUserAnswersInput, AssessmentQuestionsUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: AssessmentQuestionsCreateOrConnectWithoutUserAnswersInput
    connect?: AssessmentQuestionsWhereUniqueInput
  }

  export type QuizAttemptsUpdateOneRequiredWithoutUserAnswersNestedInput = {
    create?: XOR<QuizAttemptsCreateWithoutUserAnswersInput, QuizAttemptsUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutUserAnswersInput
    upsert?: QuizAttemptsUpsertWithoutUserAnswersInput
    connect?: QuizAttemptsWhereUniqueInput
    update?: XOR<XOR<QuizAttemptsUpdateToOneWithWhereWithoutUserAnswersInput, QuizAttemptsUpdateWithoutUserAnswersInput>, QuizAttemptsUncheckedUpdateWithoutUserAnswersInput>
  }

  export type AssessmentOptionsUpdateOneWithoutUserAnswersNestedInput = {
    create?: XOR<AssessmentOptionsCreateWithoutUserAnswersInput, AssessmentOptionsUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: AssessmentOptionsCreateOrConnectWithoutUserAnswersInput
    upsert?: AssessmentOptionsUpsertWithoutUserAnswersInput
    disconnect?: AssessmentOptionsWhereInput | boolean
    delete?: AssessmentOptionsWhereInput | boolean
    connect?: AssessmentOptionsWhereUniqueInput
    update?: XOR<XOR<AssessmentOptionsUpdateToOneWithWhereWithoutUserAnswersInput, AssessmentOptionsUpdateWithoutUserAnswersInput>, AssessmentOptionsUncheckedUpdateWithoutUserAnswersInput>
  }

  export type AssessmentQuestionsUpdateOneRequiredWithoutUserAnswersNestedInput = {
    create?: XOR<AssessmentQuestionsCreateWithoutUserAnswersInput, AssessmentQuestionsUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: AssessmentQuestionsCreateOrConnectWithoutUserAnswersInput
    upsert?: AssessmentQuestionsUpsertWithoutUserAnswersInput
    connect?: AssessmentQuestionsWhereUniqueInput
    update?: XOR<XOR<AssessmentQuestionsUpdateToOneWithWhereWithoutUserAnswersInput, AssessmentQuestionsUpdateWithoutUserAnswersInput>, AssessmentQuestionsUncheckedUpdateWithoutUserAnswersInput>
  }

  export type CoursesCreateNestedOneWithoutUserSavedCoursesInput = {
    create?: XOR<CoursesCreateWithoutUserSavedCoursesInput, CoursesUncheckedCreateWithoutUserSavedCoursesInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutUserSavedCoursesInput
    connect?: CoursesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUserSavedCoursesInput = {
    create?: XOR<UsersCreateWithoutUserSavedCoursesInput, UsersUncheckedCreateWithoutUserSavedCoursesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserSavedCoursesInput
    connect?: UsersWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutUserSavedCoursesNestedInput = {
    create?: XOR<CoursesCreateWithoutUserSavedCoursesInput, CoursesUncheckedCreateWithoutUserSavedCoursesInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutUserSavedCoursesInput
    upsert?: CoursesUpsertWithoutUserSavedCoursesInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutUserSavedCoursesInput, CoursesUpdateWithoutUserSavedCoursesInput>, CoursesUncheckedUpdateWithoutUserSavedCoursesInput>
  }

  export type UsersUpdateOneRequiredWithoutUserSavedCoursesNestedInput = {
    create?: XOR<UsersCreateWithoutUserSavedCoursesInput, UsersUncheckedCreateWithoutUserSavedCoursesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUserSavedCoursesInput
    upsert?: UsersUpsertWithoutUserSavedCoursesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUserSavedCoursesInput, UsersUpdateWithoutUserSavedCoursesInput>, UsersUncheckedUpdateWithoutUserSavedCoursesInput>
  }

  export type CertificatesCreateNestedManyWithoutUsersInput = {
    create?: XOR<CertificatesCreateWithoutUsersInput, CertificatesUncheckedCreateWithoutUsersInput> | CertificatesCreateWithoutUsersInput[] | CertificatesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CertificatesCreateOrConnectWithoutUsersInput | CertificatesCreateOrConnectWithoutUsersInput[]
    createMany?: CertificatesCreateManyUsersInputEnvelope
    connect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
  }

  export type CoursesCreateNestedManyWithoutUsersInput = {
    create?: XOR<CoursesCreateWithoutUsersInput, CoursesUncheckedCreateWithoutUsersInput> | CoursesCreateWithoutUsersInput[] | CoursesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutUsersInput | CoursesCreateOrConnectWithoutUsersInput[]
    createMany?: CoursesCreateManyUsersInputEnvelope
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
  }

  export type EnrollmentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<EnrollmentsCreateWithoutUsersInput, EnrollmentsUncheckedCreateWithoutUsersInput> | EnrollmentsCreateWithoutUsersInput[] | EnrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EnrollmentsCreateOrConnectWithoutUsersInput | EnrollmentsCreateOrConnectWithoutUsersInput[]
    createMany?: EnrollmentsCreateManyUsersInputEnvelope
    connect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
  }

  export type LessonProgressCreateNestedManyWithoutUsersInput = {
    create?: XOR<LessonProgressCreateWithoutUsersInput, LessonProgressUncheckedCreateWithoutUsersInput> | LessonProgressCreateWithoutUsersInput[] | LessonProgressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUsersInput | LessonProgressCreateOrConnectWithoutUsersInput[]
    createMany?: LessonProgressCreateManyUsersInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput = {
    create?: XOR<MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput> | MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput[] | MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutUsers_Messages_receiver_idToUsersInput | MessagesCreateOrConnectWithoutUsers_Messages_receiver_idToUsersInput[]
    createMany?: MessagesCreateManyUsers_Messages_receiver_idToUsersInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput = {
    create?: XOR<MessagesCreateWithoutUsers_Messages_sender_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput> | MessagesCreateWithoutUsers_Messages_sender_idToUsersInput[] | MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutUsers_Messages_sender_idToUsersInput | MessagesCreateOrConnectWithoutUsers_Messages_sender_idToUsersInput[]
    createMany?: MessagesCreateManyUsers_Messages_sender_idToUsersInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type MultiFactorAuthCreateNestedManyWithoutUsersInput = {
    create?: XOR<MultiFactorAuthCreateWithoutUsersInput, MultiFactorAuthUncheckedCreateWithoutUsersInput> | MultiFactorAuthCreateWithoutUsersInput[] | MultiFactorAuthUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MultiFactorAuthCreateOrConnectWithoutUsersInput | MultiFactorAuthCreateOrConnectWithoutUsersInput[]
    createMany?: MultiFactorAuthCreateManyUsersInputEnvelope
    connect?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type PaymentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<PaymentsCreateWithoutUsersInput, PaymentsUncheckedCreateWithoutUsersInput> | PaymentsCreateWithoutUsersInput[] | PaymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUsersInput | PaymentsCreateOrConnectWithoutUsersInput[]
    createMany?: PaymentsCreateManyUsersInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type QuizAttemptsCreateNestedManyWithoutUsersInput = {
    create?: XOR<QuizAttemptsCreateWithoutUsersInput, QuizAttemptsUncheckedCreateWithoutUsersInput> | QuizAttemptsCreateWithoutUsersInput[] | QuizAttemptsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutUsersInput | QuizAttemptsCreateOrConnectWithoutUsersInput[]
    createMany?: QuizAttemptsCreateManyUsersInputEnvelope
    connect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
  }

  export type ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput = {
    create?: XOR<ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput> | ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput[] | ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsCreateOrConnectWithoutUsers_Reviews_instructor_idToUsersInput[]
    createMany?: ReviewsCreateManyUsers_Reviews_instructor_idToUsersInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput = {
    create?: XOR<ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput> | ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput[] | ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsers_Reviews_user_idToUsersInput | ReviewsCreateOrConnectWithoutUsers_Reviews_user_idToUsersInput[]
    createMany?: ReviewsCreateManyUsers_Reviews_user_idToUsersInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type ShoppingCartCreateNestedManyWithoutUsersInput = {
    create?: XOR<ShoppingCartCreateWithoutUsersInput, ShoppingCartUncheckedCreateWithoutUsersInput> | ShoppingCartCreateWithoutUsersInput[] | ShoppingCartUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutUsersInput | ShoppingCartCreateOrConnectWithoutUsersInput[]
    createMany?: ShoppingCartCreateManyUsersInputEnvelope
    connect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
  }

  export type SubscriptionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<SubscriptionsCreateWithoutUsersInput, SubscriptionsUncheckedCreateWithoutUsersInput> | SubscriptionsCreateWithoutUsersInput[] | SubscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutUsersInput | SubscriptionsCreateOrConnectWithoutUsersInput[]
    createMany?: SubscriptionsCreateManyUsersInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type UserSavedCoursesCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserSavedCoursesCreateWithoutUsersInput, UserSavedCoursesUncheckedCreateWithoutUsersInput> | UserSavedCoursesCreateWithoutUsersInput[] | UserSavedCoursesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSavedCoursesCreateOrConnectWithoutUsersInput | UserSavedCoursesCreateOrConnectWithoutUsersInput[]
    createMany?: UserSavedCoursesCreateManyUsersInputEnvelope
    connect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
  }

  export type CertificatesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<CertificatesCreateWithoutUsersInput, CertificatesUncheckedCreateWithoutUsersInput> | CertificatesCreateWithoutUsersInput[] | CertificatesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CertificatesCreateOrConnectWithoutUsersInput | CertificatesCreateOrConnectWithoutUsersInput[]
    createMany?: CertificatesCreateManyUsersInputEnvelope
    connect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
  }

  export type CoursesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<CoursesCreateWithoutUsersInput, CoursesUncheckedCreateWithoutUsersInput> | CoursesCreateWithoutUsersInput[] | CoursesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutUsersInput | CoursesCreateOrConnectWithoutUsersInput[]
    createMany?: CoursesCreateManyUsersInputEnvelope
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
  }

  export type EnrollmentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<EnrollmentsCreateWithoutUsersInput, EnrollmentsUncheckedCreateWithoutUsersInput> | EnrollmentsCreateWithoutUsersInput[] | EnrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EnrollmentsCreateOrConnectWithoutUsersInput | EnrollmentsCreateOrConnectWithoutUsersInput[]
    createMany?: EnrollmentsCreateManyUsersInputEnvelope
    connect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
  }

  export type LessonProgressUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<LessonProgressCreateWithoutUsersInput, LessonProgressUncheckedCreateWithoutUsersInput> | LessonProgressCreateWithoutUsersInput[] | LessonProgressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUsersInput | LessonProgressCreateOrConnectWithoutUsersInput[]
    createMany?: LessonProgressCreateManyUsersInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput = {
    create?: XOR<MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput> | MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput[] | MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutUsers_Messages_receiver_idToUsersInput | MessagesCreateOrConnectWithoutUsers_Messages_receiver_idToUsersInput[]
    createMany?: MessagesCreateManyUsers_Messages_receiver_idToUsersInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput = {
    create?: XOR<MessagesCreateWithoutUsers_Messages_sender_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput> | MessagesCreateWithoutUsers_Messages_sender_idToUsersInput[] | MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutUsers_Messages_sender_idToUsersInput | MessagesCreateOrConnectWithoutUsers_Messages_sender_idToUsersInput[]
    createMany?: MessagesCreateManyUsers_Messages_sender_idToUsersInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<MultiFactorAuthCreateWithoutUsersInput, MultiFactorAuthUncheckedCreateWithoutUsersInput> | MultiFactorAuthCreateWithoutUsersInput[] | MultiFactorAuthUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MultiFactorAuthCreateOrConnectWithoutUsersInput | MultiFactorAuthCreateOrConnectWithoutUsersInput[]
    createMany?: MultiFactorAuthCreateManyUsersInputEnvelope
    connect?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PaymentsCreateWithoutUsersInput, PaymentsUncheckedCreateWithoutUsersInput> | PaymentsCreateWithoutUsersInput[] | PaymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUsersInput | PaymentsCreateOrConnectWithoutUsersInput[]
    createMany?: PaymentsCreateManyUsersInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<QuizAttemptsCreateWithoutUsersInput, QuizAttemptsUncheckedCreateWithoutUsersInput> | QuizAttemptsCreateWithoutUsersInput[] | QuizAttemptsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutUsersInput | QuizAttemptsCreateOrConnectWithoutUsersInput[]
    createMany?: QuizAttemptsCreateManyUsersInputEnvelope
    connect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
  }

  export type ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput = {
    create?: XOR<ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput> | ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput[] | ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsCreateOrConnectWithoutUsers_Reviews_instructor_idToUsersInput[]
    createMany?: ReviewsCreateManyUsers_Reviews_instructor_idToUsersInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput = {
    create?: XOR<ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput> | ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput[] | ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsers_Reviews_user_idToUsersInput | ReviewsCreateOrConnectWithoutUsers_Reviews_user_idToUsersInput[]
    createMany?: ReviewsCreateManyUsers_Reviews_user_idToUsersInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type ShoppingCartUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ShoppingCartCreateWithoutUsersInput, ShoppingCartUncheckedCreateWithoutUsersInput> | ShoppingCartCreateWithoutUsersInput[] | ShoppingCartUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutUsersInput | ShoppingCartCreateOrConnectWithoutUsersInput[]
    createMany?: ShoppingCartCreateManyUsersInputEnvelope
    connect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
  }

  export type SubscriptionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<SubscriptionsCreateWithoutUsersInput, SubscriptionsUncheckedCreateWithoutUsersInput> | SubscriptionsCreateWithoutUsersInput[] | SubscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutUsersInput | SubscriptionsCreateOrConnectWithoutUsersInput[]
    createMany?: SubscriptionsCreateManyUsersInputEnvelope
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
  }

  export type UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserSavedCoursesCreateWithoutUsersInput, UserSavedCoursesUncheckedCreateWithoutUsersInput> | UserSavedCoursesCreateWithoutUsersInput[] | UserSavedCoursesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSavedCoursesCreateOrConnectWithoutUsersInput | UserSavedCoursesCreateOrConnectWithoutUsersInput[]
    createMany?: UserSavedCoursesCreateManyUsersInputEnvelope
    connect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
  }

  export type EnumUsers_roleFieldUpdateOperationsInput = {
    set?: $Enums.Users_role
  }

  export type EnumUsers_instructor_application_statusFieldUpdateOperationsInput = {
    set?: $Enums.Users_instructor_application_status
  }

  export type CertificatesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CertificatesCreateWithoutUsersInput, CertificatesUncheckedCreateWithoutUsersInput> | CertificatesCreateWithoutUsersInput[] | CertificatesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CertificatesCreateOrConnectWithoutUsersInput | CertificatesCreateOrConnectWithoutUsersInput[]
    upsert?: CertificatesUpsertWithWhereUniqueWithoutUsersInput | CertificatesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CertificatesCreateManyUsersInputEnvelope
    set?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    disconnect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    delete?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    connect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    update?: CertificatesUpdateWithWhereUniqueWithoutUsersInput | CertificatesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CertificatesUpdateManyWithWhereWithoutUsersInput | CertificatesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CertificatesScalarWhereInput | CertificatesScalarWhereInput[]
  }

  export type CoursesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CoursesCreateWithoutUsersInput, CoursesUncheckedCreateWithoutUsersInput> | CoursesCreateWithoutUsersInput[] | CoursesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutUsersInput | CoursesCreateOrConnectWithoutUsersInput[]
    upsert?: CoursesUpsertWithWhereUniqueWithoutUsersInput | CoursesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CoursesCreateManyUsersInputEnvelope
    set?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    disconnect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    delete?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    update?: CoursesUpdateWithWhereUniqueWithoutUsersInput | CoursesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CoursesUpdateManyWithWhereWithoutUsersInput | CoursesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
  }

  export type EnrollmentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<EnrollmentsCreateWithoutUsersInput, EnrollmentsUncheckedCreateWithoutUsersInput> | EnrollmentsCreateWithoutUsersInput[] | EnrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EnrollmentsCreateOrConnectWithoutUsersInput | EnrollmentsCreateOrConnectWithoutUsersInput[]
    upsert?: EnrollmentsUpsertWithWhereUniqueWithoutUsersInput | EnrollmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: EnrollmentsCreateManyUsersInputEnvelope
    set?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    disconnect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    delete?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    connect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    update?: EnrollmentsUpdateWithWhereUniqueWithoutUsersInput | EnrollmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: EnrollmentsUpdateManyWithWhereWithoutUsersInput | EnrollmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: EnrollmentsScalarWhereInput | EnrollmentsScalarWhereInput[]
  }

  export type LessonProgressUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LessonProgressCreateWithoutUsersInput, LessonProgressUncheckedCreateWithoutUsersInput> | LessonProgressCreateWithoutUsersInput[] | LessonProgressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUsersInput | LessonProgressCreateOrConnectWithoutUsersInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutUsersInput | LessonProgressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: LessonProgressCreateManyUsersInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutUsersInput | LessonProgressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutUsersInput | LessonProgressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput = {
    create?: XOR<MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput> | MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput[] | MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutUsers_Messages_receiver_idToUsersInput | MessagesCreateOrConnectWithoutUsers_Messages_receiver_idToUsersInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput | MessagesUpsertWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput[]
    createMany?: MessagesCreateManyUsers_Messages_receiver_idToUsersInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput | MessagesUpdateWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutUsers_Messages_receiver_idToUsersInput | MessagesUpdateManyWithWhereWithoutUsers_Messages_receiver_idToUsersInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput = {
    create?: XOR<MessagesCreateWithoutUsers_Messages_sender_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput> | MessagesCreateWithoutUsers_Messages_sender_idToUsersInput[] | MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutUsers_Messages_sender_idToUsersInput | MessagesCreateOrConnectWithoutUsers_Messages_sender_idToUsersInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput | MessagesUpsertWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput[]
    createMany?: MessagesCreateManyUsers_Messages_sender_idToUsersInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput | MessagesUpdateWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutUsers_Messages_sender_idToUsersInput | MessagesUpdateManyWithWhereWithoutUsers_Messages_sender_idToUsersInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type MultiFactorAuthUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MultiFactorAuthCreateWithoutUsersInput, MultiFactorAuthUncheckedCreateWithoutUsersInput> | MultiFactorAuthCreateWithoutUsersInput[] | MultiFactorAuthUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MultiFactorAuthCreateOrConnectWithoutUsersInput | MultiFactorAuthCreateOrConnectWithoutUsersInput[]
    upsert?: MultiFactorAuthUpsertWithWhereUniqueWithoutUsersInput | MultiFactorAuthUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MultiFactorAuthCreateManyUsersInputEnvelope
    set?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
    disconnect?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
    delete?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
    connect?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
    update?: MultiFactorAuthUpdateWithWhereUniqueWithoutUsersInput | MultiFactorAuthUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MultiFactorAuthUpdateManyWithWhereWithoutUsersInput | MultiFactorAuthUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MultiFactorAuthScalarWhereInput | MultiFactorAuthScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUsersInput | NotificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUsersInput | NotificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUsersInput | NotificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type PaymentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PaymentsCreateWithoutUsersInput, PaymentsUncheckedCreateWithoutUsersInput> | PaymentsCreateWithoutUsersInput[] | PaymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUsersInput | PaymentsCreateOrConnectWithoutUsersInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutUsersInput | PaymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PaymentsCreateManyUsersInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutUsersInput | PaymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutUsersInput | PaymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type QuizAttemptsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<QuizAttemptsCreateWithoutUsersInput, QuizAttemptsUncheckedCreateWithoutUsersInput> | QuizAttemptsCreateWithoutUsersInput[] | QuizAttemptsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutUsersInput | QuizAttemptsCreateOrConnectWithoutUsersInput[]
    upsert?: QuizAttemptsUpsertWithWhereUniqueWithoutUsersInput | QuizAttemptsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: QuizAttemptsCreateManyUsersInputEnvelope
    set?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    disconnect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    delete?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    connect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    update?: QuizAttemptsUpdateWithWhereUniqueWithoutUsersInput | QuizAttemptsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: QuizAttemptsUpdateManyWithWhereWithoutUsersInput | QuizAttemptsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: QuizAttemptsScalarWhereInput | QuizAttemptsScalarWhereInput[]
  }

  export type ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput = {
    create?: XOR<ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput> | ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput[] | ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsCreateOrConnectWithoutUsers_Reviews_instructor_idToUsersInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput[]
    createMany?: ReviewsCreateManyUsers_Reviews_instructor_idToUsersInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsUpdateManyWithWhereWithoutUsers_Reviews_instructor_idToUsersInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput = {
    create?: XOR<ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput> | ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput[] | ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsers_Reviews_user_idToUsersInput | ReviewsCreateOrConnectWithoutUsers_Reviews_user_idToUsersInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput | ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput[]
    createMany?: ReviewsCreateManyUsers_Reviews_user_idToUsersInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput | ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutUsers_Reviews_user_idToUsersInput | ReviewsUpdateManyWithWhereWithoutUsers_Reviews_user_idToUsersInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type ShoppingCartUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ShoppingCartCreateWithoutUsersInput, ShoppingCartUncheckedCreateWithoutUsersInput> | ShoppingCartCreateWithoutUsersInput[] | ShoppingCartUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutUsersInput | ShoppingCartCreateOrConnectWithoutUsersInput[]
    upsert?: ShoppingCartUpsertWithWhereUniqueWithoutUsersInput | ShoppingCartUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ShoppingCartCreateManyUsersInputEnvelope
    set?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    disconnect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    delete?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    connect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    update?: ShoppingCartUpdateWithWhereUniqueWithoutUsersInput | ShoppingCartUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ShoppingCartUpdateManyWithWhereWithoutUsersInput | ShoppingCartUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ShoppingCartScalarWhereInput | ShoppingCartScalarWhereInput[]
  }

  export type SubscriptionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutUsersInput, SubscriptionsUncheckedCreateWithoutUsersInput> | SubscriptionsCreateWithoutUsersInput[] | SubscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutUsersInput | SubscriptionsCreateOrConnectWithoutUsersInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutUsersInput | SubscriptionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: SubscriptionsCreateManyUsersInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutUsersInput | SubscriptionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutUsersInput | SubscriptionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type UserSavedCoursesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserSavedCoursesCreateWithoutUsersInput, UserSavedCoursesUncheckedCreateWithoutUsersInput> | UserSavedCoursesCreateWithoutUsersInput[] | UserSavedCoursesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSavedCoursesCreateOrConnectWithoutUsersInput | UserSavedCoursesCreateOrConnectWithoutUsersInput[]
    upsert?: UserSavedCoursesUpsertWithWhereUniqueWithoutUsersInput | UserSavedCoursesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserSavedCoursesCreateManyUsersInputEnvelope
    set?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    disconnect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    delete?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    connect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    update?: UserSavedCoursesUpdateWithWhereUniqueWithoutUsersInput | UserSavedCoursesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserSavedCoursesUpdateManyWithWhereWithoutUsersInput | UserSavedCoursesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserSavedCoursesScalarWhereInput | UserSavedCoursesScalarWhereInput[]
  }

  export type CertificatesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CertificatesCreateWithoutUsersInput, CertificatesUncheckedCreateWithoutUsersInput> | CertificatesCreateWithoutUsersInput[] | CertificatesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CertificatesCreateOrConnectWithoutUsersInput | CertificatesCreateOrConnectWithoutUsersInput[]
    upsert?: CertificatesUpsertWithWhereUniqueWithoutUsersInput | CertificatesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CertificatesCreateManyUsersInputEnvelope
    set?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    disconnect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    delete?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    connect?: CertificatesWhereUniqueInput | CertificatesWhereUniqueInput[]
    update?: CertificatesUpdateWithWhereUniqueWithoutUsersInput | CertificatesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CertificatesUpdateManyWithWhereWithoutUsersInput | CertificatesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CertificatesScalarWhereInput | CertificatesScalarWhereInput[]
  }

  export type CoursesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CoursesCreateWithoutUsersInput, CoursesUncheckedCreateWithoutUsersInput> | CoursesCreateWithoutUsersInput[] | CoursesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutUsersInput | CoursesCreateOrConnectWithoutUsersInput[]
    upsert?: CoursesUpsertWithWhereUniqueWithoutUsersInput | CoursesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CoursesCreateManyUsersInputEnvelope
    set?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    disconnect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    delete?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    update?: CoursesUpdateWithWhereUniqueWithoutUsersInput | CoursesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CoursesUpdateManyWithWhereWithoutUsersInput | CoursesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
  }

  export type EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<EnrollmentsCreateWithoutUsersInput, EnrollmentsUncheckedCreateWithoutUsersInput> | EnrollmentsCreateWithoutUsersInput[] | EnrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EnrollmentsCreateOrConnectWithoutUsersInput | EnrollmentsCreateOrConnectWithoutUsersInput[]
    upsert?: EnrollmentsUpsertWithWhereUniqueWithoutUsersInput | EnrollmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: EnrollmentsCreateManyUsersInputEnvelope
    set?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    disconnect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    delete?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    connect?: EnrollmentsWhereUniqueInput | EnrollmentsWhereUniqueInput[]
    update?: EnrollmentsUpdateWithWhereUniqueWithoutUsersInput | EnrollmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: EnrollmentsUpdateManyWithWhereWithoutUsersInput | EnrollmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: EnrollmentsScalarWhereInput | EnrollmentsScalarWhereInput[]
  }

  export type LessonProgressUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LessonProgressCreateWithoutUsersInput, LessonProgressUncheckedCreateWithoutUsersInput> | LessonProgressCreateWithoutUsersInput[] | LessonProgressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUsersInput | LessonProgressCreateOrConnectWithoutUsersInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutUsersInput | LessonProgressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: LessonProgressCreateManyUsersInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutUsersInput | LessonProgressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutUsersInput | LessonProgressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput = {
    create?: XOR<MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput> | MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput[] | MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutUsers_Messages_receiver_idToUsersInput | MessagesCreateOrConnectWithoutUsers_Messages_receiver_idToUsersInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput | MessagesUpsertWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput[]
    createMany?: MessagesCreateManyUsers_Messages_receiver_idToUsersInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput | MessagesUpdateWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutUsers_Messages_receiver_idToUsersInput | MessagesUpdateManyWithWhereWithoutUsers_Messages_receiver_idToUsersInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput = {
    create?: XOR<MessagesCreateWithoutUsers_Messages_sender_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput> | MessagesCreateWithoutUsers_Messages_sender_idToUsersInput[] | MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutUsers_Messages_sender_idToUsersInput | MessagesCreateOrConnectWithoutUsers_Messages_sender_idToUsersInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput | MessagesUpsertWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput[]
    createMany?: MessagesCreateManyUsers_Messages_sender_idToUsersInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput | MessagesUpdateWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutUsers_Messages_sender_idToUsersInput | MessagesUpdateManyWithWhereWithoutUsers_Messages_sender_idToUsersInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MultiFactorAuthCreateWithoutUsersInput, MultiFactorAuthUncheckedCreateWithoutUsersInput> | MultiFactorAuthCreateWithoutUsersInput[] | MultiFactorAuthUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MultiFactorAuthCreateOrConnectWithoutUsersInput | MultiFactorAuthCreateOrConnectWithoutUsersInput[]
    upsert?: MultiFactorAuthUpsertWithWhereUniqueWithoutUsersInput | MultiFactorAuthUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MultiFactorAuthCreateManyUsersInputEnvelope
    set?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
    disconnect?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
    delete?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
    connect?: MultiFactorAuthWhereUniqueInput | MultiFactorAuthWhereUniqueInput[]
    update?: MultiFactorAuthUpdateWithWhereUniqueWithoutUsersInput | MultiFactorAuthUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MultiFactorAuthUpdateManyWithWhereWithoutUsersInput | MultiFactorAuthUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MultiFactorAuthScalarWhereInput | MultiFactorAuthScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUsersInput | NotificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUsersInput | NotificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUsersInput | NotificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PaymentsCreateWithoutUsersInput, PaymentsUncheckedCreateWithoutUsersInput> | PaymentsCreateWithoutUsersInput[] | PaymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUsersInput | PaymentsCreateOrConnectWithoutUsersInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutUsersInput | PaymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PaymentsCreateManyUsersInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutUsersInput | PaymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutUsersInput | PaymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<QuizAttemptsCreateWithoutUsersInput, QuizAttemptsUncheckedCreateWithoutUsersInput> | QuizAttemptsCreateWithoutUsersInput[] | QuizAttemptsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: QuizAttemptsCreateOrConnectWithoutUsersInput | QuizAttemptsCreateOrConnectWithoutUsersInput[]
    upsert?: QuizAttemptsUpsertWithWhereUniqueWithoutUsersInput | QuizAttemptsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: QuizAttemptsCreateManyUsersInputEnvelope
    set?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    disconnect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    delete?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    connect?: QuizAttemptsWhereUniqueInput | QuizAttemptsWhereUniqueInput[]
    update?: QuizAttemptsUpdateWithWhereUniqueWithoutUsersInput | QuizAttemptsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: QuizAttemptsUpdateManyWithWhereWithoutUsersInput | QuizAttemptsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: QuizAttemptsScalarWhereInput | QuizAttemptsScalarWhereInput[]
  }

  export type ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput = {
    create?: XOR<ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput> | ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput[] | ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsCreateOrConnectWithoutUsers_Reviews_instructor_idToUsersInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput[]
    createMany?: ReviewsCreateManyUsers_Reviews_instructor_idToUsersInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutUsers_Reviews_instructor_idToUsersInput | ReviewsUpdateManyWithWhereWithoutUsers_Reviews_instructor_idToUsersInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput = {
    create?: XOR<ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput> | ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput[] | ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsers_Reviews_user_idToUsersInput | ReviewsCreateOrConnectWithoutUsers_Reviews_user_idToUsersInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput | ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput[]
    createMany?: ReviewsCreateManyUsers_Reviews_user_idToUsersInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput | ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutUsers_Reviews_user_idToUsersInput | ReviewsUpdateManyWithWhereWithoutUsers_Reviews_user_idToUsersInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ShoppingCartCreateWithoutUsersInput, ShoppingCartUncheckedCreateWithoutUsersInput> | ShoppingCartCreateWithoutUsersInput[] | ShoppingCartUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutUsersInput | ShoppingCartCreateOrConnectWithoutUsersInput[]
    upsert?: ShoppingCartUpsertWithWhereUniqueWithoutUsersInput | ShoppingCartUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ShoppingCartCreateManyUsersInputEnvelope
    set?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    disconnect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    delete?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    connect?: ShoppingCartWhereUniqueInput | ShoppingCartWhereUniqueInput[]
    update?: ShoppingCartUpdateWithWhereUniqueWithoutUsersInput | ShoppingCartUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ShoppingCartUpdateManyWithWhereWithoutUsersInput | ShoppingCartUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ShoppingCartScalarWhereInput | ShoppingCartScalarWhereInput[]
  }

  export type SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutUsersInput, SubscriptionsUncheckedCreateWithoutUsersInput> | SubscriptionsCreateWithoutUsersInput[] | SubscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutUsersInput | SubscriptionsCreateOrConnectWithoutUsersInput[]
    upsert?: SubscriptionsUpsertWithWhereUniqueWithoutUsersInput | SubscriptionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: SubscriptionsCreateManyUsersInputEnvelope
    set?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    disconnect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    delete?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    connect?: SubscriptionsWhereUniqueInput | SubscriptionsWhereUniqueInput[]
    update?: SubscriptionsUpdateWithWhereUniqueWithoutUsersInput | SubscriptionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: SubscriptionsUpdateManyWithWhereWithoutUsersInput | SubscriptionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
  }

  export type UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserSavedCoursesCreateWithoutUsersInput, UserSavedCoursesUncheckedCreateWithoutUsersInput> | UserSavedCoursesCreateWithoutUsersInput[] | UserSavedCoursesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserSavedCoursesCreateOrConnectWithoutUsersInput | UserSavedCoursesCreateOrConnectWithoutUsersInput[]
    upsert?: UserSavedCoursesUpsertWithWhereUniqueWithoutUsersInput | UserSavedCoursesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserSavedCoursesCreateManyUsersInputEnvelope
    set?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    disconnect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    delete?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    connect?: UserSavedCoursesWhereUniqueInput | UserSavedCoursesWhereUniqueInput[]
    update?: UserSavedCoursesUpdateWithWhereUniqueWithoutUsersInput | UserSavedCoursesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserSavedCoursesUpdateManyWithWhereWithoutUsersInput | UserSavedCoursesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserSavedCoursesScalarWhereInput | UserSavedCoursesScalarWhereInput[]
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAssessmentQuestions_question_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentQuestions_question_type | EnumAssessmentQuestions_question_typeFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentQuestions_question_type[]
    notIn?: $Enums.AssessmentQuestions_question_type[]
    not?: NestedEnumAssessmentQuestions_question_typeFilter<$PrismaModel> | $Enums.AssessmentQuestions_question_type
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumAssessmentQuestions_question_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssessmentQuestions_question_type | EnumAssessmentQuestions_question_typeFieldRefInput<$PrismaModel>
    in?: $Enums.AssessmentQuestions_question_type[]
    notIn?: $Enums.AssessmentQuestions_question_type[]
    not?: NestedEnumAssessmentQuestions_question_typeWithAggregatesFilter<$PrismaModel> | $Enums.AssessmentQuestions_question_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssessmentQuestions_question_typeFilter<$PrismaModel>
    _max?: NestedEnumAssessmentQuestions_question_typeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumCourseContent_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseContent_type | EnumCourseContent_typeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseContent_type[]
    notIn?: $Enums.CourseContent_type[]
    not?: NestedEnumCourseContent_typeFilter<$PrismaModel> | $Enums.CourseContent_type
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCourseContent_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseContent_type | EnumCourseContent_typeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseContent_type[]
    notIn?: $Enums.CourseContent_type[]
    not?: NestedEnumCourseContent_typeWithAggregatesFilter<$PrismaModel> | $Enums.CourseContent_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseContent_typeFilter<$PrismaModel>
    _max?: NestedEnumCourseContent_typeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumCourseTags_tag_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseTags_tag_type | EnumCourseTags_tag_typeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseTags_tag_type[]
    notIn?: $Enums.CourseTags_tag_type[]
    not?: NestedEnumCourseTags_tag_typeFilter<$PrismaModel> | $Enums.CourseTags_tag_type
  }

  export type NestedEnumCourseTags_tag_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseTags_tag_type | EnumCourseTags_tag_typeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseTags_tag_type[]
    notIn?: $Enums.CourseTags_tag_type[]
    not?: NestedEnumCourseTags_tag_typeWithAggregatesFilter<$PrismaModel> | $Enums.CourseTags_tag_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTags_tag_typeFilter<$PrismaModel>
    _max?: NestedEnumCourseTags_tag_typeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumCourses_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.Courses_level | EnumCourses_levelFieldRefInput<$PrismaModel>
    in?: $Enums.Courses_level[]
    notIn?: $Enums.Courses_level[]
    not?: NestedEnumCourses_levelFilter<$PrismaModel> | $Enums.Courses_level
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumCourses_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Courses_level | EnumCourses_levelFieldRefInput<$PrismaModel>
    in?: $Enums.Courses_level[]
    notIn?: $Enums.Courses_level[]
    not?: NestedEnumCourses_levelWithAggregatesFilter<$PrismaModel> | $Enums.Courses_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourses_levelFilter<$PrismaModel>
    _max?: NestedEnumCourses_levelFilter<$PrismaModel>
  }

  export type NestedEnumMultiFactorAuth_mfa_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.MultiFactorAuth_mfa_type | EnumMultiFactorAuth_mfa_typeFieldRefInput<$PrismaModel>
    in?: $Enums.MultiFactorAuth_mfa_type[]
    notIn?: $Enums.MultiFactorAuth_mfa_type[]
    not?: NestedEnumMultiFactorAuth_mfa_typeFilter<$PrismaModel> | $Enums.MultiFactorAuth_mfa_type
  }

  export type NestedEnumMultiFactorAuth_mfa_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MultiFactorAuth_mfa_type | EnumMultiFactorAuth_mfa_typeFieldRefInput<$PrismaModel>
    in?: $Enums.MultiFactorAuth_mfa_type[]
    notIn?: $Enums.MultiFactorAuth_mfa_type[]
    not?: NestedEnumMultiFactorAuth_mfa_typeWithAggregatesFilter<$PrismaModel> | $Enums.MultiFactorAuth_mfa_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMultiFactorAuth_mfa_typeFilter<$PrismaModel>
    _max?: NestedEnumMultiFactorAuth_mfa_typeFilter<$PrismaModel>
  }

  export type NestedEnumNotifications_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Notifications_type | EnumNotifications_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Notifications_type[] | null
    notIn?: $Enums.Notifications_type[] | null
    not?: NestedEnumNotifications_typeNullableFilter<$PrismaModel> | $Enums.Notifications_type | null
  }

  export type NestedEnumNotifications_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Notifications_type | EnumNotifications_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Notifications_type[] | null
    notIn?: $Enums.Notifications_type[] | null
    not?: NestedEnumNotifications_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Notifications_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotifications_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotifications_typeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumPayments_methodFilter<$PrismaModel = never> = {
    equals?: $Enums.Payments_method | EnumPayments_methodFieldRefInput<$PrismaModel>
    in?: $Enums.Payments_method[]
    notIn?: $Enums.Payments_method[]
    not?: NestedEnumPayments_methodFilter<$PrismaModel> | $Enums.Payments_method
  }

  export type NestedEnumPayments_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.Payments_status | EnumPayments_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Payments_status[]
    notIn?: $Enums.Payments_status[]
    not?: NestedEnumPayments_statusFilter<$PrismaModel> | $Enums.Payments_status
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPayments_methodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Payments_method | EnumPayments_methodFieldRefInput<$PrismaModel>
    in?: $Enums.Payments_method[]
    notIn?: $Enums.Payments_method[]
    not?: NestedEnumPayments_methodWithAggregatesFilter<$PrismaModel> | $Enums.Payments_method
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayments_methodFilter<$PrismaModel>
    _max?: NestedEnumPayments_methodFilter<$PrismaModel>
  }

  export type NestedEnumPayments_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Payments_status | EnumPayments_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Payments_status[]
    notIn?: $Enums.Payments_status[]
    not?: NestedEnumPayments_statusWithAggregatesFilter<$PrismaModel> | $Enums.Payments_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayments_statusFilter<$PrismaModel>
    _max?: NestedEnumPayments_statusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.Subscriptions_status | EnumSubscriptions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Subscriptions_status[]
    notIn?: $Enums.Subscriptions_status[]
    not?: NestedEnumSubscriptions_statusFilter<$PrismaModel> | $Enums.Subscriptions_status
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumSubscriptions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Subscriptions_status | EnumSubscriptions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Subscriptions_status[]
    notIn?: $Enums.Subscriptions_status[]
    not?: NestedEnumSubscriptions_statusWithAggregatesFilter<$PrismaModel> | $Enums.Subscriptions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptions_statusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptions_statusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUsers_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.Users_role | EnumUsers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.Users_role[]
    notIn?: $Enums.Users_role[]
    not?: NestedEnumUsers_roleFilter<$PrismaModel> | $Enums.Users_role
  }

  export type NestedEnumUsers_instructor_application_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.Users_instructor_application_status | EnumUsers_instructor_application_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Users_instructor_application_status[]
    notIn?: $Enums.Users_instructor_application_status[]
    not?: NestedEnumUsers_instructor_application_statusFilter<$PrismaModel> | $Enums.Users_instructor_application_status
  }

  export type NestedEnumUsers_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Users_role | EnumUsers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.Users_role[]
    notIn?: $Enums.Users_role[]
    not?: NestedEnumUsers_roleWithAggregatesFilter<$PrismaModel> | $Enums.Users_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsers_roleFilter<$PrismaModel>
    _max?: NestedEnumUsers_roleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUsers_instructor_application_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Users_instructor_application_status | EnumUsers_instructor_application_statusFieldRefInput<$PrismaModel>
    in?: $Enums.Users_instructor_application_status[]
    notIn?: $Enums.Users_instructor_application_status[]
    not?: NestedEnumUsers_instructor_application_statusWithAggregatesFilter<$PrismaModel> | $Enums.Users_instructor_application_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsers_instructor_application_statusFilter<$PrismaModel>
    _max?: NestedEnumUsers_instructor_application_statusFilter<$PrismaModel>
  }

  export type AssessmentQuestionsCreateWithoutAssessmentOptionsInput = {
    id?: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
    Assessments: AssessmentsCreateNestedOneWithoutAssessmentQuestionsInput
    UserAnswers?: UserAnswersCreateNestedManyWithoutAssessmentQuestionsInput
  }

  export type AssessmentQuestionsUncheckedCreateWithoutAssessmentOptionsInput = {
    id?: bigint | number
    assessment_id: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
    UserAnswers?: UserAnswersUncheckedCreateNestedManyWithoutAssessmentQuestionsInput
  }

  export type AssessmentQuestionsCreateOrConnectWithoutAssessmentOptionsInput = {
    where: AssessmentQuestionsWhereUniqueInput
    create: XOR<AssessmentQuestionsCreateWithoutAssessmentOptionsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentOptionsInput>
  }

  export type UserAnswersCreateWithoutAssessmentOptionsInput = {
    id?: bigint | number
    answer_text?: string | null
    QuizAttempts: QuizAttemptsCreateNestedOneWithoutUserAnswersInput
    AssessmentQuestions: AssessmentQuestionsCreateNestedOneWithoutUserAnswersInput
  }

  export type UserAnswersUncheckedCreateWithoutAssessmentOptionsInput = {
    id?: bigint | number
    attempt_id: bigint | number
    question_id: bigint | number
    answer_text?: string | null
  }

  export type UserAnswersCreateOrConnectWithoutAssessmentOptionsInput = {
    where: UserAnswersWhereUniqueInput
    create: XOR<UserAnswersCreateWithoutAssessmentOptionsInput, UserAnswersUncheckedCreateWithoutAssessmentOptionsInput>
  }

  export type UserAnswersCreateManyAssessmentOptionsInputEnvelope = {
    data: UserAnswersCreateManyAssessmentOptionsInput | UserAnswersCreateManyAssessmentOptionsInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentQuestionsUpsertWithoutAssessmentOptionsInput = {
    update: XOR<AssessmentQuestionsUpdateWithoutAssessmentOptionsInput, AssessmentQuestionsUncheckedUpdateWithoutAssessmentOptionsInput>
    create: XOR<AssessmentQuestionsCreateWithoutAssessmentOptionsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentOptionsInput>
    where?: AssessmentQuestionsWhereInput
  }

  export type AssessmentQuestionsUpdateToOneWithWhereWithoutAssessmentOptionsInput = {
    where?: AssessmentQuestionsWhereInput
    data: XOR<AssessmentQuestionsUpdateWithoutAssessmentOptionsInput, AssessmentQuestionsUncheckedUpdateWithoutAssessmentOptionsInput>
  }

  export type AssessmentQuestionsUpdateWithoutAssessmentOptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
    Assessments?: AssessmentsUpdateOneRequiredWithoutAssessmentQuestionsNestedInput
    UserAnswers?: UserAnswersUpdateManyWithoutAssessmentQuestionsNestedInput
  }

  export type AssessmentQuestionsUncheckedUpdateWithoutAssessmentOptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assessment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
    UserAnswers?: UserAnswersUncheckedUpdateManyWithoutAssessmentQuestionsNestedInput
  }

  export type UserAnswersUpsertWithWhereUniqueWithoutAssessmentOptionsInput = {
    where: UserAnswersWhereUniqueInput
    update: XOR<UserAnswersUpdateWithoutAssessmentOptionsInput, UserAnswersUncheckedUpdateWithoutAssessmentOptionsInput>
    create: XOR<UserAnswersCreateWithoutAssessmentOptionsInput, UserAnswersUncheckedCreateWithoutAssessmentOptionsInput>
  }

  export type UserAnswersUpdateWithWhereUniqueWithoutAssessmentOptionsInput = {
    where: UserAnswersWhereUniqueInput
    data: XOR<UserAnswersUpdateWithoutAssessmentOptionsInput, UserAnswersUncheckedUpdateWithoutAssessmentOptionsInput>
  }

  export type UserAnswersUpdateManyWithWhereWithoutAssessmentOptionsInput = {
    where: UserAnswersScalarWhereInput
    data: XOR<UserAnswersUpdateManyMutationInput, UserAnswersUncheckedUpdateManyWithoutAssessmentOptionsInput>
  }

  export type UserAnswersScalarWhereInput = {
    AND?: UserAnswersScalarWhereInput | UserAnswersScalarWhereInput[]
    OR?: UserAnswersScalarWhereInput[]
    NOT?: UserAnswersScalarWhereInput | UserAnswersScalarWhereInput[]
    id?: BigIntFilter<"UserAnswers"> | bigint | number
    attempt_id?: BigIntFilter<"UserAnswers"> | bigint | number
    question_id?: BigIntFilter<"UserAnswers"> | bigint | number
    selected_option_id?: BigIntNullableFilter<"UserAnswers"> | bigint | number | null
    answer_text?: StringNullableFilter<"UserAnswers"> | string | null
  }

  export type AssessmentOptionsCreateWithoutAssessmentQuestionsInput = {
    id?: bigint | number
    option_text?: string | null
    is_correct?: boolean | null
    UserAnswers?: UserAnswersCreateNestedManyWithoutAssessmentOptionsInput
  }

  export type AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput = {
    id?: bigint | number
    option_text?: string | null
    is_correct?: boolean | null
    UserAnswers?: UserAnswersUncheckedCreateNestedManyWithoutAssessmentOptionsInput
  }

  export type AssessmentOptionsCreateOrConnectWithoutAssessmentQuestionsInput = {
    where: AssessmentOptionsWhereUniqueInput
    create: XOR<AssessmentOptionsCreateWithoutAssessmentQuestionsInput, AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput>
  }

  export type AssessmentOptionsCreateManyAssessmentQuestionsInputEnvelope = {
    data: AssessmentOptionsCreateManyAssessmentQuestionsInput | AssessmentOptionsCreateManyAssessmentQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentsCreateWithoutAssessmentQuestionsInput = {
    id?: bigint | number
    title?: string | null
    instructions?: string | null
    CourseContent: CourseContentCreateNestedOneWithoutAssessmentsInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutAssessmentsInput
  }

  export type AssessmentsUncheckedCreateWithoutAssessmentQuestionsInput = {
    id?: bigint | number
    content_id: bigint | number
    title?: string | null
    instructions?: string | null
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutAssessmentsInput
  }

  export type AssessmentsCreateOrConnectWithoutAssessmentQuestionsInput = {
    where: AssessmentsWhereUniqueInput
    create: XOR<AssessmentsCreateWithoutAssessmentQuestionsInput, AssessmentsUncheckedCreateWithoutAssessmentQuestionsInput>
  }

  export type UserAnswersCreateWithoutAssessmentQuestionsInput = {
    id?: bigint | number
    answer_text?: string | null
    QuizAttempts: QuizAttemptsCreateNestedOneWithoutUserAnswersInput
    AssessmentOptions?: AssessmentOptionsCreateNestedOneWithoutUserAnswersInput
  }

  export type UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput = {
    id?: bigint | number
    attempt_id: bigint | number
    selected_option_id?: bigint | number | null
    answer_text?: string | null
  }

  export type UserAnswersCreateOrConnectWithoutAssessmentQuestionsInput = {
    where: UserAnswersWhereUniqueInput
    create: XOR<UserAnswersCreateWithoutAssessmentQuestionsInput, UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput>
  }

  export type UserAnswersCreateManyAssessmentQuestionsInputEnvelope = {
    data: UserAnswersCreateManyAssessmentQuestionsInput | UserAnswersCreateManyAssessmentQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentOptionsUpsertWithWhereUniqueWithoutAssessmentQuestionsInput = {
    where: AssessmentOptionsWhereUniqueInput
    update: XOR<AssessmentOptionsUpdateWithoutAssessmentQuestionsInput, AssessmentOptionsUncheckedUpdateWithoutAssessmentQuestionsInput>
    create: XOR<AssessmentOptionsCreateWithoutAssessmentQuestionsInput, AssessmentOptionsUncheckedCreateWithoutAssessmentQuestionsInput>
  }

  export type AssessmentOptionsUpdateWithWhereUniqueWithoutAssessmentQuestionsInput = {
    where: AssessmentOptionsWhereUniqueInput
    data: XOR<AssessmentOptionsUpdateWithoutAssessmentQuestionsInput, AssessmentOptionsUncheckedUpdateWithoutAssessmentQuestionsInput>
  }

  export type AssessmentOptionsUpdateManyWithWhereWithoutAssessmentQuestionsInput = {
    where: AssessmentOptionsScalarWhereInput
    data: XOR<AssessmentOptionsUpdateManyMutationInput, AssessmentOptionsUncheckedUpdateManyWithoutAssessmentQuestionsInput>
  }

  export type AssessmentOptionsScalarWhereInput = {
    AND?: AssessmentOptionsScalarWhereInput | AssessmentOptionsScalarWhereInput[]
    OR?: AssessmentOptionsScalarWhereInput[]
    NOT?: AssessmentOptionsScalarWhereInput | AssessmentOptionsScalarWhereInput[]
    id?: BigIntFilter<"AssessmentOptions"> | bigint | number
    question_id?: BigIntFilter<"AssessmentOptions"> | bigint | number
    option_text?: StringNullableFilter<"AssessmentOptions"> | string | null
    is_correct?: BoolNullableFilter<"AssessmentOptions"> | boolean | null
  }

  export type AssessmentsUpsertWithoutAssessmentQuestionsInput = {
    update: XOR<AssessmentsUpdateWithoutAssessmentQuestionsInput, AssessmentsUncheckedUpdateWithoutAssessmentQuestionsInput>
    create: XOR<AssessmentsCreateWithoutAssessmentQuestionsInput, AssessmentsUncheckedCreateWithoutAssessmentQuestionsInput>
    where?: AssessmentsWhereInput
  }

  export type AssessmentsUpdateToOneWithWhereWithoutAssessmentQuestionsInput = {
    where?: AssessmentsWhereInput
    data: XOR<AssessmentsUpdateWithoutAssessmentQuestionsInput, AssessmentsUncheckedUpdateWithoutAssessmentQuestionsInput>
  }

  export type AssessmentsUpdateWithoutAssessmentQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    CourseContent?: CourseContentUpdateOneRequiredWithoutAssessmentsNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutAssessmentsNestedInput
  }

  export type AssessmentsUncheckedUpdateWithoutAssessmentQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutAssessmentsNestedInput
  }

  export type UserAnswersUpsertWithWhereUniqueWithoutAssessmentQuestionsInput = {
    where: UserAnswersWhereUniqueInput
    update: XOR<UserAnswersUpdateWithoutAssessmentQuestionsInput, UserAnswersUncheckedUpdateWithoutAssessmentQuestionsInput>
    create: XOR<UserAnswersCreateWithoutAssessmentQuestionsInput, UserAnswersUncheckedCreateWithoutAssessmentQuestionsInput>
  }

  export type UserAnswersUpdateWithWhereUniqueWithoutAssessmentQuestionsInput = {
    where: UserAnswersWhereUniqueInput
    data: XOR<UserAnswersUpdateWithoutAssessmentQuestionsInput, UserAnswersUncheckedUpdateWithoutAssessmentQuestionsInput>
  }

  export type UserAnswersUpdateManyWithWhereWithoutAssessmentQuestionsInput = {
    where: UserAnswersScalarWhereInput
    data: XOR<UserAnswersUpdateManyMutationInput, UserAnswersUncheckedUpdateManyWithoutAssessmentQuestionsInput>
  }

  export type AssessmentQuestionsCreateWithoutAssessmentsInput = {
    id?: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsCreateNestedManyWithoutAssessmentQuestionsInput
    UserAnswers?: UserAnswersCreateNestedManyWithoutAssessmentQuestionsInput
  }

  export type AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput = {
    id?: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsUncheckedCreateNestedManyWithoutAssessmentQuestionsInput
    UserAnswers?: UserAnswersUncheckedCreateNestedManyWithoutAssessmentQuestionsInput
  }

  export type AssessmentQuestionsCreateOrConnectWithoutAssessmentsInput = {
    where: AssessmentQuestionsWhereUniqueInput
    create: XOR<AssessmentQuestionsCreateWithoutAssessmentsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput>
  }

  export type AssessmentQuestionsCreateManyAssessmentsInputEnvelope = {
    data: AssessmentQuestionsCreateManyAssessmentsInput | AssessmentQuestionsCreateManyAssessmentsInput[]
    skipDuplicates?: boolean
  }

  export type CourseContentCreateWithoutAssessmentsInput = {
    id?: bigint | number
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Courses: CoursesCreateNestedOneWithoutCourseContentInput
    CourseContent?: CourseContentCreateNestedOneWithoutOther_CourseContentInput
    other_CourseContent?: CourseContentCreateNestedManyWithoutCourseContentInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentUncheckedCreateWithoutAssessmentsInput = {
    id?: bigint | number
    course_id: bigint | number
    parent_id?: bigint | number | null
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    other_CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCourseContentInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentCreateOrConnectWithoutAssessmentsInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutAssessmentsInput, CourseContentUncheckedCreateWithoutAssessmentsInput>
  }

  export type QuizAttemptsCreateWithoutAssessmentsInput = {
    id?: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    Users: UsersCreateNestedOneWithoutQuizAttemptsInput
    UserAnswers?: UserAnswersCreateNestedManyWithoutQuizAttemptsInput
  }

  export type QuizAttemptsUncheckedCreateWithoutAssessmentsInput = {
    id?: bigint | number
    user_id: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    UserAnswers?: UserAnswersUncheckedCreateNestedManyWithoutQuizAttemptsInput
  }

  export type QuizAttemptsCreateOrConnectWithoutAssessmentsInput = {
    where: QuizAttemptsWhereUniqueInput
    create: XOR<QuizAttemptsCreateWithoutAssessmentsInput, QuizAttemptsUncheckedCreateWithoutAssessmentsInput>
  }

  export type QuizAttemptsCreateManyAssessmentsInputEnvelope = {
    data: QuizAttemptsCreateManyAssessmentsInput | QuizAttemptsCreateManyAssessmentsInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentQuestionsUpsertWithWhereUniqueWithoutAssessmentsInput = {
    where: AssessmentQuestionsWhereUniqueInput
    update: XOR<AssessmentQuestionsUpdateWithoutAssessmentsInput, AssessmentQuestionsUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<AssessmentQuestionsCreateWithoutAssessmentsInput, AssessmentQuestionsUncheckedCreateWithoutAssessmentsInput>
  }

  export type AssessmentQuestionsUpdateWithWhereUniqueWithoutAssessmentsInput = {
    where: AssessmentQuestionsWhereUniqueInput
    data: XOR<AssessmentQuestionsUpdateWithoutAssessmentsInput, AssessmentQuestionsUncheckedUpdateWithoutAssessmentsInput>
  }

  export type AssessmentQuestionsUpdateManyWithWhereWithoutAssessmentsInput = {
    where: AssessmentQuestionsScalarWhereInput
    data: XOR<AssessmentQuestionsUpdateManyMutationInput, AssessmentQuestionsUncheckedUpdateManyWithoutAssessmentsInput>
  }

  export type AssessmentQuestionsScalarWhereInput = {
    AND?: AssessmentQuestionsScalarWhereInput | AssessmentQuestionsScalarWhereInput[]
    OR?: AssessmentQuestionsScalarWhereInput[]
    NOT?: AssessmentQuestionsScalarWhereInput | AssessmentQuestionsScalarWhereInput[]
    id?: BigIntFilter<"AssessmentQuestions"> | bigint | number
    assessment_id?: BigIntFilter<"AssessmentQuestions"> | bigint | number
    question_text?: StringFilter<"AssessmentQuestions"> | string
    question_type?: EnumAssessmentQuestions_question_typeFilter<"AssessmentQuestions"> | $Enums.AssessmentQuestions_question_type
  }

  export type CourseContentUpsertWithoutAssessmentsInput = {
    update: XOR<CourseContentUpdateWithoutAssessmentsInput, CourseContentUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<CourseContentCreateWithoutAssessmentsInput, CourseContentUncheckedCreateWithoutAssessmentsInput>
    where?: CourseContentWhereInput
  }

  export type CourseContentUpdateToOneWithWhereWithoutAssessmentsInput = {
    where?: CourseContentWhereInput
    data: XOR<CourseContentUpdateWithoutAssessmentsInput, CourseContentUncheckedUpdateWithoutAssessmentsInput>
  }

  export type CourseContentUpdateWithoutAssessmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Courses?: CoursesUpdateOneRequiredWithoutCourseContentNestedInput
    CourseContent?: CourseContentUpdateOneWithoutOther_CourseContentNestedInput
    other_CourseContent?: CourseContentUpdateManyWithoutCourseContentNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutAssessmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    other_CourseContent?: CourseContentUncheckedUpdateManyWithoutCourseContentNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutCourseContentNestedInput
  }

  export type QuizAttemptsUpsertWithWhereUniqueWithoutAssessmentsInput = {
    where: QuizAttemptsWhereUniqueInput
    update: XOR<QuizAttemptsUpdateWithoutAssessmentsInput, QuizAttemptsUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<QuizAttemptsCreateWithoutAssessmentsInput, QuizAttemptsUncheckedCreateWithoutAssessmentsInput>
  }

  export type QuizAttemptsUpdateWithWhereUniqueWithoutAssessmentsInput = {
    where: QuizAttemptsWhereUniqueInput
    data: XOR<QuizAttemptsUpdateWithoutAssessmentsInput, QuizAttemptsUncheckedUpdateWithoutAssessmentsInput>
  }

  export type QuizAttemptsUpdateManyWithWhereWithoutAssessmentsInput = {
    where: QuizAttemptsScalarWhereInput
    data: XOR<QuizAttemptsUpdateManyMutationInput, QuizAttemptsUncheckedUpdateManyWithoutAssessmentsInput>
  }

  export type QuizAttemptsScalarWhereInput = {
    AND?: QuizAttemptsScalarWhereInput | QuizAttemptsScalarWhereInput[]
    OR?: QuizAttemptsScalarWhereInput[]
    NOT?: QuizAttemptsScalarWhereInput | QuizAttemptsScalarWhereInput[]
    id?: BigIntFilter<"QuizAttempts"> | bigint | number
    user_id?: BigIntFilter<"QuizAttempts"> | bigint | number
    assessment_id?: BigIntFilter<"QuizAttempts"> | bigint | number
    score?: IntNullableFilter<"QuizAttempts"> | number | null
    started_at?: DateTimeNullableFilter<"QuizAttempts"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"QuizAttempts"> | Date | string | null
  }

  export type CoursesCreateWithoutCategoriesInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutCategoriesInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutCategoriesInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutCategoriesInput, CoursesUncheckedCreateWithoutCategoriesInput>
  }

  export type CoursesCreateManyCategoriesInputEnvelope = {
    data: CoursesCreateManyCategoriesInput | CoursesCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type CoursesUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: CoursesWhereUniqueInput
    update: XOR<CoursesUpdateWithoutCategoriesInput, CoursesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<CoursesCreateWithoutCategoriesInput, CoursesUncheckedCreateWithoutCategoriesInput>
  }

  export type CoursesUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: CoursesWhereUniqueInput
    data: XOR<CoursesUpdateWithoutCategoriesInput, CoursesUncheckedUpdateWithoutCategoriesInput>
  }

  export type CoursesUpdateManyWithWhereWithoutCategoriesInput = {
    where: CoursesScalarWhereInput
    data: XOR<CoursesUpdateManyMutationInput, CoursesUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type CoursesScalarWhereInput = {
    AND?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
    OR?: CoursesScalarWhereInput[]
    NOT?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
    id?: BigIntFilter<"Courses"> | bigint | number
    instructor_id?: BigIntFilter<"Courses"> | bigint | number
    title?: StringFilter<"Courses"> | string
    subtitle?: StringNullableFilter<"Courses"> | string | null
    description?: StringNullableFilter<"Courses"> | string | null
    category_id?: BigIntFilter<"Courses"> | bigint | number
    price?: DecimalNullableFilter<"Courses"> | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: StringNullableFilter<"Courses"> | string | null
    level?: EnumCourses_levelFilter<"Courses"> | $Enums.Courses_level
    views?: IntNullableFilter<"Courses"> | number | null
    enrollments_count?: IntNullableFilter<"Courses"> | number | null
    created_at?: DateTimeNullableFilter<"Courses"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"Courses"> | Date | string | null
  }

  export type CoursesCreateWithoutCertificatesInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutCertificatesInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutCertificatesInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutCertificatesInput, CoursesUncheckedCreateWithoutCertificatesInput>
  }

  export type UsersCreateWithoutCertificatesInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutCertificatesInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutCertificatesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCertificatesInput, UsersUncheckedCreateWithoutCertificatesInput>
  }

  export type CoursesUpsertWithoutCertificatesInput = {
    update: XOR<CoursesUpdateWithoutCertificatesInput, CoursesUncheckedUpdateWithoutCertificatesInput>
    create: XOR<CoursesCreateWithoutCertificatesInput, CoursesUncheckedCreateWithoutCertificatesInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutCertificatesInput, CoursesUncheckedUpdateWithoutCertificatesInput>
  }

  export type CoursesUpdateWithoutCertificatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutCertificatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type UsersUpsertWithoutCertificatesInput = {
    update: XOR<UsersUpdateWithoutCertificatesInput, UsersUncheckedUpdateWithoutCertificatesInput>
    create: XOR<UsersCreateWithoutCertificatesInput, UsersUncheckedCreateWithoutCertificatesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCertificatesInput, UsersUncheckedUpdateWithoutCertificatesInput>
  }

  export type UsersUpdateWithoutCertificatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutCertificatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type AssessmentsCreateWithoutCourseContentInput = {
    id?: bigint | number
    title?: string | null
    instructions?: string | null
    AssessmentQuestions?: AssessmentQuestionsCreateNestedManyWithoutAssessmentsInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutAssessmentsInput
  }

  export type AssessmentsUncheckedCreateWithoutCourseContentInput = {
    id?: bigint | number
    title?: string | null
    instructions?: string | null
    AssessmentQuestions?: AssessmentQuestionsUncheckedCreateNestedManyWithoutAssessmentsInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutAssessmentsInput
  }

  export type AssessmentsCreateOrConnectWithoutCourseContentInput = {
    where: AssessmentsWhereUniqueInput
    create: XOR<AssessmentsCreateWithoutCourseContentInput, AssessmentsUncheckedCreateWithoutCourseContentInput>
  }

  export type AssessmentsCreateManyCourseContentInputEnvelope = {
    data: AssessmentsCreateManyCourseContentInput | AssessmentsCreateManyCourseContentInput[]
    skipDuplicates?: boolean
  }

  export type CoursesCreateWithoutCourseContentInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutCourseContentInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutCourseContentInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutCourseContentInput, CoursesUncheckedCreateWithoutCourseContentInput>
  }

  export type CourseContentCreateWithoutOther_CourseContentInput = {
    id?: bigint | number
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsCreateNestedManyWithoutCourseContentInput
    Courses: CoursesCreateNestedOneWithoutCourseContentInput
    CourseContent?: CourseContentCreateNestedOneWithoutOther_CourseContentInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentUncheckedCreateWithoutOther_CourseContentInput = {
    id?: bigint | number
    course_id: bigint | number
    parent_id?: bigint | number | null
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsUncheckedCreateNestedManyWithoutCourseContentInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentCreateOrConnectWithoutOther_CourseContentInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutOther_CourseContentInput, CourseContentUncheckedCreateWithoutOther_CourseContentInput>
  }

  export type CourseContentCreateWithoutCourseContentInput = {
    id?: bigint | number
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsCreateNestedManyWithoutCourseContentInput
    Courses: CoursesCreateNestedOneWithoutCourseContentInput
    other_CourseContent?: CourseContentCreateNestedManyWithoutCourseContentInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentUncheckedCreateWithoutCourseContentInput = {
    id?: bigint | number
    course_id: bigint | number
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsUncheckedCreateNestedManyWithoutCourseContentInput
    other_CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCourseContentInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentCreateOrConnectWithoutCourseContentInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutCourseContentInput, CourseContentUncheckedCreateWithoutCourseContentInput>
  }

  export type CourseContentCreateManyCourseContentInputEnvelope = {
    data: CourseContentCreateManyCourseContentInput | CourseContentCreateManyCourseContentInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressCreateWithoutCourseContentInput = {
    id?: bigint | number
    is_completed?: boolean | null
    completed_at?: Date | string | null
    Users: UsersCreateNestedOneWithoutLessonProgressInput
  }

  export type LessonProgressUncheckedCreateWithoutCourseContentInput = {
    id?: bigint | number
    user_id: bigint | number
    is_completed?: boolean | null
    completed_at?: Date | string | null
  }

  export type LessonProgressCreateOrConnectWithoutCourseContentInput = {
    where: LessonProgressWhereUniqueInput
    create: XOR<LessonProgressCreateWithoutCourseContentInput, LessonProgressUncheckedCreateWithoutCourseContentInput>
  }

  export type LessonProgressCreateManyCourseContentInputEnvelope = {
    data: LessonProgressCreateManyCourseContentInput | LessonProgressCreateManyCourseContentInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentsUpsertWithWhereUniqueWithoutCourseContentInput = {
    where: AssessmentsWhereUniqueInput
    update: XOR<AssessmentsUpdateWithoutCourseContentInput, AssessmentsUncheckedUpdateWithoutCourseContentInput>
    create: XOR<AssessmentsCreateWithoutCourseContentInput, AssessmentsUncheckedCreateWithoutCourseContentInput>
  }

  export type AssessmentsUpdateWithWhereUniqueWithoutCourseContentInput = {
    where: AssessmentsWhereUniqueInput
    data: XOR<AssessmentsUpdateWithoutCourseContentInput, AssessmentsUncheckedUpdateWithoutCourseContentInput>
  }

  export type AssessmentsUpdateManyWithWhereWithoutCourseContentInput = {
    where: AssessmentsScalarWhereInput
    data: XOR<AssessmentsUpdateManyMutationInput, AssessmentsUncheckedUpdateManyWithoutCourseContentInput>
  }

  export type AssessmentsScalarWhereInput = {
    AND?: AssessmentsScalarWhereInput | AssessmentsScalarWhereInput[]
    OR?: AssessmentsScalarWhereInput[]
    NOT?: AssessmentsScalarWhereInput | AssessmentsScalarWhereInput[]
    id?: BigIntFilter<"Assessments"> | bigint | number
    content_id?: BigIntFilter<"Assessments"> | bigint | number
    title?: StringNullableFilter<"Assessments"> | string | null
    instructions?: StringNullableFilter<"Assessments"> | string | null
  }

  export type CoursesUpsertWithoutCourseContentInput = {
    update: XOR<CoursesUpdateWithoutCourseContentInput, CoursesUncheckedUpdateWithoutCourseContentInput>
    create: XOR<CoursesCreateWithoutCourseContentInput, CoursesUncheckedCreateWithoutCourseContentInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutCourseContentInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutCourseContentInput, CoursesUncheckedUpdateWithoutCourseContentInput>
  }

  export type CoursesUpdateWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CourseContentUpsertWithoutOther_CourseContentInput = {
    update: XOR<CourseContentUpdateWithoutOther_CourseContentInput, CourseContentUncheckedUpdateWithoutOther_CourseContentInput>
    create: XOR<CourseContentCreateWithoutOther_CourseContentInput, CourseContentUncheckedCreateWithoutOther_CourseContentInput>
    where?: CourseContentWhereInput
  }

  export type CourseContentUpdateToOneWithWhereWithoutOther_CourseContentInput = {
    where?: CourseContentWhereInput
    data: XOR<CourseContentUpdateWithoutOther_CourseContentInput, CourseContentUncheckedUpdateWithoutOther_CourseContentInput>
  }

  export type CourseContentUpdateWithoutOther_CourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUpdateManyWithoutCourseContentNestedInput
    Courses?: CoursesUpdateOneRequiredWithoutCourseContentNestedInput
    CourseContent?: CourseContentUpdateOneWithoutOther_CourseContentNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutOther_CourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUncheckedUpdateManyWithoutCourseContentNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentUpsertWithWhereUniqueWithoutCourseContentInput = {
    where: CourseContentWhereUniqueInput
    update: XOR<CourseContentUpdateWithoutCourseContentInput, CourseContentUncheckedUpdateWithoutCourseContentInput>
    create: XOR<CourseContentCreateWithoutCourseContentInput, CourseContentUncheckedCreateWithoutCourseContentInput>
  }

  export type CourseContentUpdateWithWhereUniqueWithoutCourseContentInput = {
    where: CourseContentWhereUniqueInput
    data: XOR<CourseContentUpdateWithoutCourseContentInput, CourseContentUncheckedUpdateWithoutCourseContentInput>
  }

  export type CourseContentUpdateManyWithWhereWithoutCourseContentInput = {
    where: CourseContentScalarWhereInput
    data: XOR<CourseContentUpdateManyMutationInput, CourseContentUncheckedUpdateManyWithoutCourseContentInput>
  }

  export type CourseContentScalarWhereInput = {
    AND?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
    OR?: CourseContentScalarWhereInput[]
    NOT?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
    id?: BigIntFilter<"CourseContent"> | bigint | number
    course_id?: BigIntFilter<"CourseContent"> | bigint | number
    parent_id?: BigIntNullableFilter<"CourseContent"> | bigint | number | null
    title?: StringFilter<"CourseContent"> | string
    type?: EnumCourseContent_typeFilter<"CourseContent"> | $Enums.CourseContent_type
    video_url?: StringNullableFilter<"CourseContent"> | string | null
    note_content?: StringNullableFilter<"CourseContent"> | string | null
    duration_seconds?: IntNullableFilter<"CourseContent"> | number | null
    order_index?: IntFilter<"CourseContent"> | number
  }

  export type LessonProgressUpsertWithWhereUniqueWithoutCourseContentInput = {
    where: LessonProgressWhereUniqueInput
    update: XOR<LessonProgressUpdateWithoutCourseContentInput, LessonProgressUncheckedUpdateWithoutCourseContentInput>
    create: XOR<LessonProgressCreateWithoutCourseContentInput, LessonProgressUncheckedCreateWithoutCourseContentInput>
  }

  export type LessonProgressUpdateWithWhereUniqueWithoutCourseContentInput = {
    where: LessonProgressWhereUniqueInput
    data: XOR<LessonProgressUpdateWithoutCourseContentInput, LessonProgressUncheckedUpdateWithoutCourseContentInput>
  }

  export type LessonProgressUpdateManyWithWhereWithoutCourseContentInput = {
    where: LessonProgressScalarWhereInput
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyWithoutCourseContentInput>
  }

  export type LessonProgressScalarWhereInput = {
    AND?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
    OR?: LessonProgressScalarWhereInput[]
    NOT?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
    id?: BigIntFilter<"LessonProgress"> | bigint | number
    user_id?: BigIntFilter<"LessonProgress"> | bigint | number
    content_id?: BigIntFilter<"LessonProgress"> | bigint | number
    is_completed?: BoolNullableFilter<"LessonProgress"> | boolean | null
    completed_at?: DateTimeNullableFilter<"LessonProgress"> | Date | string | null
  }

  export type CoursesCreateWithoutCourseTagsInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutCourseTagsInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutCourseTagsInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutCourseTagsInput, CoursesUncheckedCreateWithoutCourseTagsInput>
  }

  export type CoursesUpsertWithoutCourseTagsInput = {
    update: XOR<CoursesUpdateWithoutCourseTagsInput, CoursesUncheckedUpdateWithoutCourseTagsInput>
    create: XOR<CoursesCreateWithoutCourseTagsInput, CoursesUncheckedCreateWithoutCourseTagsInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutCourseTagsInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutCourseTagsInput, CoursesUncheckedUpdateWithoutCourseTagsInput>
  }

  export type CoursesUpdateWithoutCourseTagsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutCourseTagsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CertificatesCreateWithoutCoursesInput = {
    id?: bigint | number
    certificate_url?: string | null
    issued_at?: Date | string | null
    Users: UsersCreateNestedOneWithoutCertificatesInput
  }

  export type CertificatesUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    certificate_url?: string | null
    issued_at?: Date | string | null
  }

  export type CertificatesCreateOrConnectWithoutCoursesInput = {
    where: CertificatesWhereUniqueInput
    create: XOR<CertificatesCreateWithoutCoursesInput, CertificatesUncheckedCreateWithoutCoursesInput>
  }

  export type CertificatesCreateManyCoursesInputEnvelope = {
    data: CertificatesCreateManyCoursesInput | CertificatesCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type CourseContentCreateWithoutCoursesInput = {
    id?: bigint | number
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsCreateNestedManyWithoutCourseContentInput
    CourseContent?: CourseContentCreateNestedOneWithoutOther_CourseContentInput
    other_CourseContent?: CourseContentCreateNestedManyWithoutCourseContentInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    parent_id?: bigint | number | null
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsUncheckedCreateNestedManyWithoutCourseContentInput
    other_CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCourseContentInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentCreateOrConnectWithoutCoursesInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutCoursesInput, CourseContentUncheckedCreateWithoutCoursesInput>
  }

  export type CourseContentCreateManyCoursesInputEnvelope = {
    data: CourseContentCreateManyCoursesInput | CourseContentCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type CourseTagsCreateWithoutCoursesInput = {
    id?: bigint | number
    tag_name: string
    tag_type: $Enums.CourseTags_tag_type
  }

  export type CourseTagsUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    tag_name: string
    tag_type: $Enums.CourseTags_tag_type
  }

  export type CourseTagsCreateOrConnectWithoutCoursesInput = {
    where: CourseTagsWhereUniqueInput
    create: XOR<CourseTagsCreateWithoutCoursesInput, CourseTagsUncheckedCreateWithoutCoursesInput>
  }

  export type CourseTagsCreateManyCoursesInputEnvelope = {
    data: CourseTagsCreateManyCoursesInput | CourseTagsCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type CategoriesCreateWithoutCoursesInput = {
    id?: bigint | number
    name: string
  }

  export type CategoriesUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    name: string
  }

  export type CategoriesCreateOrConnectWithoutCoursesInput = {
    where: CategoriesWhereUniqueInput
    create: XOR<CategoriesCreateWithoutCoursesInput, CategoriesUncheckedCreateWithoutCoursesInput>
  }

  export type UsersCreateWithoutCoursesInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutCoursesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCoursesInput, UsersUncheckedCreateWithoutCoursesInput>
  }

  export type EnrollmentsCreateWithoutCoursesInput = {
    id?: bigint | number
    enrolled_at?: Date | string | null
    Users: UsersCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentsUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    enrolled_at?: Date | string | null
  }

  export type EnrollmentsCreateOrConnectWithoutCoursesInput = {
    where: EnrollmentsWhereUniqueInput
    create: XOR<EnrollmentsCreateWithoutCoursesInput, EnrollmentsUncheckedCreateWithoutCoursesInput>
  }

  export type EnrollmentsCreateManyCoursesInputEnvelope = {
    data: EnrollmentsCreateManyCoursesInput | EnrollmentsCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type PaymentsCreateWithoutCoursesInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    SubscriptionPlans?: SubscriptionPlansCreateNestedOneWithoutPaymentsInput
    Users: UsersCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    subscription_plan_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type PaymentsCreateOrConnectWithoutCoursesInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutCoursesInput, PaymentsUncheckedCreateWithoutCoursesInput>
  }

  export type PaymentsCreateManyCoursesInputEnvelope = {
    data: PaymentsCreateManyCoursesInput | PaymentsCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type ReviewsCreateWithoutCoursesInput = {
    id?: bigint | number
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
    Users_Reviews_instructor_idToUsers?: UsersCreateNestedOneWithoutReviews_Reviews_instructor_idToUsersInput
    Users_Reviews_user_idToUsers: UsersCreateNestedOneWithoutReviews_Reviews_user_idToUsersInput
  }

  export type ReviewsUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    instructor_id?: bigint | number | null
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
  }

  export type ReviewsCreateOrConnectWithoutCoursesInput = {
    where: ReviewsWhereUniqueInput
    create: XOR<ReviewsCreateWithoutCoursesInput, ReviewsUncheckedCreateWithoutCoursesInput>
  }

  export type ReviewsCreateManyCoursesInputEnvelope = {
    data: ReviewsCreateManyCoursesInput | ReviewsCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type ShoppingCartCreateWithoutCoursesInput = {
    id?: bigint | number
    added_at?: Date | string | null
    Users: UsersCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    added_at?: Date | string | null
  }

  export type ShoppingCartCreateOrConnectWithoutCoursesInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutCoursesInput, ShoppingCartUncheckedCreateWithoutCoursesInput>
  }

  export type ShoppingCartCreateManyCoursesInputEnvelope = {
    data: ShoppingCartCreateManyCoursesInput | ShoppingCartCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type UserSavedCoursesCreateWithoutCoursesInput = {
    id?: bigint | number
    Users: UsersCreateNestedOneWithoutUserSavedCoursesInput
  }

  export type UserSavedCoursesUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
  }

  export type UserSavedCoursesCreateOrConnectWithoutCoursesInput = {
    where: UserSavedCoursesWhereUniqueInput
    create: XOR<UserSavedCoursesCreateWithoutCoursesInput, UserSavedCoursesUncheckedCreateWithoutCoursesInput>
  }

  export type UserSavedCoursesCreateManyCoursesInputEnvelope = {
    data: UserSavedCoursesCreateManyCoursesInput | UserSavedCoursesCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type CertificatesUpsertWithWhereUniqueWithoutCoursesInput = {
    where: CertificatesWhereUniqueInput
    update: XOR<CertificatesUpdateWithoutCoursesInput, CertificatesUncheckedUpdateWithoutCoursesInput>
    create: XOR<CertificatesCreateWithoutCoursesInput, CertificatesUncheckedCreateWithoutCoursesInput>
  }

  export type CertificatesUpdateWithWhereUniqueWithoutCoursesInput = {
    where: CertificatesWhereUniqueInput
    data: XOR<CertificatesUpdateWithoutCoursesInput, CertificatesUncheckedUpdateWithoutCoursesInput>
  }

  export type CertificatesUpdateManyWithWhereWithoutCoursesInput = {
    where: CertificatesScalarWhereInput
    data: XOR<CertificatesUpdateManyMutationInput, CertificatesUncheckedUpdateManyWithoutCoursesInput>
  }

  export type CertificatesScalarWhereInput = {
    AND?: CertificatesScalarWhereInput | CertificatesScalarWhereInput[]
    OR?: CertificatesScalarWhereInput[]
    NOT?: CertificatesScalarWhereInput | CertificatesScalarWhereInput[]
    id?: BigIntFilter<"Certificates"> | bigint | number
    user_id?: BigIntFilter<"Certificates"> | bigint | number
    course_id?: BigIntFilter<"Certificates"> | bigint | number
    certificate_url?: StringNullableFilter<"Certificates"> | string | null
    issued_at?: DateTimeNullableFilter<"Certificates"> | Date | string | null
  }

  export type CourseContentUpsertWithWhereUniqueWithoutCoursesInput = {
    where: CourseContentWhereUniqueInput
    update: XOR<CourseContentUpdateWithoutCoursesInput, CourseContentUncheckedUpdateWithoutCoursesInput>
    create: XOR<CourseContentCreateWithoutCoursesInput, CourseContentUncheckedCreateWithoutCoursesInput>
  }

  export type CourseContentUpdateWithWhereUniqueWithoutCoursesInput = {
    where: CourseContentWhereUniqueInput
    data: XOR<CourseContentUpdateWithoutCoursesInput, CourseContentUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseContentUpdateManyWithWhereWithoutCoursesInput = {
    where: CourseContentScalarWhereInput
    data: XOR<CourseContentUpdateManyMutationInput, CourseContentUncheckedUpdateManyWithoutCoursesInput>
  }

  export type CourseTagsUpsertWithWhereUniqueWithoutCoursesInput = {
    where: CourseTagsWhereUniqueInput
    update: XOR<CourseTagsUpdateWithoutCoursesInput, CourseTagsUncheckedUpdateWithoutCoursesInput>
    create: XOR<CourseTagsCreateWithoutCoursesInput, CourseTagsUncheckedCreateWithoutCoursesInput>
  }

  export type CourseTagsUpdateWithWhereUniqueWithoutCoursesInput = {
    where: CourseTagsWhereUniqueInput
    data: XOR<CourseTagsUpdateWithoutCoursesInput, CourseTagsUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseTagsUpdateManyWithWhereWithoutCoursesInput = {
    where: CourseTagsScalarWhereInput
    data: XOR<CourseTagsUpdateManyMutationInput, CourseTagsUncheckedUpdateManyWithoutCoursesInput>
  }

  export type CourseTagsScalarWhereInput = {
    AND?: CourseTagsScalarWhereInput | CourseTagsScalarWhereInput[]
    OR?: CourseTagsScalarWhereInput[]
    NOT?: CourseTagsScalarWhereInput | CourseTagsScalarWhereInput[]
    id?: BigIntFilter<"CourseTags"> | bigint | number
    course_id?: BigIntFilter<"CourseTags"> | bigint | number
    tag_name?: StringFilter<"CourseTags"> | string
    tag_type?: EnumCourseTags_tag_typeFilter<"CourseTags"> | $Enums.CourseTags_tag_type
  }

  export type CategoriesUpsertWithoutCoursesInput = {
    update: XOR<CategoriesUpdateWithoutCoursesInput, CategoriesUncheckedUpdateWithoutCoursesInput>
    create: XOR<CategoriesCreateWithoutCoursesInput, CategoriesUncheckedCreateWithoutCoursesInput>
    where?: CategoriesWhereInput
  }

  export type CategoriesUpdateToOneWithWhereWithoutCoursesInput = {
    where?: CategoriesWhereInput
    data: XOR<CategoriesUpdateWithoutCoursesInput, CategoriesUncheckedUpdateWithoutCoursesInput>
  }

  export type CategoriesUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUpsertWithoutCoursesInput = {
    update: XOR<UsersUpdateWithoutCoursesInput, UsersUncheckedUpdateWithoutCoursesInput>
    create: XOR<UsersCreateWithoutCoursesInput, UsersUncheckedCreateWithoutCoursesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCoursesInput, UsersUncheckedUpdateWithoutCoursesInput>
  }

  export type UsersUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type EnrollmentsUpsertWithWhereUniqueWithoutCoursesInput = {
    where: EnrollmentsWhereUniqueInput
    update: XOR<EnrollmentsUpdateWithoutCoursesInput, EnrollmentsUncheckedUpdateWithoutCoursesInput>
    create: XOR<EnrollmentsCreateWithoutCoursesInput, EnrollmentsUncheckedCreateWithoutCoursesInput>
  }

  export type EnrollmentsUpdateWithWhereUniqueWithoutCoursesInput = {
    where: EnrollmentsWhereUniqueInput
    data: XOR<EnrollmentsUpdateWithoutCoursesInput, EnrollmentsUncheckedUpdateWithoutCoursesInput>
  }

  export type EnrollmentsUpdateManyWithWhereWithoutCoursesInput = {
    where: EnrollmentsScalarWhereInput
    data: XOR<EnrollmentsUpdateManyMutationInput, EnrollmentsUncheckedUpdateManyWithoutCoursesInput>
  }

  export type EnrollmentsScalarWhereInput = {
    AND?: EnrollmentsScalarWhereInput | EnrollmentsScalarWhereInput[]
    OR?: EnrollmentsScalarWhereInput[]
    NOT?: EnrollmentsScalarWhereInput | EnrollmentsScalarWhereInput[]
    id?: BigIntFilter<"Enrollments"> | bigint | number
    user_id?: BigIntFilter<"Enrollments"> | bigint | number
    course_id?: BigIntFilter<"Enrollments"> | bigint | number
    enrolled_at?: DateTimeNullableFilter<"Enrollments"> | Date | string | null
  }

  export type PaymentsUpsertWithWhereUniqueWithoutCoursesInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutCoursesInput, PaymentsUncheckedUpdateWithoutCoursesInput>
    create: XOR<PaymentsCreateWithoutCoursesInput, PaymentsUncheckedCreateWithoutCoursesInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutCoursesInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutCoursesInput, PaymentsUncheckedUpdateWithoutCoursesInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutCoursesInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutCoursesInput>
  }

  export type PaymentsScalarWhereInput = {
    AND?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    OR?: PaymentsScalarWhereInput[]
    NOT?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    id?: BigIntFilter<"Payments"> | bigint | number
    user_id?: BigIntFilter<"Payments"> | bigint | number
    course_id?: BigIntNullableFilter<"Payments"> | bigint | number | null
    subscription_plan_id?: BigIntNullableFilter<"Payments"> | bigint | number | null
    amount?: DecimalFilter<"Payments"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payments"> | string
    method?: EnumPayments_methodFilter<"Payments"> | $Enums.Payments_method
    status?: EnumPayments_statusFilter<"Payments"> | $Enums.Payments_status
    transaction_id?: StringNullableFilter<"Payments"> | string | null
    created_at?: DateTimeNullableFilter<"Payments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"Payments"> | Date | string | null
  }

  export type ReviewsUpsertWithWhereUniqueWithoutCoursesInput = {
    where: ReviewsWhereUniqueInput
    update: XOR<ReviewsUpdateWithoutCoursesInput, ReviewsUncheckedUpdateWithoutCoursesInput>
    create: XOR<ReviewsCreateWithoutCoursesInput, ReviewsUncheckedCreateWithoutCoursesInput>
  }

  export type ReviewsUpdateWithWhereUniqueWithoutCoursesInput = {
    where: ReviewsWhereUniqueInput
    data: XOR<ReviewsUpdateWithoutCoursesInput, ReviewsUncheckedUpdateWithoutCoursesInput>
  }

  export type ReviewsUpdateManyWithWhereWithoutCoursesInput = {
    where: ReviewsScalarWhereInput
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyWithoutCoursesInput>
  }

  export type ReviewsScalarWhereInput = {
    AND?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
    OR?: ReviewsScalarWhereInput[]
    NOT?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
    id?: BigIntFilter<"Reviews"> | bigint | number
    user_id?: BigIntFilter<"Reviews"> | bigint | number
    course_id?: BigIntNullableFilter<"Reviews"> | bigint | number | null
    instructor_id?: BigIntNullableFilter<"Reviews"> | bigint | number | null
    rating?: IntFilter<"Reviews"> | number
    review_text?: StringNullableFilter<"Reviews"> | string | null
    created_at?: DateTimeNullableFilter<"Reviews"> | Date | string | null
  }

  export type ShoppingCartUpsertWithWhereUniqueWithoutCoursesInput = {
    where: ShoppingCartWhereUniqueInput
    update: XOR<ShoppingCartUpdateWithoutCoursesInput, ShoppingCartUncheckedUpdateWithoutCoursesInput>
    create: XOR<ShoppingCartCreateWithoutCoursesInput, ShoppingCartUncheckedCreateWithoutCoursesInput>
  }

  export type ShoppingCartUpdateWithWhereUniqueWithoutCoursesInput = {
    where: ShoppingCartWhereUniqueInput
    data: XOR<ShoppingCartUpdateWithoutCoursesInput, ShoppingCartUncheckedUpdateWithoutCoursesInput>
  }

  export type ShoppingCartUpdateManyWithWhereWithoutCoursesInput = {
    where: ShoppingCartScalarWhereInput
    data: XOR<ShoppingCartUpdateManyMutationInput, ShoppingCartUncheckedUpdateManyWithoutCoursesInput>
  }

  export type ShoppingCartScalarWhereInput = {
    AND?: ShoppingCartScalarWhereInput | ShoppingCartScalarWhereInput[]
    OR?: ShoppingCartScalarWhereInput[]
    NOT?: ShoppingCartScalarWhereInput | ShoppingCartScalarWhereInput[]
    id?: BigIntFilter<"ShoppingCart"> | bigint | number
    user_id?: BigIntFilter<"ShoppingCart"> | bigint | number
    course_id?: BigIntFilter<"ShoppingCart"> | bigint | number
    added_at?: DateTimeNullableFilter<"ShoppingCart"> | Date | string | null
  }

  export type UserSavedCoursesUpsertWithWhereUniqueWithoutCoursesInput = {
    where: UserSavedCoursesWhereUniqueInput
    update: XOR<UserSavedCoursesUpdateWithoutCoursesInput, UserSavedCoursesUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserSavedCoursesCreateWithoutCoursesInput, UserSavedCoursesUncheckedCreateWithoutCoursesInput>
  }

  export type UserSavedCoursesUpdateWithWhereUniqueWithoutCoursesInput = {
    where: UserSavedCoursesWhereUniqueInput
    data: XOR<UserSavedCoursesUpdateWithoutCoursesInput, UserSavedCoursesUncheckedUpdateWithoutCoursesInput>
  }

  export type UserSavedCoursesUpdateManyWithWhereWithoutCoursesInput = {
    where: UserSavedCoursesScalarWhereInput
    data: XOR<UserSavedCoursesUpdateManyMutationInput, UserSavedCoursesUncheckedUpdateManyWithoutCoursesInput>
  }

  export type UserSavedCoursesScalarWhereInput = {
    AND?: UserSavedCoursesScalarWhereInput | UserSavedCoursesScalarWhereInput[]
    OR?: UserSavedCoursesScalarWhereInput[]
    NOT?: UserSavedCoursesScalarWhereInput | UserSavedCoursesScalarWhereInput[]
    id?: BigIntFilter<"UserSavedCourses"> | bigint | number
    user_id?: BigIntFilter<"UserSavedCourses"> | bigint | number
    course_id?: BigIntFilter<"UserSavedCourses"> | bigint | number
  }

  export type CoursesCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutEnrollmentsInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutEnrollmentsInput, CoursesUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UsersCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutEnrollmentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutEnrollmentsInput, UsersUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CoursesUpsertWithoutEnrollmentsInput = {
    update: XOR<CoursesUpdateWithoutEnrollmentsInput, CoursesUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CoursesCreateWithoutEnrollmentsInput, CoursesUncheckedCreateWithoutEnrollmentsInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutEnrollmentsInput, CoursesUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CoursesUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type UsersUpsertWithoutEnrollmentsInput = {
    update: XOR<UsersUpdateWithoutEnrollmentsInput, UsersUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<UsersCreateWithoutEnrollmentsInput, UsersUncheckedCreateWithoutEnrollmentsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutEnrollmentsInput, UsersUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UsersUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type CourseContentCreateWithoutLessonProgressInput = {
    id?: bigint | number
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsCreateNestedManyWithoutCourseContentInput
    Courses: CoursesCreateNestedOneWithoutCourseContentInput
    CourseContent?: CourseContentCreateNestedOneWithoutOther_CourseContentInput
    other_CourseContent?: CourseContentCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentUncheckedCreateWithoutLessonProgressInput = {
    id?: bigint | number
    course_id: bigint | number
    parent_id?: bigint | number | null
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
    Assessments?: AssessmentsUncheckedCreateNestedManyWithoutCourseContentInput
    other_CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCourseContentInput
  }

  export type CourseContentCreateOrConnectWithoutLessonProgressInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutLessonProgressInput, CourseContentUncheckedCreateWithoutLessonProgressInput>
  }

  export type UsersCreateWithoutLessonProgressInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutLessonProgressInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutLessonProgressInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutLessonProgressInput, UsersUncheckedCreateWithoutLessonProgressInput>
  }

  export type CourseContentUpsertWithoutLessonProgressInput = {
    update: XOR<CourseContentUpdateWithoutLessonProgressInput, CourseContentUncheckedUpdateWithoutLessonProgressInput>
    create: XOR<CourseContentCreateWithoutLessonProgressInput, CourseContentUncheckedCreateWithoutLessonProgressInput>
    where?: CourseContentWhereInput
  }

  export type CourseContentUpdateToOneWithWhereWithoutLessonProgressInput = {
    where?: CourseContentWhereInput
    data: XOR<CourseContentUpdateWithoutLessonProgressInput, CourseContentUncheckedUpdateWithoutLessonProgressInput>
  }

  export type CourseContentUpdateWithoutLessonProgressInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUpdateManyWithoutCourseContentNestedInput
    Courses?: CoursesUpdateOneRequiredWithoutCourseContentNestedInput
    CourseContent?: CourseContentUpdateOneWithoutOther_CourseContentNestedInput
    other_CourseContent?: CourseContentUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutLessonProgressInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUncheckedUpdateManyWithoutCourseContentNestedInput
    other_CourseContent?: CourseContentUncheckedUpdateManyWithoutCourseContentNestedInput
  }

  export type UsersUpsertWithoutLessonProgressInput = {
    update: XOR<UsersUpdateWithoutLessonProgressInput, UsersUncheckedUpdateWithoutLessonProgressInput>
    create: XOR<UsersCreateWithoutLessonProgressInput, UsersUncheckedCreateWithoutLessonProgressInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutLessonProgressInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutLessonProgressInput, UsersUncheckedUpdateWithoutLessonProgressInput>
  }

  export type UsersUpdateWithoutLessonProgressInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutLessonProgressInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutMessages_Messages_receiver_idToUsersInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMessages_Messages_receiver_idToUsersInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMessages_Messages_receiver_idToUsersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMessages_Messages_receiver_idToUsersInput, UsersUncheckedCreateWithoutMessages_Messages_receiver_idToUsersInput>
  }

  export type UsersCreateWithoutMessages_Messages_sender_idToUsersInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMessages_Messages_sender_idToUsersInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMessages_Messages_sender_idToUsersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMessages_Messages_sender_idToUsersInput, UsersUncheckedCreateWithoutMessages_Messages_sender_idToUsersInput>
  }

  export type UsersUpsertWithoutMessages_Messages_receiver_idToUsersInput = {
    update: XOR<UsersUpdateWithoutMessages_Messages_receiver_idToUsersInput, UsersUncheckedUpdateWithoutMessages_Messages_receiver_idToUsersInput>
    create: XOR<UsersCreateWithoutMessages_Messages_receiver_idToUsersInput, UsersUncheckedCreateWithoutMessages_Messages_receiver_idToUsersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMessages_Messages_receiver_idToUsersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMessages_Messages_receiver_idToUsersInput, UsersUncheckedUpdateWithoutMessages_Messages_receiver_idToUsersInput>
  }

  export type UsersUpdateWithoutMessages_Messages_receiver_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMessages_Messages_receiver_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUpsertWithoutMessages_Messages_sender_idToUsersInput = {
    update: XOR<UsersUpdateWithoutMessages_Messages_sender_idToUsersInput, UsersUncheckedUpdateWithoutMessages_Messages_sender_idToUsersInput>
    create: XOR<UsersCreateWithoutMessages_Messages_sender_idToUsersInput, UsersUncheckedCreateWithoutMessages_Messages_sender_idToUsersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMessages_Messages_sender_idToUsersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMessages_Messages_sender_idToUsersInput, UsersUncheckedUpdateWithoutMessages_Messages_sender_idToUsersInput>
  }

  export type UsersUpdateWithoutMessages_Messages_sender_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMessages_Messages_sender_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutMultiFactorAuthInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMultiFactorAuthInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMultiFactorAuthInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMultiFactorAuthInput, UsersUncheckedCreateWithoutMultiFactorAuthInput>
  }

  export type UsersUpsertWithoutMultiFactorAuthInput = {
    update: XOR<UsersUpdateWithoutMultiFactorAuthInput, UsersUncheckedUpdateWithoutMultiFactorAuthInput>
    create: XOR<UsersCreateWithoutMultiFactorAuthInput, UsersUncheckedCreateWithoutMultiFactorAuthInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMultiFactorAuthInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMultiFactorAuthInput, UsersUncheckedUpdateWithoutMultiFactorAuthInput>
  }

  export type UsersUpdateWithoutMultiFactorAuthInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMultiFactorAuthInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutNotificationsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutNotificationsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutNotificationsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
  }

  export type UsersUpsertWithoutNotificationsInput = {
    update: XOR<UsersUpdateWithoutNotificationsInput, UsersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutNotificationsInput, UsersUncheckedUpdateWithoutNotificationsInput>
  }

  export type UsersUpdateWithoutNotificationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutNotificationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type CoursesCreateWithoutPaymentsInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutPaymentsInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutPaymentsInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutPaymentsInput, CoursesUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionPlansCreateWithoutPaymentsInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    description?: string | null
    Subscriptions?: SubscriptionsCreateNestedManyWithoutSubscriptionPlansInput
  }

  export type SubscriptionPlansUncheckedCreateWithoutPaymentsInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    description?: string | null
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutSubscriptionPlansInput
  }

  export type SubscriptionPlansCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionPlansWhereUniqueInput
    create: XOR<SubscriptionPlansCreateWithoutPaymentsInput, SubscriptionPlansUncheckedCreateWithoutPaymentsInput>
  }

  export type UsersCreateWithoutPaymentsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutPaymentsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutPaymentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPaymentsInput, UsersUncheckedCreateWithoutPaymentsInput>
  }

  export type CoursesUpsertWithoutPaymentsInput = {
    update: XOR<CoursesUpdateWithoutPaymentsInput, CoursesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CoursesCreateWithoutPaymentsInput, CoursesUncheckedCreateWithoutPaymentsInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutPaymentsInput, CoursesUncheckedUpdateWithoutPaymentsInput>
  }

  export type CoursesUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type SubscriptionPlansUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionPlansUpdateWithoutPaymentsInput, SubscriptionPlansUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionPlansCreateWithoutPaymentsInput, SubscriptionPlansUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionPlansWhereInput
  }

  export type SubscriptionPlansUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionPlansWhereInput
    data: XOR<SubscriptionPlansUpdateWithoutPaymentsInput, SubscriptionPlansUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionPlansUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Subscriptions?: SubscriptionsUpdateManyWithoutSubscriptionPlansNestedInput
  }

  export type SubscriptionPlansUncheckedUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutSubscriptionPlansNestedInput
  }

  export type UsersUpsertWithoutPaymentsInput = {
    update: XOR<UsersUpdateWithoutPaymentsInput, UsersUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UsersCreateWithoutPaymentsInput, UsersUncheckedCreateWithoutPaymentsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPaymentsInput, UsersUncheckedUpdateWithoutPaymentsInput>
  }

  export type UsersUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type AssessmentsCreateWithoutQuizAttemptsInput = {
    id?: bigint | number
    title?: string | null
    instructions?: string | null
    AssessmentQuestions?: AssessmentQuestionsCreateNestedManyWithoutAssessmentsInput
    CourseContent: CourseContentCreateNestedOneWithoutAssessmentsInput
  }

  export type AssessmentsUncheckedCreateWithoutQuizAttemptsInput = {
    id?: bigint | number
    content_id: bigint | number
    title?: string | null
    instructions?: string | null
    AssessmentQuestions?: AssessmentQuestionsUncheckedCreateNestedManyWithoutAssessmentsInput
  }

  export type AssessmentsCreateOrConnectWithoutQuizAttemptsInput = {
    where: AssessmentsWhereUniqueInput
    create: XOR<AssessmentsCreateWithoutQuizAttemptsInput, AssessmentsUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type UsersCreateWithoutQuizAttemptsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutQuizAttemptsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutQuizAttemptsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutQuizAttemptsInput, UsersUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type UserAnswersCreateWithoutQuizAttemptsInput = {
    id?: bigint | number
    answer_text?: string | null
    AssessmentOptions?: AssessmentOptionsCreateNestedOneWithoutUserAnswersInput
    AssessmentQuestions: AssessmentQuestionsCreateNestedOneWithoutUserAnswersInput
  }

  export type UserAnswersUncheckedCreateWithoutQuizAttemptsInput = {
    id?: bigint | number
    question_id: bigint | number
    selected_option_id?: bigint | number | null
    answer_text?: string | null
  }

  export type UserAnswersCreateOrConnectWithoutQuizAttemptsInput = {
    where: UserAnswersWhereUniqueInput
    create: XOR<UserAnswersCreateWithoutQuizAttemptsInput, UserAnswersUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type UserAnswersCreateManyQuizAttemptsInputEnvelope = {
    data: UserAnswersCreateManyQuizAttemptsInput | UserAnswersCreateManyQuizAttemptsInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentsUpsertWithoutQuizAttemptsInput = {
    update: XOR<AssessmentsUpdateWithoutQuizAttemptsInput, AssessmentsUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<AssessmentsCreateWithoutQuizAttemptsInput, AssessmentsUncheckedCreateWithoutQuizAttemptsInput>
    where?: AssessmentsWhereInput
  }

  export type AssessmentsUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: AssessmentsWhereInput
    data: XOR<AssessmentsUpdateWithoutQuizAttemptsInput, AssessmentsUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type AssessmentsUpdateWithoutQuizAttemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    AssessmentQuestions?: AssessmentQuestionsUpdateManyWithoutAssessmentsNestedInput
    CourseContent?: CourseContentUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type AssessmentsUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    AssessmentQuestions?: AssessmentQuestionsUncheckedUpdateManyWithoutAssessmentsNestedInput
  }

  export type UsersUpsertWithoutQuizAttemptsInput = {
    update: XOR<UsersUpdateWithoutQuizAttemptsInput, UsersUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<UsersCreateWithoutQuizAttemptsInput, UsersUncheckedCreateWithoutQuizAttemptsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutQuizAttemptsInput, UsersUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UsersUpdateWithoutQuizAttemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserAnswersUpsertWithWhereUniqueWithoutQuizAttemptsInput = {
    where: UserAnswersWhereUniqueInput
    update: XOR<UserAnswersUpdateWithoutQuizAttemptsInput, UserAnswersUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<UserAnswersCreateWithoutQuizAttemptsInput, UserAnswersUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type UserAnswersUpdateWithWhereUniqueWithoutQuizAttemptsInput = {
    where: UserAnswersWhereUniqueInput
    data: XOR<UserAnswersUpdateWithoutQuizAttemptsInput, UserAnswersUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UserAnswersUpdateManyWithWhereWithoutQuizAttemptsInput = {
    where: UserAnswersScalarWhereInput
    data: XOR<UserAnswersUpdateManyMutationInput, UserAnswersUncheckedUpdateManyWithoutQuizAttemptsInput>
  }

  export type CoursesCreateWithoutReviewsInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutReviewsInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutReviewsInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutReviewsInput, CoursesUncheckedCreateWithoutReviewsInput>
  }

  export type UsersCreateWithoutReviews_Reviews_instructor_idToUsersInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutReviews_Reviews_instructor_idToUsersInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutReviews_Reviews_instructor_idToUsersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutReviews_Reviews_instructor_idToUsersInput, UsersUncheckedCreateWithoutReviews_Reviews_instructor_idToUsersInput>
  }

  export type UsersCreateWithoutReviews_Reviews_user_idToUsersInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutReviews_Reviews_user_idToUsersInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutReviews_Reviews_user_idToUsersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutReviews_Reviews_user_idToUsersInput, UsersUncheckedCreateWithoutReviews_Reviews_user_idToUsersInput>
  }

  export type CoursesUpsertWithoutReviewsInput = {
    update: XOR<CoursesUpdateWithoutReviewsInput, CoursesUncheckedUpdateWithoutReviewsInput>
    create: XOR<CoursesCreateWithoutReviewsInput, CoursesUncheckedCreateWithoutReviewsInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutReviewsInput, CoursesUncheckedUpdateWithoutReviewsInput>
  }

  export type CoursesUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type UsersUpsertWithoutReviews_Reviews_instructor_idToUsersInput = {
    update: XOR<UsersUpdateWithoutReviews_Reviews_instructor_idToUsersInput, UsersUncheckedUpdateWithoutReviews_Reviews_instructor_idToUsersInput>
    create: XOR<UsersCreateWithoutReviews_Reviews_instructor_idToUsersInput, UsersUncheckedCreateWithoutReviews_Reviews_instructor_idToUsersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutReviews_Reviews_instructor_idToUsersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutReviews_Reviews_instructor_idToUsersInput, UsersUncheckedUpdateWithoutReviews_Reviews_instructor_idToUsersInput>
  }

  export type UsersUpdateWithoutReviews_Reviews_instructor_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutReviews_Reviews_instructor_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUpsertWithoutReviews_Reviews_user_idToUsersInput = {
    update: XOR<UsersUpdateWithoutReviews_Reviews_user_idToUsersInput, UsersUncheckedUpdateWithoutReviews_Reviews_user_idToUsersInput>
    create: XOR<UsersCreateWithoutReviews_Reviews_user_idToUsersInput, UsersUncheckedCreateWithoutReviews_Reviews_user_idToUsersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutReviews_Reviews_user_idToUsersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutReviews_Reviews_user_idToUsersInput, UsersUncheckedUpdateWithoutReviews_Reviews_user_idToUsersInput>
  }

  export type UsersUpdateWithoutReviews_Reviews_user_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutReviews_Reviews_user_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type CoursesCreateWithoutShoppingCartInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutShoppingCartInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutShoppingCartInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutShoppingCartInput, CoursesUncheckedCreateWithoutShoppingCartInput>
  }

  export type UsersCreateWithoutShoppingCartInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutShoppingCartInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutShoppingCartInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutShoppingCartInput, UsersUncheckedCreateWithoutShoppingCartInput>
  }

  export type CoursesUpsertWithoutShoppingCartInput = {
    update: XOR<CoursesUpdateWithoutShoppingCartInput, CoursesUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<CoursesCreateWithoutShoppingCartInput, CoursesUncheckedCreateWithoutShoppingCartInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutShoppingCartInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutShoppingCartInput, CoursesUncheckedUpdateWithoutShoppingCartInput>
  }

  export type CoursesUpdateWithoutShoppingCartInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutShoppingCartInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type UsersUpsertWithoutShoppingCartInput = {
    update: XOR<UsersUpdateWithoutShoppingCartInput, UsersUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<UsersCreateWithoutShoppingCartInput, UsersUncheckedCreateWithoutShoppingCartInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutShoppingCartInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutShoppingCartInput, UsersUncheckedUpdateWithoutShoppingCartInput>
  }

  export type UsersUpdateWithoutShoppingCartInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutShoppingCartInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PaymentsCreateWithoutSubscriptionPlansInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Courses?: CoursesCreateNestedOneWithoutPaymentsInput
    Users: UsersCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutSubscriptionPlansInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type PaymentsCreateOrConnectWithoutSubscriptionPlansInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutSubscriptionPlansInput, PaymentsUncheckedCreateWithoutSubscriptionPlansInput>
  }

  export type PaymentsCreateManySubscriptionPlansInputEnvelope = {
    data: PaymentsCreateManySubscriptionPlansInput | PaymentsCreateManySubscriptionPlansInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionsCreateWithoutSubscriptionPlansInput = {
    id?: bigint | number
    status: $Enums.Subscriptions_status
    start_date: Date | string
    end_date: Date | string
    Users: UsersCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput = {
    id?: bigint | number
    user_id: bigint | number
    status: $Enums.Subscriptions_status
    start_date: Date | string
    end_date: Date | string
  }

  export type SubscriptionsCreateOrConnectWithoutSubscriptionPlansInput = {
    where: SubscriptionsWhereUniqueInput
    create: XOR<SubscriptionsCreateWithoutSubscriptionPlansInput, SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput>
  }

  export type SubscriptionsCreateManySubscriptionPlansInputEnvelope = {
    data: SubscriptionsCreateManySubscriptionPlansInput | SubscriptionsCreateManySubscriptionPlansInput[]
    skipDuplicates?: boolean
  }

  export type PaymentsUpsertWithWhereUniqueWithoutSubscriptionPlansInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutSubscriptionPlansInput, PaymentsUncheckedUpdateWithoutSubscriptionPlansInput>
    create: XOR<PaymentsCreateWithoutSubscriptionPlansInput, PaymentsUncheckedCreateWithoutSubscriptionPlansInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutSubscriptionPlansInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutSubscriptionPlansInput, PaymentsUncheckedUpdateWithoutSubscriptionPlansInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutSubscriptionPlansInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutSubscriptionPlansInput>
  }

  export type SubscriptionsUpsertWithWhereUniqueWithoutSubscriptionPlansInput = {
    where: SubscriptionsWhereUniqueInput
    update: XOR<SubscriptionsUpdateWithoutSubscriptionPlansInput, SubscriptionsUncheckedUpdateWithoutSubscriptionPlansInput>
    create: XOR<SubscriptionsCreateWithoutSubscriptionPlansInput, SubscriptionsUncheckedCreateWithoutSubscriptionPlansInput>
  }

  export type SubscriptionsUpdateWithWhereUniqueWithoutSubscriptionPlansInput = {
    where: SubscriptionsWhereUniqueInput
    data: XOR<SubscriptionsUpdateWithoutSubscriptionPlansInput, SubscriptionsUncheckedUpdateWithoutSubscriptionPlansInput>
  }

  export type SubscriptionsUpdateManyWithWhereWithoutSubscriptionPlansInput = {
    where: SubscriptionsScalarWhereInput
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyWithoutSubscriptionPlansInput>
  }

  export type SubscriptionsScalarWhereInput = {
    AND?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
    OR?: SubscriptionsScalarWhereInput[]
    NOT?: SubscriptionsScalarWhereInput | SubscriptionsScalarWhereInput[]
    id?: BigIntFilter<"Subscriptions"> | bigint | number
    user_id?: BigIntFilter<"Subscriptions"> | bigint | number
    plan_id?: BigIntFilter<"Subscriptions"> | bigint | number
    status?: EnumSubscriptions_statusFilter<"Subscriptions"> | $Enums.Subscriptions_status
    start_date?: DateTimeFilter<"Subscriptions"> | Date | string
    end_date?: DateTimeFilter<"Subscriptions"> | Date | string
  }

  export type SubscriptionPlansCreateWithoutSubscriptionsInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    description?: string | null
    Payments?: PaymentsCreateNestedManyWithoutSubscriptionPlansInput
  }

  export type SubscriptionPlansUncheckedCreateWithoutSubscriptionsInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    description?: string | null
    Payments?: PaymentsUncheckedCreateNestedManyWithoutSubscriptionPlansInput
  }

  export type SubscriptionPlansCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlansWhereUniqueInput
    create: XOR<SubscriptionPlansCreateWithoutSubscriptionsInput, SubscriptionPlansUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UsersCreateWithoutSubscriptionsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutSubscriptionsInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutSubscriptionsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutSubscriptionsInput, UsersUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlansUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlansUpdateWithoutSubscriptionsInput, SubscriptionPlansUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlansCreateWithoutSubscriptionsInput, SubscriptionPlansUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlansWhereInput
  }

  export type SubscriptionPlansUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlansWhereInput
    data: XOR<SubscriptionPlansUpdateWithoutSubscriptionsInput, SubscriptionPlansUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlansUpdateWithoutSubscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Payments?: PaymentsUpdateManyWithoutSubscriptionPlansNestedInput
  }

  export type SubscriptionPlansUncheckedUpdateWithoutSubscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Payments?: PaymentsUncheckedUpdateManyWithoutSubscriptionPlansNestedInput
  }

  export type UsersUpsertWithoutSubscriptionsInput = {
    update: XOR<UsersUpdateWithoutSubscriptionsInput, UsersUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UsersCreateWithoutSubscriptionsInput, UsersUncheckedCreateWithoutSubscriptionsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutSubscriptionsInput, UsersUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UsersUpdateWithoutSubscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutSubscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type QuizAttemptsCreateWithoutUserAnswersInput = {
    id?: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    Assessments: AssessmentsCreateNestedOneWithoutQuizAttemptsInput
    Users: UsersCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptsUncheckedCreateWithoutUserAnswersInput = {
    id?: bigint | number
    user_id: bigint | number
    assessment_id: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type QuizAttemptsCreateOrConnectWithoutUserAnswersInput = {
    where: QuizAttemptsWhereUniqueInput
    create: XOR<QuizAttemptsCreateWithoutUserAnswersInput, QuizAttemptsUncheckedCreateWithoutUserAnswersInput>
  }

  export type AssessmentOptionsCreateWithoutUserAnswersInput = {
    id?: bigint | number
    option_text?: string | null
    is_correct?: boolean | null
    AssessmentQuestions: AssessmentQuestionsCreateNestedOneWithoutAssessmentOptionsInput
  }

  export type AssessmentOptionsUncheckedCreateWithoutUserAnswersInput = {
    id?: bigint | number
    question_id: bigint | number
    option_text?: string | null
    is_correct?: boolean | null
  }

  export type AssessmentOptionsCreateOrConnectWithoutUserAnswersInput = {
    where: AssessmentOptionsWhereUniqueInput
    create: XOR<AssessmentOptionsCreateWithoutUserAnswersInput, AssessmentOptionsUncheckedCreateWithoutUserAnswersInput>
  }

  export type AssessmentQuestionsCreateWithoutUserAnswersInput = {
    id?: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsCreateNestedManyWithoutAssessmentQuestionsInput
    Assessments: AssessmentsCreateNestedOneWithoutAssessmentQuestionsInput
  }

  export type AssessmentQuestionsUncheckedCreateWithoutUserAnswersInput = {
    id?: bigint | number
    assessment_id: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsUncheckedCreateNestedManyWithoutAssessmentQuestionsInput
  }

  export type AssessmentQuestionsCreateOrConnectWithoutUserAnswersInput = {
    where: AssessmentQuestionsWhereUniqueInput
    create: XOR<AssessmentQuestionsCreateWithoutUserAnswersInput, AssessmentQuestionsUncheckedCreateWithoutUserAnswersInput>
  }

  export type QuizAttemptsUpsertWithoutUserAnswersInput = {
    update: XOR<QuizAttemptsUpdateWithoutUserAnswersInput, QuizAttemptsUncheckedUpdateWithoutUserAnswersInput>
    create: XOR<QuizAttemptsCreateWithoutUserAnswersInput, QuizAttemptsUncheckedCreateWithoutUserAnswersInput>
    where?: QuizAttemptsWhereInput
  }

  export type QuizAttemptsUpdateToOneWithWhereWithoutUserAnswersInput = {
    where?: QuizAttemptsWhereInput
    data: XOR<QuizAttemptsUpdateWithoutUserAnswersInput, QuizAttemptsUncheckedUpdateWithoutUserAnswersInput>
  }

  export type QuizAttemptsUpdateWithoutUserAnswersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Assessments?: AssessmentsUpdateOneRequiredWithoutQuizAttemptsNestedInput
    Users?: UsersUpdateOneRequiredWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptsUncheckedUpdateWithoutUserAnswersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assessment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssessmentOptionsUpsertWithoutUserAnswersInput = {
    update: XOR<AssessmentOptionsUpdateWithoutUserAnswersInput, AssessmentOptionsUncheckedUpdateWithoutUserAnswersInput>
    create: XOR<AssessmentOptionsCreateWithoutUserAnswersInput, AssessmentOptionsUncheckedCreateWithoutUserAnswersInput>
    where?: AssessmentOptionsWhereInput
  }

  export type AssessmentOptionsUpdateToOneWithWhereWithoutUserAnswersInput = {
    where?: AssessmentOptionsWhereInput
    data: XOR<AssessmentOptionsUpdateWithoutUserAnswersInput, AssessmentOptionsUncheckedUpdateWithoutUserAnswersInput>
  }

  export type AssessmentOptionsUpdateWithoutUserAnswersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    AssessmentQuestions?: AssessmentQuestionsUpdateOneRequiredWithoutAssessmentOptionsNestedInput
  }

  export type AssessmentOptionsUncheckedUpdateWithoutUserAnswersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AssessmentQuestionsUpsertWithoutUserAnswersInput = {
    update: XOR<AssessmentQuestionsUpdateWithoutUserAnswersInput, AssessmentQuestionsUncheckedUpdateWithoutUserAnswersInput>
    create: XOR<AssessmentQuestionsCreateWithoutUserAnswersInput, AssessmentQuestionsUncheckedCreateWithoutUserAnswersInput>
    where?: AssessmentQuestionsWhereInput
  }

  export type AssessmentQuestionsUpdateToOneWithWhereWithoutUserAnswersInput = {
    where?: AssessmentQuestionsWhereInput
    data: XOR<AssessmentQuestionsUpdateWithoutUserAnswersInput, AssessmentQuestionsUncheckedUpdateWithoutUserAnswersInput>
  }

  export type AssessmentQuestionsUpdateWithoutUserAnswersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsUpdateManyWithoutAssessmentQuestionsNestedInput
    Assessments?: AssessmentsUpdateOneRequiredWithoutAssessmentQuestionsNestedInput
  }

  export type AssessmentQuestionsUncheckedUpdateWithoutUserAnswersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assessment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsUncheckedUpdateManyWithoutAssessmentQuestionsNestedInput
  }

  export type CoursesCreateWithoutUserSavedCoursesInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Users: UsersCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutUserSavedCoursesInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutUserSavedCoursesInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutUserSavedCoursesInput, CoursesUncheckedCreateWithoutUserSavedCoursesInput>
  }

  export type UsersCreateWithoutUserSavedCoursesInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutUsersInput
    Courses?: CoursesCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsCreateNestedManyWithoutUsersInput
    Payments?: PaymentsCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUserSavedCoursesInput = {
    id?: bigint | number
    email: string
    password_hash: string
    role?: $Enums.Users_role
    first_name?: string | null
    last_name?: string | null
    headline?: string | null
    biography?: string | null
    photo_url?: string | null
    field_of_learning?: string | null
    occupation?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: string | null
    instructor_application_status?: $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: Date | string | null
    instructor_reviewed_at?: Date | string | null
    instructor_admin_comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutUsersInput
    Courses?: CoursesUncheckedCreateNestedManyWithoutUsersInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutUsersInput
    LessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUsersInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_receiver_idToUsersInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedCreateNestedManyWithoutUsers_Messages_sender_idToUsersInput
    MultiFactorAuth?: MultiFactorAuthUncheckedCreateNestedManyWithoutUsersInput
    Notifications?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUsersInput
    QuizAttempts?: QuizAttemptsUncheckedCreateNestedManyWithoutUsersInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_instructor_idToUsersInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedCreateNestedManyWithoutUsers_Reviews_user_idToUsersInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUsersInput
    Subscriptions?: SubscriptionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUserSavedCoursesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUserSavedCoursesInput, UsersUncheckedCreateWithoutUserSavedCoursesInput>
  }

  export type CoursesUpsertWithoutUserSavedCoursesInput = {
    update: XOR<CoursesUpdateWithoutUserSavedCoursesInput, CoursesUncheckedUpdateWithoutUserSavedCoursesInput>
    create: XOR<CoursesCreateWithoutUserSavedCoursesInput, CoursesUncheckedCreateWithoutUserSavedCoursesInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutUserSavedCoursesInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutUserSavedCoursesInput, CoursesUncheckedUpdateWithoutUserSavedCoursesInput>
  }

  export type CoursesUpdateWithoutUserSavedCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutUserSavedCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type UsersUpsertWithoutUserSavedCoursesInput = {
    update: XOR<UsersUpdateWithoutUserSavedCoursesInput, UsersUncheckedUpdateWithoutUserSavedCoursesInput>
    create: XOR<UsersCreateWithoutUserSavedCoursesInput, UsersUncheckedCreateWithoutUserSavedCoursesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUserSavedCoursesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUserSavedCoursesInput, UsersUncheckedUpdateWithoutUserSavedCoursesInput>
  }

  export type UsersUpdateWithoutUserSavedCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUserSavedCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUsers_roleFieldUpdateOperationsInput | $Enums.Users_role
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_learning?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    interests?: NullableJsonNullValueInput | InputJsonValue
    resume_url?: NullableStringFieldUpdateOperationsInput | string | null
    instructor_application_status?: EnumUsers_instructor_application_statusFieldUpdateOperationsInput | $Enums.Users_instructor_application_status
    instructor_application_submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_admin_comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutUsersNestedInput
    Courses?: CoursesUncheckedUpdateManyWithoutUsersNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutUsersNestedInput
    Messages_Messages_receiver_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersNestedInput
    Messages_Messages_sender_idToUsers?: MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersNestedInput
    MultiFactorAuth?: MultiFactorAuthUncheckedUpdateManyWithoutUsersNestedInput
    Notifications?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUsersNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews_Reviews_instructor_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersNestedInput
    Reviews_Reviews_user_idToUsers?: ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUsersNestedInput
    Subscriptions?: SubscriptionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type CertificatesCreateWithoutUsersInput = {
    id?: bigint | number
    certificate_url?: string | null
    issued_at?: Date | string | null
    Courses: CoursesCreateNestedOneWithoutCertificatesInput
  }

  export type CertificatesUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    course_id: bigint | number
    certificate_url?: string | null
    issued_at?: Date | string | null
  }

  export type CertificatesCreateOrConnectWithoutUsersInput = {
    where: CertificatesWhereUniqueInput
    create: XOR<CertificatesCreateWithoutUsersInput, CertificatesUncheckedCreateWithoutUsersInput>
  }

  export type CertificatesCreateManyUsersInputEnvelope = {
    data: CertificatesCreateManyUsersInput | CertificatesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type CoursesCreateWithoutUsersInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsCreateNestedManyWithoutCoursesInput
    Categories: CategoriesCreateNestedOneWithoutCoursesInput
    Enrollments?: EnrollmentsCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Certificates?: CertificatesUncheckedCreateNestedManyWithoutCoursesInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutCoursesInput
    CourseTags?: CourseTagsUncheckedCreateNestedManyWithoutCoursesInput
    Enrollments?: EnrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutCoursesInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutCoursesInput
    ShoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutCoursesInput
    UserSavedCourses?: UserSavedCoursesUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutUsersInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutUsersInput, CoursesUncheckedCreateWithoutUsersInput>
  }

  export type CoursesCreateManyUsersInputEnvelope = {
    data: CoursesCreateManyUsersInput | CoursesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentsCreateWithoutUsersInput = {
    id?: bigint | number
    enrolled_at?: Date | string | null
    Courses: CoursesCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    course_id: bigint | number
    enrolled_at?: Date | string | null
  }

  export type EnrollmentsCreateOrConnectWithoutUsersInput = {
    where: EnrollmentsWhereUniqueInput
    create: XOR<EnrollmentsCreateWithoutUsersInput, EnrollmentsUncheckedCreateWithoutUsersInput>
  }

  export type EnrollmentsCreateManyUsersInputEnvelope = {
    data: EnrollmentsCreateManyUsersInput | EnrollmentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressCreateWithoutUsersInput = {
    id?: bigint | number
    is_completed?: boolean | null
    completed_at?: Date | string | null
    CourseContent: CourseContentCreateNestedOneWithoutLessonProgressInput
  }

  export type LessonProgressUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    content_id: bigint | number
    is_completed?: boolean | null
    completed_at?: Date | string | null
  }

  export type LessonProgressCreateOrConnectWithoutUsersInput = {
    where: LessonProgressWhereUniqueInput
    create: XOR<LessonProgressCreateWithoutUsersInput, LessonProgressUncheckedCreateWithoutUsersInput>
  }

  export type LessonProgressCreateManyUsersInputEnvelope = {
    data: LessonProgressCreateManyUsersInput | LessonProgressCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput = {
    id?: bigint | number
    content: string
    created_at?: Date | string | null
    Users_Messages_sender_idToUsers: UsersCreateNestedOneWithoutMessages_Messages_sender_idToUsersInput
  }

  export type MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput = {
    id?: bigint | number
    sender_id: bigint | number
    content: string
    created_at?: Date | string | null
  }

  export type MessagesCreateOrConnectWithoutUsers_Messages_receiver_idToUsersInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput>
  }

  export type MessagesCreateManyUsers_Messages_receiver_idToUsersInputEnvelope = {
    data: MessagesCreateManyUsers_Messages_receiver_idToUsersInput | MessagesCreateManyUsers_Messages_receiver_idToUsersInput[]
    skipDuplicates?: boolean
  }

  export type MessagesCreateWithoutUsers_Messages_sender_idToUsersInput = {
    id?: bigint | number
    content: string
    created_at?: Date | string | null
    Users_Messages_receiver_idToUsers: UsersCreateNestedOneWithoutMessages_Messages_receiver_idToUsersInput
  }

  export type MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput = {
    id?: bigint | number
    receiver_id: bigint | number
    content: string
    created_at?: Date | string | null
  }

  export type MessagesCreateOrConnectWithoutUsers_Messages_sender_idToUsersInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutUsers_Messages_sender_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput>
  }

  export type MessagesCreateManyUsers_Messages_sender_idToUsersInputEnvelope = {
    data: MessagesCreateManyUsers_Messages_sender_idToUsersInput | MessagesCreateManyUsers_Messages_sender_idToUsersInput[]
    skipDuplicates?: boolean
  }

  export type MultiFactorAuthCreateWithoutUsersInput = {
    id?: bigint | number
    mfa_type: $Enums.MultiFactorAuth_mfa_type
    secret_key?: string | null
    is_enabled?: boolean | null
    created_at?: Date | string | null
  }

  export type MultiFactorAuthUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    mfa_type: $Enums.MultiFactorAuth_mfa_type
    secret_key?: string | null
    is_enabled?: boolean | null
    created_at?: Date | string | null
  }

  export type MultiFactorAuthCreateOrConnectWithoutUsersInput = {
    where: MultiFactorAuthWhereUniqueInput
    create: XOR<MultiFactorAuthCreateWithoutUsersInput, MultiFactorAuthUncheckedCreateWithoutUsersInput>
  }

  export type MultiFactorAuthCreateManyUsersInputEnvelope = {
    data: MultiFactorAuthCreateManyUsersInput | MultiFactorAuthCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutUsersInput = {
    id?: bigint | number
    message: string
    type?: $Enums.Notifications_type | null
    is_read?: boolean | null
    created_at?: Date | string | null
  }

  export type NotificationsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    message: string
    type?: $Enums.Notifications_type | null
    is_read?: boolean | null
    created_at?: Date | string | null
  }

  export type NotificationsCreateOrConnectWithoutUsersInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput>
  }

  export type NotificationsCreateManyUsersInputEnvelope = {
    data: NotificationsCreateManyUsersInput | NotificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type PaymentsCreateWithoutUsersInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    Courses?: CoursesCreateNestedOneWithoutPaymentsInput
    SubscriptionPlans?: SubscriptionPlansCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    subscription_plan_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type PaymentsCreateOrConnectWithoutUsersInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutUsersInput, PaymentsUncheckedCreateWithoutUsersInput>
  }

  export type PaymentsCreateManyUsersInputEnvelope = {
    data: PaymentsCreateManyUsersInput | PaymentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptsCreateWithoutUsersInput = {
    id?: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    Assessments: AssessmentsCreateNestedOneWithoutQuizAttemptsInput
    UserAnswers?: UserAnswersCreateNestedManyWithoutQuizAttemptsInput
  }

  export type QuizAttemptsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    assessment_id: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    UserAnswers?: UserAnswersUncheckedCreateNestedManyWithoutQuizAttemptsInput
  }

  export type QuizAttemptsCreateOrConnectWithoutUsersInput = {
    where: QuizAttemptsWhereUniqueInput
    create: XOR<QuizAttemptsCreateWithoutUsersInput, QuizAttemptsUncheckedCreateWithoutUsersInput>
  }

  export type QuizAttemptsCreateManyUsersInputEnvelope = {
    data: QuizAttemptsCreateManyUsersInput | QuizAttemptsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput = {
    id?: bigint | number
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
    Courses?: CoursesCreateNestedOneWithoutReviewsInput
    Users_Reviews_user_idToUsers: UsersCreateNestedOneWithoutReviews_Reviews_user_idToUsersInput
  }

  export type ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id?: bigint | number | null
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
  }

  export type ReviewsCreateOrConnectWithoutUsers_Reviews_instructor_idToUsersInput = {
    where: ReviewsWhereUniqueInput
    create: XOR<ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput>
  }

  export type ReviewsCreateManyUsers_Reviews_instructor_idToUsersInputEnvelope = {
    data: ReviewsCreateManyUsers_Reviews_instructor_idToUsersInput | ReviewsCreateManyUsers_Reviews_instructor_idToUsersInput[]
    skipDuplicates?: boolean
  }

  export type ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput = {
    id?: bigint | number
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
    Courses?: CoursesCreateNestedOneWithoutReviewsInput
    Users_Reviews_instructor_idToUsers?: UsersCreateNestedOneWithoutReviews_Reviews_instructor_idToUsersInput
  }

  export type ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    instructor_id?: bigint | number | null
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
  }

  export type ReviewsCreateOrConnectWithoutUsers_Reviews_user_idToUsersInput = {
    where: ReviewsWhereUniqueInput
    create: XOR<ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput>
  }

  export type ReviewsCreateManyUsers_Reviews_user_idToUsersInputEnvelope = {
    data: ReviewsCreateManyUsers_Reviews_user_idToUsersInput | ReviewsCreateManyUsers_Reviews_user_idToUsersInput[]
    skipDuplicates?: boolean
  }

  export type ShoppingCartCreateWithoutUsersInput = {
    id?: bigint | number
    added_at?: Date | string | null
    Courses: CoursesCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    course_id: bigint | number
    added_at?: Date | string | null
  }

  export type ShoppingCartCreateOrConnectWithoutUsersInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutUsersInput, ShoppingCartUncheckedCreateWithoutUsersInput>
  }

  export type ShoppingCartCreateManyUsersInputEnvelope = {
    data: ShoppingCartCreateManyUsersInput | ShoppingCartCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionsCreateWithoutUsersInput = {
    id?: bigint | number
    status: $Enums.Subscriptions_status
    start_date: Date | string
    end_date: Date | string
    SubscriptionPlans: SubscriptionPlansCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    plan_id: bigint | number
    status: $Enums.Subscriptions_status
    start_date: Date | string
    end_date: Date | string
  }

  export type SubscriptionsCreateOrConnectWithoutUsersInput = {
    where: SubscriptionsWhereUniqueInput
    create: XOR<SubscriptionsCreateWithoutUsersInput, SubscriptionsUncheckedCreateWithoutUsersInput>
  }

  export type SubscriptionsCreateManyUsersInputEnvelope = {
    data: SubscriptionsCreateManyUsersInput | SubscriptionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type UserSavedCoursesCreateWithoutUsersInput = {
    id?: bigint | number
    Courses: CoursesCreateNestedOneWithoutUserSavedCoursesInput
  }

  export type UserSavedCoursesUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    course_id: bigint | number
  }

  export type UserSavedCoursesCreateOrConnectWithoutUsersInput = {
    where: UserSavedCoursesWhereUniqueInput
    create: XOR<UserSavedCoursesCreateWithoutUsersInput, UserSavedCoursesUncheckedCreateWithoutUsersInput>
  }

  export type UserSavedCoursesCreateManyUsersInputEnvelope = {
    data: UserSavedCoursesCreateManyUsersInput | UserSavedCoursesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type CertificatesUpsertWithWhereUniqueWithoutUsersInput = {
    where: CertificatesWhereUniqueInput
    update: XOR<CertificatesUpdateWithoutUsersInput, CertificatesUncheckedUpdateWithoutUsersInput>
    create: XOR<CertificatesCreateWithoutUsersInput, CertificatesUncheckedCreateWithoutUsersInput>
  }

  export type CertificatesUpdateWithWhereUniqueWithoutUsersInput = {
    where: CertificatesWhereUniqueInput
    data: XOR<CertificatesUpdateWithoutUsersInput, CertificatesUncheckedUpdateWithoutUsersInput>
  }

  export type CertificatesUpdateManyWithWhereWithoutUsersInput = {
    where: CertificatesScalarWhereInput
    data: XOR<CertificatesUpdateManyMutationInput, CertificatesUncheckedUpdateManyWithoutUsersInput>
  }

  export type CoursesUpsertWithWhereUniqueWithoutUsersInput = {
    where: CoursesWhereUniqueInput
    update: XOR<CoursesUpdateWithoutUsersInput, CoursesUncheckedUpdateWithoutUsersInput>
    create: XOR<CoursesCreateWithoutUsersInput, CoursesUncheckedCreateWithoutUsersInput>
  }

  export type CoursesUpdateWithWhereUniqueWithoutUsersInput = {
    where: CoursesWhereUniqueInput
    data: XOR<CoursesUpdateWithoutUsersInput, CoursesUncheckedUpdateWithoutUsersInput>
  }

  export type CoursesUpdateManyWithWhereWithoutUsersInput = {
    where: CoursesScalarWhereInput
    data: XOR<CoursesUpdateManyMutationInput, CoursesUncheckedUpdateManyWithoutUsersInput>
  }

  export type EnrollmentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: EnrollmentsWhereUniqueInput
    update: XOR<EnrollmentsUpdateWithoutUsersInput, EnrollmentsUncheckedUpdateWithoutUsersInput>
    create: XOR<EnrollmentsCreateWithoutUsersInput, EnrollmentsUncheckedCreateWithoutUsersInput>
  }

  export type EnrollmentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: EnrollmentsWhereUniqueInput
    data: XOR<EnrollmentsUpdateWithoutUsersInput, EnrollmentsUncheckedUpdateWithoutUsersInput>
  }

  export type EnrollmentsUpdateManyWithWhereWithoutUsersInput = {
    where: EnrollmentsScalarWhereInput
    data: XOR<EnrollmentsUpdateManyMutationInput, EnrollmentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type LessonProgressUpsertWithWhereUniqueWithoutUsersInput = {
    where: LessonProgressWhereUniqueInput
    update: XOR<LessonProgressUpdateWithoutUsersInput, LessonProgressUncheckedUpdateWithoutUsersInput>
    create: XOR<LessonProgressCreateWithoutUsersInput, LessonProgressUncheckedCreateWithoutUsersInput>
  }

  export type LessonProgressUpdateWithWhereUniqueWithoutUsersInput = {
    where: LessonProgressWhereUniqueInput
    data: XOR<LessonProgressUpdateWithoutUsersInput, LessonProgressUncheckedUpdateWithoutUsersInput>
  }

  export type LessonProgressUpdateManyWithWhereWithoutUsersInput = {
    where: LessonProgressScalarWhereInput
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyWithoutUsersInput>
  }

  export type MessagesUpsertWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput = {
    where: MessagesWhereUniqueInput
    update: XOR<MessagesUpdateWithoutUsers_Messages_receiver_idToUsersInput, MessagesUncheckedUpdateWithoutUsers_Messages_receiver_idToUsersInput>
    create: XOR<MessagesCreateWithoutUsers_Messages_receiver_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_receiver_idToUsersInput>
  }

  export type MessagesUpdateWithWhereUniqueWithoutUsers_Messages_receiver_idToUsersInput = {
    where: MessagesWhereUniqueInput
    data: XOR<MessagesUpdateWithoutUsers_Messages_receiver_idToUsersInput, MessagesUncheckedUpdateWithoutUsers_Messages_receiver_idToUsersInput>
  }

  export type MessagesUpdateManyWithWhereWithoutUsers_Messages_receiver_idToUsersInput = {
    where: MessagesScalarWhereInput
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersInput>
  }

  export type MessagesScalarWhereInput = {
    AND?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    OR?: MessagesScalarWhereInput[]
    NOT?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    id?: BigIntFilter<"Messages"> | bigint | number
    sender_id?: BigIntFilter<"Messages"> | bigint | number
    receiver_id?: BigIntFilter<"Messages"> | bigint | number
    content?: StringFilter<"Messages"> | string
    created_at?: DateTimeNullableFilter<"Messages"> | Date | string | null
  }

  export type MessagesUpsertWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput = {
    where: MessagesWhereUniqueInput
    update: XOR<MessagesUpdateWithoutUsers_Messages_sender_idToUsersInput, MessagesUncheckedUpdateWithoutUsers_Messages_sender_idToUsersInput>
    create: XOR<MessagesCreateWithoutUsers_Messages_sender_idToUsersInput, MessagesUncheckedCreateWithoutUsers_Messages_sender_idToUsersInput>
  }

  export type MessagesUpdateWithWhereUniqueWithoutUsers_Messages_sender_idToUsersInput = {
    where: MessagesWhereUniqueInput
    data: XOR<MessagesUpdateWithoutUsers_Messages_sender_idToUsersInput, MessagesUncheckedUpdateWithoutUsers_Messages_sender_idToUsersInput>
  }

  export type MessagesUpdateManyWithWhereWithoutUsers_Messages_sender_idToUsersInput = {
    where: MessagesScalarWhereInput
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersInput>
  }

  export type MultiFactorAuthUpsertWithWhereUniqueWithoutUsersInput = {
    where: MultiFactorAuthWhereUniqueInput
    update: XOR<MultiFactorAuthUpdateWithoutUsersInput, MultiFactorAuthUncheckedUpdateWithoutUsersInput>
    create: XOR<MultiFactorAuthCreateWithoutUsersInput, MultiFactorAuthUncheckedCreateWithoutUsersInput>
  }

  export type MultiFactorAuthUpdateWithWhereUniqueWithoutUsersInput = {
    where: MultiFactorAuthWhereUniqueInput
    data: XOR<MultiFactorAuthUpdateWithoutUsersInput, MultiFactorAuthUncheckedUpdateWithoutUsersInput>
  }

  export type MultiFactorAuthUpdateManyWithWhereWithoutUsersInput = {
    where: MultiFactorAuthScalarWhereInput
    data: XOR<MultiFactorAuthUpdateManyMutationInput, MultiFactorAuthUncheckedUpdateManyWithoutUsersInput>
  }

  export type MultiFactorAuthScalarWhereInput = {
    AND?: MultiFactorAuthScalarWhereInput | MultiFactorAuthScalarWhereInput[]
    OR?: MultiFactorAuthScalarWhereInput[]
    NOT?: MultiFactorAuthScalarWhereInput | MultiFactorAuthScalarWhereInput[]
    id?: BigIntFilter<"MultiFactorAuth"> | bigint | number
    user_id?: BigIntFilter<"MultiFactorAuth"> | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFilter<"MultiFactorAuth"> | $Enums.MultiFactorAuth_mfa_type
    secret_key?: StringNullableFilter<"MultiFactorAuth"> | string | null
    is_enabled?: BoolNullableFilter<"MultiFactorAuth"> | boolean | null
    created_at?: DateTimeNullableFilter<"MultiFactorAuth"> | Date | string | null
  }

  export type NotificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutUsersInput, NotificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutUsersInput, NotificationsUncheckedUpdateWithoutUsersInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutUsersInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type NotificationsScalarWhereInput = {
    AND?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    OR?: NotificationsScalarWhereInput[]
    NOT?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    id?: BigIntFilter<"Notifications"> | bigint | number
    user_id?: BigIntFilter<"Notifications"> | bigint | number
    message?: StringFilter<"Notifications"> | string
    type?: EnumNotifications_typeNullableFilter<"Notifications"> | $Enums.Notifications_type | null
    is_read?: BoolNullableFilter<"Notifications"> | boolean | null
    created_at?: DateTimeNullableFilter<"Notifications"> | Date | string | null
  }

  export type PaymentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutUsersInput, PaymentsUncheckedUpdateWithoutUsersInput>
    create: XOR<PaymentsCreateWithoutUsersInput, PaymentsUncheckedCreateWithoutUsersInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutUsersInput, PaymentsUncheckedUpdateWithoutUsersInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutUsersInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type QuizAttemptsUpsertWithWhereUniqueWithoutUsersInput = {
    where: QuizAttemptsWhereUniqueInput
    update: XOR<QuizAttemptsUpdateWithoutUsersInput, QuizAttemptsUncheckedUpdateWithoutUsersInput>
    create: XOR<QuizAttemptsCreateWithoutUsersInput, QuizAttemptsUncheckedCreateWithoutUsersInput>
  }

  export type QuizAttemptsUpdateWithWhereUniqueWithoutUsersInput = {
    where: QuizAttemptsWhereUniqueInput
    data: XOR<QuizAttemptsUpdateWithoutUsersInput, QuizAttemptsUncheckedUpdateWithoutUsersInput>
  }

  export type QuizAttemptsUpdateManyWithWhereWithoutUsersInput = {
    where: QuizAttemptsScalarWhereInput
    data: XOR<QuizAttemptsUpdateManyMutationInput, QuizAttemptsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput = {
    where: ReviewsWhereUniqueInput
    update: XOR<ReviewsUpdateWithoutUsers_Reviews_instructor_idToUsersInput, ReviewsUncheckedUpdateWithoutUsers_Reviews_instructor_idToUsersInput>
    create: XOR<ReviewsCreateWithoutUsers_Reviews_instructor_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_instructor_idToUsersInput>
  }

  export type ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_instructor_idToUsersInput = {
    where: ReviewsWhereUniqueInput
    data: XOR<ReviewsUpdateWithoutUsers_Reviews_instructor_idToUsersInput, ReviewsUncheckedUpdateWithoutUsers_Reviews_instructor_idToUsersInput>
  }

  export type ReviewsUpdateManyWithWhereWithoutUsers_Reviews_instructor_idToUsersInput = {
    where: ReviewsScalarWhereInput
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersInput>
  }

  export type ReviewsUpsertWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput = {
    where: ReviewsWhereUniqueInput
    update: XOR<ReviewsUpdateWithoutUsers_Reviews_user_idToUsersInput, ReviewsUncheckedUpdateWithoutUsers_Reviews_user_idToUsersInput>
    create: XOR<ReviewsCreateWithoutUsers_Reviews_user_idToUsersInput, ReviewsUncheckedCreateWithoutUsers_Reviews_user_idToUsersInput>
  }

  export type ReviewsUpdateWithWhereUniqueWithoutUsers_Reviews_user_idToUsersInput = {
    where: ReviewsWhereUniqueInput
    data: XOR<ReviewsUpdateWithoutUsers_Reviews_user_idToUsersInput, ReviewsUncheckedUpdateWithoutUsers_Reviews_user_idToUsersInput>
  }

  export type ReviewsUpdateManyWithWhereWithoutUsers_Reviews_user_idToUsersInput = {
    where: ReviewsScalarWhereInput
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersInput>
  }

  export type ShoppingCartUpsertWithWhereUniqueWithoutUsersInput = {
    where: ShoppingCartWhereUniqueInput
    update: XOR<ShoppingCartUpdateWithoutUsersInput, ShoppingCartUncheckedUpdateWithoutUsersInput>
    create: XOR<ShoppingCartCreateWithoutUsersInput, ShoppingCartUncheckedCreateWithoutUsersInput>
  }

  export type ShoppingCartUpdateWithWhereUniqueWithoutUsersInput = {
    where: ShoppingCartWhereUniqueInput
    data: XOR<ShoppingCartUpdateWithoutUsersInput, ShoppingCartUncheckedUpdateWithoutUsersInput>
  }

  export type ShoppingCartUpdateManyWithWhereWithoutUsersInput = {
    where: ShoppingCartScalarWhereInput
    data: XOR<ShoppingCartUpdateManyMutationInput, ShoppingCartUncheckedUpdateManyWithoutUsersInput>
  }

  export type SubscriptionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: SubscriptionsWhereUniqueInput
    update: XOR<SubscriptionsUpdateWithoutUsersInput, SubscriptionsUncheckedUpdateWithoutUsersInput>
    create: XOR<SubscriptionsCreateWithoutUsersInput, SubscriptionsUncheckedCreateWithoutUsersInput>
  }

  export type SubscriptionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: SubscriptionsWhereUniqueInput
    data: XOR<SubscriptionsUpdateWithoutUsersInput, SubscriptionsUncheckedUpdateWithoutUsersInput>
  }

  export type SubscriptionsUpdateManyWithWhereWithoutUsersInput = {
    where: SubscriptionsScalarWhereInput
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserSavedCoursesUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserSavedCoursesWhereUniqueInput
    update: XOR<UserSavedCoursesUpdateWithoutUsersInput, UserSavedCoursesUncheckedUpdateWithoutUsersInput>
    create: XOR<UserSavedCoursesCreateWithoutUsersInput, UserSavedCoursesUncheckedCreateWithoutUsersInput>
  }

  export type UserSavedCoursesUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserSavedCoursesWhereUniqueInput
    data: XOR<UserSavedCoursesUpdateWithoutUsersInput, UserSavedCoursesUncheckedUpdateWithoutUsersInput>
  }

  export type UserSavedCoursesUpdateManyWithWhereWithoutUsersInput = {
    where: UserSavedCoursesScalarWhereInput
    data: XOR<UserSavedCoursesUpdateManyMutationInput, UserSavedCoursesUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserAnswersCreateManyAssessmentOptionsInput = {
    id?: bigint | number
    attempt_id: bigint | number
    question_id: bigint | number
    answer_text?: string | null
  }

  export type UserAnswersUpdateWithoutAssessmentOptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
    QuizAttempts?: QuizAttemptsUpdateOneRequiredWithoutUserAnswersNestedInput
    AssessmentQuestions?: AssessmentQuestionsUpdateOneRequiredWithoutUserAnswersNestedInput
  }

  export type UserAnswersUncheckedUpdateWithoutAssessmentOptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAnswersUncheckedUpdateManyWithoutAssessmentOptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentOptionsCreateManyAssessmentQuestionsInput = {
    id?: bigint | number
    option_text?: string | null
    is_correct?: boolean | null
  }

  export type UserAnswersCreateManyAssessmentQuestionsInput = {
    id?: bigint | number
    attempt_id: bigint | number
    selected_option_id?: bigint | number | null
    answer_text?: string | null
  }

  export type AssessmentOptionsUpdateWithoutAssessmentQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserAnswers?: UserAnswersUpdateManyWithoutAssessmentOptionsNestedInput
  }

  export type AssessmentOptionsUncheckedUpdateWithoutAssessmentQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserAnswers?: UserAnswersUncheckedUpdateManyWithoutAssessmentOptionsNestedInput
  }

  export type AssessmentOptionsUncheckedUpdateManyWithoutAssessmentQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    option_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserAnswersUpdateWithoutAssessmentQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
    QuizAttempts?: QuizAttemptsUpdateOneRequiredWithoutUserAnswersNestedInput
    AssessmentOptions?: AssessmentOptionsUpdateOneWithoutUserAnswersNestedInput
  }

  export type UserAnswersUncheckedUpdateWithoutAssessmentQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    selected_option_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAnswersUncheckedUpdateManyWithoutAssessmentQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    attempt_id?: BigIntFieldUpdateOperationsInput | bigint | number
    selected_option_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssessmentQuestionsCreateManyAssessmentsInput = {
    id?: bigint | number
    question_text: string
    question_type: $Enums.AssessmentQuestions_question_type
  }

  export type QuizAttemptsCreateManyAssessmentsInput = {
    id?: bigint | number
    user_id: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type AssessmentQuestionsUpdateWithoutAssessmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsUpdateManyWithoutAssessmentQuestionsNestedInput
    UserAnswers?: UserAnswersUpdateManyWithoutAssessmentQuestionsNestedInput
  }

  export type AssessmentQuestionsUncheckedUpdateWithoutAssessmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
    AssessmentOptions?: AssessmentOptionsUncheckedUpdateManyWithoutAssessmentQuestionsNestedInput
    UserAnswers?: UserAnswersUncheckedUpdateManyWithoutAssessmentQuestionsNestedInput
  }

  export type AssessmentQuestionsUncheckedUpdateManyWithoutAssessmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumAssessmentQuestions_question_typeFieldUpdateOperationsInput | $Enums.AssessmentQuestions_question_type
  }

  export type QuizAttemptsUpdateWithoutAssessmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutQuizAttemptsNestedInput
    UserAnswers?: UserAnswersUpdateManyWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptsUncheckedUpdateWithoutAssessmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAnswers?: UserAnswersUncheckedUpdateManyWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptsUncheckedUpdateManyWithoutAssessmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoursesCreateManyCategoriesInput = {
    id?: bigint | number
    instructor_id: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type CoursesUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Users?: UsersUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateManyWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssessmentsCreateManyCourseContentInput = {
    id?: bigint | number
    title?: string | null
    instructions?: string | null
  }

  export type CourseContentCreateManyCourseContentInput = {
    id?: bigint | number
    course_id: bigint | number
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
  }

  export type LessonProgressCreateManyCourseContentInput = {
    id?: bigint | number
    user_id: bigint | number
    is_completed?: boolean | null
    completed_at?: Date | string | null
  }

  export type AssessmentsUpdateWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    AssessmentQuestions?: AssessmentQuestionsUpdateManyWithoutAssessmentsNestedInput
    QuizAttempts?: QuizAttemptsUpdateManyWithoutAssessmentsNestedInput
  }

  export type AssessmentsUncheckedUpdateWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    AssessmentQuestions?: AssessmentQuestionsUncheckedUpdateManyWithoutAssessmentsNestedInput
    QuizAttempts?: QuizAttemptsUncheckedUpdateManyWithoutAssessmentsNestedInput
  }

  export type AssessmentsUncheckedUpdateManyWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseContentUpdateWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUpdateManyWithoutCourseContentNestedInput
    Courses?: CoursesUpdateOneRequiredWithoutCourseContentNestedInput
    other_CourseContent?: CourseContentUpdateManyWithoutCourseContentNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUncheckedUpdateManyWithoutCourseContentNestedInput
    other_CourseContent?: CourseContentUncheckedUpdateManyWithoutCourseContentNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentUncheckedUpdateManyWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
  }

  export type LessonProgressUpdateWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutLessonProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonProgressUncheckedUpdateManyWithoutCourseContentInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificatesCreateManyCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    certificate_url?: string | null
    issued_at?: Date | string | null
  }

  export type CourseContentCreateManyCoursesInput = {
    id?: bigint | number
    parent_id?: bigint | number | null
    title: string
    type: $Enums.CourseContent_type
    video_url?: string | null
    note_content?: string | null
    duration_seconds?: number | null
    order_index: number
  }

  export type CourseTagsCreateManyCoursesInput = {
    id?: bigint | number
    tag_name: string
    tag_type: $Enums.CourseTags_tag_type
  }

  export type EnrollmentsCreateManyCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    enrolled_at?: Date | string | null
  }

  export type PaymentsCreateManyCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    subscription_plan_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ReviewsCreateManyCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    instructor_id?: bigint | number | null
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
  }

  export type ShoppingCartCreateManyCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
    added_at?: Date | string | null
  }

  export type UserSavedCoursesCreateManyCoursesInput = {
    id?: bigint | number
    user_id: bigint | number
  }

  export type CertificatesUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificatesUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificatesUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseContentUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUpdateManyWithoutCourseContentNestedInput
    CourseContent?: CourseContentUpdateOneWithoutOther_CourseContentNestedInput
    other_CourseContent?: CourseContentUpdateManyWithoutCourseContentNestedInput
    LessonProgress?: LessonProgressUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    Assessments?: AssessmentsUncheckedUpdateManyWithoutCourseContentNestedInput
    other_CourseContent?: CourseContentUncheckedUpdateManyWithoutCourseContentNestedInput
    LessonProgress?: LessonProgressUncheckedUpdateManyWithoutCourseContentNestedInput
  }

  export type CourseContentUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseContent_typeFieldUpdateOperationsInput | $Enums.CourseContent_type
    video_url?: NullableStringFieldUpdateOperationsInput | string | null
    note_content?: NullableStringFieldUpdateOperationsInput | string | null
    duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTagsUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_type?: EnumCourseTags_tag_typeFieldUpdateOperationsInput | $Enums.CourseTags_tag_type
  }

  export type CourseTagsUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_type?: EnumCourseTags_tag_typeFieldUpdateOperationsInput | $Enums.CourseTags_tag_type
  }

  export type CourseTagsUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_type?: EnumCourseTags_tag_typeFieldUpdateOperationsInput | $Enums.CourseTags_tag_type
  }

  export type EnrollmentsUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentsUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentsUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentsUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SubscriptionPlans?: SubscriptionPlansUpdateOneWithoutPaymentsNestedInput
    Users?: UsersUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subscription_plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subscription_plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewsUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users_Reviews_instructor_idToUsers?: UsersUpdateOneWithoutReviews_Reviews_instructor_idToUsersNestedInput
    Users_Reviews_user_idToUsers?: UsersUpdateOneRequiredWithoutReviews_Reviews_user_idToUsersNestedInput
  }

  export type ReviewsUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewsUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    instructor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutShoppingCartNestedInput
  }

  export type ShoppingCartUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSavedCoursesUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    Users?: UsersUpdateOneRequiredWithoutUserSavedCoursesNestedInput
  }

  export type UserSavedCoursesUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserSavedCoursesUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserAnswersCreateManyQuizAttemptsInput = {
    id?: bigint | number
    question_id: bigint | number
    selected_option_id?: bigint | number | null
    answer_text?: string | null
  }

  export type UserAnswersUpdateWithoutQuizAttemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
    AssessmentOptions?: AssessmentOptionsUpdateOneWithoutUserAnswersNestedInput
    AssessmentQuestions?: AssessmentQuestionsUpdateOneRequiredWithoutUserAnswersNestedInput
  }

  export type UserAnswersUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    selected_option_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAnswersUncheckedUpdateManyWithoutQuizAttemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_id?: BigIntFieldUpdateOperationsInput | bigint | number
    selected_option_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answer_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentsCreateManySubscriptionPlansInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type SubscriptionsCreateManySubscriptionPlansInput = {
    id?: bigint | number
    user_id: bigint | number
    status: $Enums.Subscriptions_status
    start_date: Date | string
    end_date: Date | string
  }

  export type PaymentsUpdateWithoutSubscriptionPlansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneWithoutPaymentsNestedInput
    Users?: UsersUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutSubscriptionPlansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutSubscriptionPlansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsUpdateWithoutSubscriptionPlansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateWithoutSubscriptionPlansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionsUncheckedUpdateManyWithoutSubscriptionPlansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificatesCreateManyUsersInput = {
    id?: bigint | number
    course_id: bigint | number
    certificate_url?: string | null
    issued_at?: Date | string | null
  }

  export type CoursesCreateManyUsersInput = {
    id?: bigint | number
    title: string
    subtitle?: string | null
    description?: string | null
    category_id: bigint | number
    price?: Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: string | null
    level?: $Enums.Courses_level
    views?: number | null
    enrollments_count?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type EnrollmentsCreateManyUsersInput = {
    id?: bigint | number
    course_id: bigint | number
    enrolled_at?: Date | string | null
  }

  export type LessonProgressCreateManyUsersInput = {
    id?: bigint | number
    content_id: bigint | number
    is_completed?: boolean | null
    completed_at?: Date | string | null
  }

  export type MessagesCreateManyUsers_Messages_receiver_idToUsersInput = {
    id?: bigint | number
    sender_id: bigint | number
    content: string
    created_at?: Date | string | null
  }

  export type MessagesCreateManyUsers_Messages_sender_idToUsersInput = {
    id?: bigint | number
    receiver_id: bigint | number
    content: string
    created_at?: Date | string | null
  }

  export type MultiFactorAuthCreateManyUsersInput = {
    id?: bigint | number
    mfa_type: $Enums.MultiFactorAuth_mfa_type
    secret_key?: string | null
    is_enabled?: boolean | null
    created_at?: Date | string | null
  }

  export type NotificationsCreateManyUsersInput = {
    id?: bigint | number
    message: string
    type?: $Enums.Notifications_type | null
    is_read?: boolean | null
    created_at?: Date | string | null
  }

  export type PaymentsCreateManyUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    subscription_plan_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    method: $Enums.Payments_method
    status: $Enums.Payments_status
    transaction_id?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type QuizAttemptsCreateManyUsersInput = {
    id?: bigint | number
    assessment_id: bigint | number
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type ReviewsCreateManyUsers_Reviews_instructor_idToUsersInput = {
    id?: bigint | number
    user_id: bigint | number
    course_id?: bigint | number | null
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
  }

  export type ReviewsCreateManyUsers_Reviews_user_idToUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    instructor_id?: bigint | number | null
    rating: number
    review_text?: string | null
    created_at?: Date | string | null
  }

  export type ShoppingCartCreateManyUsersInput = {
    id?: bigint | number
    course_id: bigint | number
    added_at?: Date | string | null
  }

  export type SubscriptionsCreateManyUsersInput = {
    id?: bigint | number
    plan_id: bigint | number
    status: $Enums.Subscriptions_status
    start_date: Date | string
    end_date: Date | string
  }

  export type UserSavedCoursesCreateManyUsersInput = {
    id?: bigint | number
    course_id: bigint | number
  }

  export type CertificatesUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificatesUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificatesUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    certificate_url?: NullableStringFieldUpdateOperationsInput | string | null
    issued_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoursesUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUpdateManyWithoutCoursesNestedInput
    Categories?: CategoriesUpdateOneRequiredWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Certificates?: CertificatesUncheckedUpdateManyWithoutCoursesNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutCoursesNestedInput
    CourseTags?: CourseTagsUncheckedUpdateManyWithoutCoursesNestedInput
    Enrollments?: EnrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutCoursesNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutCoursesNestedInput
    ShoppingCart?: ShoppingCartUncheckedUpdateManyWithoutCoursesNestedInput
    UserSavedCourses?: UserSavedCoursesUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumCourses_levelFieldUpdateOperationsInput | $Enums.Courses_level
    views?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    enrolled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonProgressUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CourseContent?: CourseContentUpdateOneRequiredWithoutLessonProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content_id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonProgressUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content_id?: BigIntFieldUpdateOperationsInput | bigint | number
    is_completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessagesUpdateWithoutUsers_Messages_receiver_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users_Messages_sender_idToUsers?: UsersUpdateOneRequiredWithoutMessages_Messages_sender_idToUsersNestedInput
  }

  export type MessagesUncheckedUpdateWithoutUsers_Messages_receiver_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sender_id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessagesUncheckedUpdateManyWithoutUsers_Messages_receiver_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sender_id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessagesUpdateWithoutUsers_Messages_sender_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users_Messages_receiver_idToUsers?: UsersUpdateOneRequiredWithoutMessages_Messages_receiver_idToUsersNestedInput
  }

  export type MessagesUncheckedUpdateWithoutUsers_Messages_sender_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receiver_id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessagesUncheckedUpdateManyWithoutUsers_Messages_sender_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receiver_id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultiFactorAuthUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFieldUpdateOperationsInput | $Enums.MultiFactorAuth_mfa_type
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultiFactorAuthUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFieldUpdateOperationsInput | $Enums.MultiFactorAuth_mfa_type
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultiFactorAuthUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    mfa_type?: EnumMultiFactorAuth_mfa_typeFieldUpdateOperationsInput | $Enums.MultiFactorAuth_mfa_type
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotifications_typeFieldUpdateOperationsInput | $Enums.Notifications_type | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotifications_typeFieldUpdateOperationsInput | $Enums.Notifications_type | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    message?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotifications_typeFieldUpdateOperationsInput | $Enums.Notifications_type | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneWithoutPaymentsNestedInput
    SubscriptionPlans?: SubscriptionPlansUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subscription_plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subscription_plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPayments_methodFieldUpdateOperationsInput | $Enums.Payments_method
    status?: EnumPayments_statusFieldUpdateOperationsInput | $Enums.Payments_status
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAttemptsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Assessments?: AssessmentsUpdateOneRequiredWithoutQuizAttemptsNestedInput
    UserAnswers?: UserAnswersUpdateManyWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assessment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserAnswers?: UserAnswersUncheckedUpdateManyWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assessment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewsUpdateWithoutUsers_Reviews_instructor_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneWithoutReviewsNestedInput
    Users_Reviews_user_idToUsers?: UsersUpdateOneRequiredWithoutReviews_Reviews_user_idToUsersNestedInput
  }

  export type ReviewsUncheckedUpdateWithoutUsers_Reviews_instructor_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewsUncheckedUpdateManyWithoutUsers_Reviews_instructor_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewsUpdateWithoutUsers_Reviews_user_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneWithoutReviewsNestedInput
    Users_Reviews_instructor_idToUsers?: UsersUpdateOneWithoutReviews_Reviews_instructor_idToUsersNestedInput
  }

  export type ReviewsUncheckedUpdateWithoutUsers_Reviews_user_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    instructor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewsUncheckedUpdateManyWithoutUsers_Reviews_user_idToUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    instructor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review_text?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Courses?: CoursesUpdateOneRequiredWithoutShoppingCartNestedInput
  }

  export type ShoppingCartUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionPlans?: SubscriptionPlansUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumSubscriptions_statusFieldUpdateOperationsInput | $Enums.Subscriptions_status
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSavedCoursesUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    Courses?: CoursesUpdateOneRequiredWithoutUserSavedCoursesNestedInput
  }

  export type UserSavedCoursesUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserSavedCoursesUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AssessmentOptionsCountOutputTypeDefaultArgs instead
     */
    export type AssessmentOptionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentOptionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentQuestionsCountOutputTypeDefaultArgs instead
     */
    export type AssessmentQuestionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentQuestionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentsCountOutputTypeDefaultArgs instead
     */
    export type AssessmentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriesCountOutputTypeDefaultArgs instead
     */
    export type CategoriesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseContentCountOutputTypeDefaultArgs instead
     */
    export type CourseContentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseContentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoursesCountOutputTypeDefaultArgs instead
     */
    export type CoursesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizAttemptsCountOutputTypeDefaultArgs instead
     */
    export type QuizAttemptsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizAttemptsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlansCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionPlansCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlansCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentOptionsDefaultArgs instead
     */
    export type AssessmentOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentOptionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentQuestionsDefaultArgs instead
     */
    export type AssessmentQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentQuestionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentsDefaultArgs instead
     */
    export type AssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriesDefaultArgs instead
     */
    export type CategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificatesDefaultArgs instead
     */
    export type CertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificatesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseContentDefaultArgs instead
     */
    export type CourseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseTagsDefaultArgs instead
     */
    export type CourseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseTagsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoursesDefaultArgs instead
     */
    export type CoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnrollmentsDefaultArgs instead
     */
    export type EnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnrollmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonProgressDefaultArgs instead
     */
    export type LessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessagesDefaultArgs instead
     */
    export type MessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MultiFactorAuthDefaultArgs instead
     */
    export type MultiFactorAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MultiFactorAuthDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationsDefaultArgs instead
     */
    export type NotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentsDefaultArgs instead
     */
    export type PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizAttemptsDefaultArgs instead
     */
    export type QuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizAttemptsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewsDefaultArgs instead
     */
    export type ReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShoppingCartDefaultArgs instead
     */
    export type ShoppingCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShoppingCartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPlansDefaultArgs instead
     */
    export type SubscriptionPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPlansDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionsDefaultArgs instead
     */
    export type SubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAnswersDefaultArgs instead
     */
    export type UserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAnswersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSavedCoursesDefaultArgs instead
     */
    export type UserSavedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSavedCoursesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersDefaultArgs instead
     */
    export type UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}